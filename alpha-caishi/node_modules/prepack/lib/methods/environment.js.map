{"version":3,"sources":["../../src/methods/environment.js"],"names":["t","EnvironmentImplementation","realm","V","thisValue","undefined","base","GetBase","type","getType","referencedName","reportIntrospectionError","val","_dereference","simplifyAndRefineAbstractValue","simplifyAndRefineAbstractCondition","IsUnresolvableReference","createErrorThrowCompletion","intrinsics","ReferenceError","toString","IsPropertyReference","ToObjectPartial","HasPrimitiveBase","$GetPartial","GetReferencedNamePartial","GetReferencedName","GetBindingValue","IsStrictReference","strict","E","active","env","activeLexicalEnvironments","add","envRec","environmentRecord","parent","node","Object","keys","getOuterBindingIdentifiers","properties","prop","ContainsExpression","elements","elem","argument","name","getRunningContext","lexicalEnvironment","GetIdentifierReference","lex","exists","HasBinding","outer","W","InitializeBinding","strictCode","body","declarations","kind","push","d","BoundNames","dn","SyntaxError","CreateImmutableBinding","CreateMutableBinding","fn","fo","evaluate","G","objRec","dclRec","globalRec","$ObjectRecord","$GlobalThisValue","$DeclarativeRecord","$VarNames","O","F","newTarget","$FunctionObject","$ThisMode","$ThisBindingStatus","home","$HomeObject","$NewTarget","$Environment","contextStack","length","ec","i","function","$ScriptOrModule","ScriptOrModule","HasThisBinding","GetThisEnvironment","GetThisBinding","value","environment","iterator","iteratorRecord","$Iterator","$Done","result","IteratorBindingInitialization","error","completion","property","P","KeyedBindingInitialization","InitializeBoundName","decl","BindingInitialization","id","formals","restEl","lastFormal","slice","param","next","e","Initializer","right","left","bindingId","lhs","ResolveBinding","v","defaultValue","GetValue","hasNameProperty","SetFunctionName","PutValue","InitializeReferencedBinding","A","ArrayCreate","n","nextValue","status","CreateDataProperty","ast","propertyName"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport {\n  AbstractValue,\n  UndefinedValue,\n  NullValue,\n  NumberValue,\n  BooleanValue,\n  SymbolValue,\n  ECMAScriptFunctionValue,\n  ObjectValue,\n  StringValue,\n  Value,\n  AbstractObjectValue,\n} from \"../values/index.js\";\nimport {\n  ObjectEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  EnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  GlobalEnvironmentRecord,\n  Reference,\n  LexicalEnvironment,\n} from \"../environment.js\";\nimport { NormalCompletion, AbruptCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport {\n  GetV,\n  GetThisValue,\n  RequireObjectCoercible,\n  HasSomeCompatibleType,\n  GetIterator,\n  IteratorStep,\n  IteratorValue,\n  IteratorClose,\n  IsAnonymousFunctionDefinition,\n  HasOwnProperty,\n} from \"./index.js\";\nimport { Create, Functions, Properties, To } from \"../singletons.js\";\nimport type {\n  BabelNode,\n  BabelNodeVariableDeclaration,\n  BabelNodeIdentifier,\n  BabelNodeRestElement,\n  BabelNodeObjectPattern,\n  BabelNodeArrayPattern,\n  BabelNodeStatement,\n  BabelNodeLVal,\n  BabelNodePattern,\n} from \"babel-types\";\n\nexport class EnvironmentImplementation {\n  // ECMA262 6.2.3\n  // IsSuperReference(V). Returns true if this reference has a thisValue component.\n  IsSuperReference(realm: Realm, V: Reference): boolean {\n    return V.thisValue !== undefined;\n  }\n\n  // ECMA262 6.2.3\n  // HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\n  HasPrimitiveBase(realm: Realm, V: Reference): boolean {\n    let base = this.GetBase(realm, V);\n    // void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord | AbstractValue;\n    if (!base || base instanceof EnvironmentRecord) return false;\n    let type = base.getType();\n    return type === BooleanValue || type === StringValue || type === SymbolValue || type === NumberValue;\n  }\n\n  // ECMA262 6.2.3\n  // GetReferencedName(V). Returns the referenced name component of the reference V.\n  GetReferencedName(realm: Realm, V: Reference): string | SymbolValue {\n    if (V.referencedName instanceof AbstractValue) {\n      AbstractValue.reportIntrospectionError(V.referencedName);\n      throw new FatalError();\n    }\n    return V.referencedName;\n  }\n\n  GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue {\n    return V.referencedName;\n  }\n\n  // ECMA262 6.2.3.1\n  GetValue(realm: Realm, V: Reference | Value): Value {\n    let val = this._dereference(realm, V);\n    if (val instanceof AbstractValue) return realm.simplifyAndRefineAbstractValue(val);\n    return val;\n  }\n\n  GetConditionValue(realm: Realm, V: Reference | Value): Value {\n    let val = this._dereference(realm, V);\n    if (val instanceof AbstractValue) return realm.simplifyAndRefineAbstractCondition(val);\n    return val;\n  }\n\n  _dereference(realm: Realm, V: Reference | Value): Value {\n    // This step is not necessary as we propagate completions with exceptions.\n    // 1. ReturnIfAbrupt(V).\n\n    // 2. If Type(V) is not Reference, return V.\n    if (!(V instanceof Reference)) return V;\n\n    // 3. Let base be GetBase(V).\n    let base = this.GetBase(realm, V);\n\n    // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.\n    if (this.IsUnresolvableReference(realm, V)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.ReferenceError,\n        `${V.referencedName.toString()} is not defined`\n      );\n    }\n\n    // 5. If IsPropertyReference(V) is true, then\n    if (this.IsPropertyReference(realm, V)) {\n      if (base instanceof AbstractValue) {\n        // Ensure that abstract values are coerced to objects. This might yield\n        // an operation that might throw.\n        base = To.ToObjectPartial(realm, base);\n      }\n      // a. If HasPrimitiveBase(V) is true, then\n      if (this.HasPrimitiveBase(realm, V)) {\n        // i. Assert: In this case, base will never be null or undefined.\n        invariant(base instanceof Value && !HasSomeCompatibleType(base, UndefinedValue, NullValue));\n\n        // ii. Let base be To.ToObject(base).\n        base = To.ToObjectPartial(realm, base);\n      }\n      invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n      // b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).\n      return base.$GetPartial(this.GetReferencedNamePartial(realm, V), GetThisValue(realm, V));\n    }\n\n    // 6. Else base must be an Environment Record,\n    if (base instanceof EnvironmentRecord) {\n      // a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).\n      let referencedName = this.GetReferencedName(realm, V);\n      invariant(typeof referencedName === \"string\");\n      return base.GetBindingValue(referencedName, this.IsStrictReference(realm, V));\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 6.2.3\n  // IsStrictReference(V). Returns the strict reference flag component of the reference V.\n  IsStrictReference(realm: Realm, V: Reference): boolean {\n    return V.strict;\n  }\n\n  // ECMA262 6.2.3\n  // IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\n  IsPropertyReference(realm: Realm, V: Reference): boolean {\n    // V.base is AbstractValue | void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;\n    return V.base instanceof AbstractValue || V.base instanceof ObjectValue || this.HasPrimitiveBase(realm, V);\n  }\n\n  // ECMA262 6.2.3\n  // GetBase(V). Returns the base value component of the reference V.\n  GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord {\n    return V.base;\n  }\n\n  // ECMA262 6.2.3\n  // IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\n  IsUnresolvableReference(realm: Realm, V: Reference): boolean {\n    return !V.base;\n  }\n\n  // ECMA262 8.1.2.2\n  NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment, active: boolean = true): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    if (active) realm.activeLexicalEnvironments.add(env);\n\n    // 2. Let envRec be a new declarative Environment Record containing no bindings.\n    let envRec = new DeclarativeEnvironmentRecord(realm);\n\n    // 3. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 4. Set the outer lexical environment reference of env to E.\n    env.parent = E;\n\n    // 5. Return env.\n    return env;\n  }\n\n  BoundNames(realm: Realm, node: BabelNode): Array<string> {\n    return Object.keys(t.getOuterBindingIdentifiers(node));\n  }\n\n  // ECMA262 13.3.3.2\n  ContainsExpression(realm: Realm, node: ?BabelNode): boolean {\n    if (!node) {\n      return false;\n    }\n    switch (node.type) {\n      case \"ObjectPattern\":\n        for (let prop of ((node: any): BabelNodeObjectPattern).properties) {\n          if (this.ContainsExpression(realm, prop)) return true;\n        }\n        return false;\n      case \"ArrayPattern\":\n        for (let elem of ((node: any): BabelNodeArrayPattern).elements) {\n          if (this.ContainsExpression(realm, elem)) return true;\n        }\n        return false;\n      case \"RestElement\":\n        return this.ContainsExpression(realm, ((node: any): BabelNodeRestElement).argument);\n      case \"AssignmentPattern\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // ECMA262 8.3.2\n  ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference {\n    // 1. If env was not passed or if env is undefined, then\n    if (!env) {\n      // a. Let env be the running execution context's LexicalEnvironment.\n      env = realm.getRunningContext().lexicalEnvironment;\n    }\n\n    // 2. Assert: env is a Lexical Environment.\n    invariant(env instanceof LexicalEnvironment, \"expected lexical environment\");\n\n    // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.\n\n    // 4. Return ? GetIdentifierReference(env, name, strict).\n    return this.GetIdentifierReference(realm, env, name, strict);\n  }\n\n  // ECMA262 8.1.2.1\n  GetIdentifierReference(realm: Realm, lex: ?LexicalEnvironment, name: string, strict: boolean): Reference {\n    // 1. If lex is the value null, then\n    if (!lex) {\n      // a. Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict.\n      return new Reference(undefined, name, strict);\n    }\n\n    // 2. Let envRec be lex's EnvironmentRecord.\n    let envRec = lex.environmentRecord;\n\n    // 3. Let exists be ? envRec.HasBinding(name).\n    let exists = envRec.HasBinding(name);\n\n    // 4. If exists is true, then\n    if (exists) {\n      // a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict.\n      return new Reference(envRec, name, strict);\n    } else {\n      // 5. Else,\n      // a. Let outer be the value of lex's outer environment reference.\n      let outer = lex.parent;\n\n      // b. Return ? GetIdentifierReference(outer, name, strict).\n      return this.GetIdentifierReference(realm, outer, name, strict);\n    }\n  }\n\n  // ECMA262 6.2.3.4\n  InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value {\n    // 1. ReturnIfAbrupt(V).\n    // 2. ReturnIfAbrupt(W).\n\n    // 3. Assert: Type(V) is Reference.\n    invariant(V instanceof Reference, \"expected reference\");\n\n    // 4. Assert: IsUnresolvableReference(V) is false.\n    invariant(!this.IsUnresolvableReference(realm, V), \"expected resolvable reference\");\n\n    // 5. Let base be GetBase(V).\n    let base = this.GetBase(realm, V);\n\n    // 6. Assert: base is an Environment Record.\n    invariant(base instanceof EnvironmentRecord, \"expected environment record\");\n\n    // 7. Return base.InitializeBinding(GetReferencedName(V), W).\n    let referencedName = this.GetReferencedName(realm, V);\n    invariant(typeof referencedName === \"string\");\n    return base.InitializeBinding(referencedName, W);\n  }\n\n  // ECMA262 13.2.14\n  BlockDeclarationInstantiation(\n    realm: Realm,\n    strictCode: boolean,\n    body: Array<BabelNodeStatement>,\n    env: LexicalEnvironment\n  ) {\n    // 1. Let envRec be env's EnvironmentRecord.\n    let envRec = env.environmentRecord;\n\n    // 2. Assert: envRec is a declarative Environment Record.\n    invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n\n    // 3. Let declarations be the LexicallyScopedDeclarations of code.\n    let declarations = [];\n    for (let node of body) {\n      if (\n        node.type === \"ClassDeclaration\" ||\n        node.type === \"FunctionDeclaration\" ||\n        (node.type === \"VariableDeclaration\" && node.kind !== \"var\")\n      ) {\n        declarations.push(node);\n      }\n    }\n\n    // 4. For each element d in declarations do\n    for (let d of declarations) {\n      // a. For each element dn of the BoundNames of d do\n      for (let dn of this.BoundNames(realm, d)) {\n        if (envRec.HasBinding(dn)) {\n          //ECMA262 13.2.1\n          throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, dn + \" already declared\");\n        }\n        // i. If IsConstantDeclaration of d is true, then\n        if (d.type === \"VariableDeclaration\" && d.kind === \"const\") {\n          // 1. Perform ! envRec.CreateImmutableBinding(dn, true).\n          envRec.CreateImmutableBinding(dn, true);\n        } else {\n          // ii. Else,\n          // 1. Perform ! envRec.CreateMutableBinding(dn, false).\n          envRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then\n      if (d.type === \"FunctionDeclaration\") {\n        // i. Let fn be the sole element of the BoundNames of d.\n        let fn = this.BoundNames(realm, d)[0];\n\n        // ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.\n        let fo = env.evaluate(d, strictCode);\n        invariant(fo instanceof Value);\n\n        // iii. Perform envRec.InitializeBinding(fn, fo).\n        envRec.InitializeBinding(fn, fo);\n      }\n    }\n  }\n\n  // ECMA262 8.1.2.5\n  NewGlobalEnvironment(\n    realm: Realm,\n    G: ObjectValue | AbstractObjectValue,\n    thisValue: ObjectValue | AbstractObjectValue\n  ) {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n\n    // 2. Let objRec be a new object Environment Record containing G as the binding object.\n    let objRec = new ObjectEnvironmentRecord(realm, G);\n\n    // 3. Let dclRec be a new declarative Environment Record containing no bindings.\n    let dclRec = new DeclarativeEnvironmentRecord(realm);\n\n    // 4. Let globalRec be a new global Environment Record.\n    let globalRec = new GlobalEnvironmentRecord(realm);\n\n    // 5. Set globalRec.[[ObjectRecord]] to objRec.\n    globalRec.$ObjectRecord = objRec;\n\n    // 6. Set globalRec.[[GlobalThisValue]] to thisValue.\n    globalRec.$GlobalThisValue = thisValue;\n\n    // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.\n    globalRec.$DeclarativeRecord = dclRec;\n\n    // 8. Set globalRec.[[VarNames]] to a new empty List.\n    globalRec.$VarNames = [];\n\n    // 9. Set env's EnvironmentRecord to globalRec.\n    env.environmentRecord = globalRec;\n    realm.activeLexicalEnvironments.add(env);\n\n    // 10. Set the outer lexical environment reference of env to null.\n    env.parent = null;\n\n    // 11. Return env.\n    return env;\n  }\n\n  // ECMA262 8.1.2.3\n  NewObjectEnvironment(realm: Realm, O: ObjectValue | AbstractObjectValue, E: LexicalEnvironment): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    realm.activeLexicalEnvironments.add(env);\n\n    // 2. Let envRec be a new object Environment Record containing O as the binding object.\n    let envRec = new ObjectEnvironmentRecord(realm, O);\n\n    // 3. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 4. Set the outer lexical environment reference of env to E.\n    env.parent = E;\n\n    // 5. Return env.\n    return env;\n  }\n\n  // ECMA262 8.1.2.4\n  NewFunctionEnvironment(realm: Realm, F: ECMAScriptFunctionValue, newTarget?: ObjectValue): LexicalEnvironment {\n    // 1. Assert: F is an ECMAScript function.\n    invariant(F instanceof ECMAScriptFunctionValue, \"expected a function\");\n\n    // 2. Assert: Type(newTarget) is Undefined or Object.\n    invariant(\n      newTarget === undefined || newTarget instanceof ObjectValue,\n      \"expected undefined or object value for new target\"\n    );\n\n    // 3. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    realm.activeLexicalEnvironments.add(env);\n\n    // 4. Let envRec be a new function Environment Record containing no bindings.\n    let envRec = new FunctionEnvironmentRecord(realm);\n\n    // 5. Set envRec.[[FunctionObject]] to F.\n    envRec.$FunctionObject = F;\n\n    // 6. If F's [[ThisMode]] internal slot is lexical, set envRec.[[ThisBindingStatus]] to \"lexical\".\n    if (F.$ThisMode === \"lexical\") {\n      envRec.$ThisBindingStatus = \"lexical\";\n    } else {\n      // 7. Else, set envRec.[[ThisBindingStatus]] to \"uninitialized\".\n      envRec.$ThisBindingStatus = \"uninitialized\";\n    }\n\n    // 8. Let home be the value of F's [[HomeObject]] internal slot.\n    let home = F.$HomeObject;\n\n    // 9. Set envRec.[[HomeObject]] to home.\n    envRec.$HomeObject = home;\n\n    // 10. Set envRec.[[NewTarget]] to newTarget.\n    envRec.$NewTarget = newTarget;\n\n    // 11. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot.\n    env.parent = F.$Environment;\n\n    // 13. Return env.\n    return env;\n  }\n\n  // ECMA262 8.3.1\n  GetActiveScriptOrModule(realm: Realm) {\n    // The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the active function object.\n    // GetActiveScriptOrModule performs the following steps:\n    //\n    // If the execution context stack is empty, return null.\n    if (realm.contextStack.length === 0) return null;\n    // Let ec be the topmost execution context on the execution context stack whose Function component's [[ScriptOrModule]] component is not null.\n    // If such an execution context exists, return ec's Function component's [[ScriptOrModule]] slot's value.\n    let ec;\n    for (let i = realm.contextStack.length - 1; i >= 0; i--) {\n      ec = realm.contextStack[i];\n      let F = ec.function;\n      if (F == null) continue;\n      if (F.$ScriptOrModule instanceof Object) {\n        return F.$ScriptOrModule;\n      }\n    }\n    // Otherwise, let ec be the running execution context.\n    ec = realm.getRunningContext();\n    // Assert: ec's ScriptOrModule component is not null.\n    invariant(ec.ScriptOrModule !== null);\n    // Return ec's ScriptOrModule component.\n    return ec.ScriptOrModule;\n  }\n\n  // ECMA262 8.3.3\n  GetThisEnvironment(realm: Realm): EnvironmentRecord {\n    // 1. Let lex be the running execution context's LexicalEnvironment.\n    let lex = realm.getRunningContext().lexicalEnvironment;\n\n    // 2. Repeat\n    while (true) {\n      // a. Let envRec be lex's EnvironmentRecord.\n      let envRec = lex.environmentRecord;\n\n      // b. Let exists be envRec.HasThisBinding().\n      let exists = envRec.HasThisBinding();\n\n      // c. If exists is true, return envRec.\n      if (exists) return envRec;\n\n      // d. Let outer be the value of lex's outer environment reference.\n      let outer = lex.parent;\n      invariant(outer);\n\n      // e. Let lex be outer.\n      lex = outer;\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 8.3.4\n  ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be GetThisEnvironment( ).\n    let envRec = this.GetThisEnvironment(realm);\n\n    // 2. Return ? envRec.GetThisBinding().\n    return envRec.GetThisBinding();\n  }\n\n  BindingInitialization(\n    realm: Realm,\n    node: BabelNodeLVal | BabelNodeVariableDeclaration,\n    value: Value,\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value {\n    if (node.type === \"ArrayPattern\") {\n      // ECMA262 13.3.3.5\n      // 1. Let iterator be ? GetIterator(value).\n      let iterator = GetIterator(realm, value);\n\n      // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n      let iteratorRecord = {\n        $Iterator: iterator,\n        $Done: false,\n      };\n\n      let result;\n\n      // 3. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.\n      try {\n        result = this.IteratorBindingInitialization(realm, node.elements, iteratorRecord, strictCode, environment);\n      } catch (error) {\n        // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n        if (iteratorRecord.$Done === false && error instanceof AbruptCompletion) {\n          throw IteratorClose(realm, iterator, error);\n        }\n        throw error;\n      }\n\n      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n      if (iteratorRecord.$Done === false) {\n        let completion = IteratorClose(realm, iterator, new NormalCompletion(realm.intrinsics.undefined));\n        if (completion instanceof AbruptCompletion) {\n          throw completion;\n        }\n      }\n\n      // 5. Return result.\n      return result;\n    } else if (node.type === \"ObjectPattern\") {\n      // ECMA262 13.3.3.5\n      // BindingPattern : ObjectBindingPattern\n\n      // 1. Perform ? RequireObjectCoercible(value).\n      RequireObjectCoercible(realm, value);\n\n      // 2. Return the result of performing BindingInitialization for ObjectBindingPattern using value and environment as arguments.\n      for (let property of node.properties) {\n        let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n        // 1. Let P be the result of evaluating PropertyName.\n        let P = EvalPropertyName(property, env, realm, strictCode);\n\n        // 2. ReturnIfAbrupt(P).\n\n        // 3. Return the result of performing KeyedBindingInitialization for BindingElement using value, environment, and P as arguments.\n        this.KeyedBindingInitialization(realm, property.value, value, strictCode, environment, P);\n      }\n    } else if (node.type === \"Identifier\") {\n      // ECMA262 12.1.5\n      // 1. Let name be StringValue of Identifier.\n      let name = ((node: any): BabelNodeIdentifier).name;\n\n      // 2. Return ? InitializeBoundName(name, value, environment).\n      return this.InitializeBoundName(realm, name, value, environment);\n    } else {\n      invariant(node.type === \"VariableDeclaration\");\n      // ECMA262 13.7.5.9\n      for (let decl of ((node: any): BabelNodeVariableDeclaration).declarations) {\n        this.BindingInitialization(realm, decl.id, value, strictCode, environment);\n      }\n    }\n  }\n\n  // ECMA262 13.3.3.6\n  // ECMA262 14.1.19\n  IteratorBindingInitialization(\n    realm: Realm,\n    formals: $ReadOnlyArray<BabelNodeLVal | null>,\n    iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ) {\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n    // Check if the last formal is a rest element. If so then we want to save the\n    // element and handle it separately after we iterate through the other\n    // formals. This also enforces that a rest element may only ever be in the\n    // last position.\n    let restEl;\n    if (formals.length > 0) {\n      let lastFormal = formals[formals.length - 1];\n      if (lastFormal !== null && lastFormal.type === \"RestElement\") {\n        restEl = lastFormal;\n        formals = formals.slice(0, -1);\n      }\n    }\n\n    for (let param of formals) {\n      if (param === null) {\n        // Elision handling in IteratorDestructuringAssignmentEvaluation\n\n        // 1. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n        // 2. Return NormalCompletion(empty).\n        continue;\n      }\n\n      let Initializer;\n      if (param.type === \"AssignmentPattern\") {\n        Initializer = param.right;\n        param = param.left;\n      }\n\n      if (param.type === \"Identifier\") {\n        // SingleNameBinding : BindingIdentifier Initializer\n\n        // 1. Let bindingId be StringValue of BindingIdentifier.\n        let bindingId = param.name;\n\n        // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n        let lhs = this.ResolveBinding(realm, param.name, strictCode, environment);\n\n        // Initialized later in the algorithm.\n        let v;\n\n        // 3. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next: ObjectValue | false;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n            // Normally this assignment would be done in step 4, but we do it\n            // here so that Flow knows `v` will always be initialized by step 5.\n            v = realm.intrinsics.undefined;\n          } else {\n            // e. Else,\n            // i. Let v be IteratorValue(next).\n            try {\n              v = IteratorValue(realm, next);\n            } catch (e) {\n              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n              if (e instanceof AbruptCompletion) {\n                iteratorRecord.$Done = true;\n              }\n              // iii. ReturnIfAbrupt(v).\n              throw e;\n            }\n          }\n        } else {\n          // 4. If iteratorRecord.[[Done]] is true, let v be undefined.\n          v = realm.intrinsics.undefined;\n        }\n\n        // 5. If Initializer is present and v is undefined, then\n        if (Initializer && v instanceof UndefinedValue) {\n          // a. Let defaultValue be the result of evaluating Initializer.\n          let defaultValue = env.evaluate(Initializer, strictCode);\n\n          // b. Let v be ? GetValue(defaultValue).\n          v = this.GetValue(realm, defaultValue);\n\n          // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n          if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n            // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n            let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n            // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n            if (hasNameProperty === false) {\n              Functions.SetFunctionName(realm, v, bindingId);\n            }\n          }\n        }\n\n        // 6. If environment is undefined, return ? PutValue(lhs, v).\n        if (!environment) {\n          Properties.PutValue(realm, lhs, v);\n          continue;\n        }\n\n        // 7. Return InitializeReferencedBinding(lhs, v).\n        this.InitializeReferencedBinding(realm, lhs, v);\n        continue;\n      } else {\n        invariant(param.type === \"ObjectPattern\" || param.type === \"ArrayPattern\");\n        // BindingElement : BindingPatternInitializer\n\n        // Initialized later in the algorithm.\n        let v;\n\n        // 1. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n            // Normally this assignment would be done in step 2, but we do it\n            // here so that Flow knows `v` will always be initialized by step 3.\n            v = realm.intrinsics.undefined;\n          } else {\n            // e. Else,\n            // i. Let v be IteratorValue(next).\n            try {\n              v = IteratorValue(realm, next);\n            } catch (e) {\n              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n              if (e instanceof AbruptCompletion) {\n                iteratorRecord.$Done = true;\n              }\n              // iii. ReturnIfAbrupt(v).\n              throw e;\n            }\n          }\n        } else {\n          // 2. If iteratorRecord.[[Done]] is true, let v be undefined.\n          v = realm.intrinsics.undefined;\n        }\n\n        // 3. If Initializer is present and v is undefined, then\n        if (Initializer && v instanceof UndefinedValue) {\n          // a. Let defaultValue be the result of evaluating Initializer.\n          let defaultValue = env.evaluate(Initializer, strictCode);\n\n          // b. Let v be ? GetValue(defaultValue).\n          v = this.GetValue(realm, defaultValue);\n        }\n\n        // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.\n        this.BindingInitialization(realm, param, v, strictCode, environment);\n        continue;\n      }\n    }\n\n    // Handle the rest element if we have one.\n    if (restEl && restEl.argument.type === \"Identifier\") {\n      // BindingRestElement : ...BindingIdentifier\n\n      // 1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).\n      let lhs = this.ResolveBinding(realm, restEl.argument.name, strictCode, environment);\n\n      // 2. Let A be ArrayCreate(0).\n      let A = Create.ArrayCreate(realm, 0);\n\n      // 3. Let n be 0.\n      let n = 0;\n\n      // 4. Repeat,\n      while (true) {\n        // Initialized later in the algorithm.\n        let next: ObjectValue | false;\n\n        // a. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // iv. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n\n        // b. If iteratorRecord.[[Done]] is true, then\n        if (iteratorRecord.$Done === true) {\n          // i. If environment is undefined, return ? PutValue(lhs, A).\n          if (!environment) {\n            Properties.PutValue(realm, lhs, A);\n            break;\n          }\n\n          // ii. Return InitializeReferencedBinding(lhs, A).\n          this.InitializeReferencedBinding(realm, lhs, A);\n          break;\n        }\n\n        // Given the nature of the algorithm this should always be true, however\n        // it is difficult to arrange the code in such a way where Flow's control\n        // flow analysis will pick that up, so we add an invariant here.\n        invariant(next instanceof ObjectValue);\n\n        // c. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // e. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // g. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // h. Increment n by 1.\n        n += 1;\n      }\n    } else if (restEl) {\n      invariant(restEl.argument.type === \"ArrayPattern\" || restEl.argument.type === \"ObjectPattern\");\n      // 1. Let A be ArrayCreate(0).\n      let A = Create.ArrayCreate(realm, 0);\n\n      // 2. Let n be 0.\n      let n = 0;\n\n      // 3. Repeat,\n      while (true) {\n        // Initialized later in the algorithm.\n        let next;\n\n        // a. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // iv. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n\n        // b. If iteratorRecord.[[Done]] is true, then\n        if (iteratorRecord.$Done === true) {\n          // i. Return the result of performing BindingInitialization of BindingPattern with A and environment as the arguments.\n          this.BindingInitialization(realm, restEl.argument, A, strictCode, environment);\n          break;\n        }\n\n        // Given the nature of the algorithm this should always be true, however\n        // it is difficult to arrange the code in such a way where Flow's control\n        // flow analysis will pick that up, so we add an invariant here.\n        invariant(next instanceof ObjectValue);\n\n        // c. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // e. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // g. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // h. Increment n by 1.\n        n += 1;\n      }\n    }\n  }\n\n  // ECMA262 12.1.5.1\n  InitializeBoundName(\n    realm: Realm,\n    name: string,\n    value: Value,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value {\n    // 1. Assert: Type(name) is String.\n    invariant(typeof name === \"string\", \"expected name to be a string\");\n\n    // 2. If environment is not undefined, then\n    if (environment) {\n      // a. Let env be the EnvironmentRecord component of environment.\n      let env = environment.environmentRecord;\n\n      // b. Perform env.InitializeBinding(name, value).\n      env.InitializeBinding(name, value);\n\n      // c. Return NormalCompletion(undefined).\n      return realm.intrinsics.undefined;\n    } else {\n      // 3. Else,\n      // a. Let lhs be ResolveBinding(name).\n      // Note that the undefined environment implies non-strict.\n      let lhs = this.ResolveBinding(realm, name, false);\n\n      // b. Return ? PutValue(lhs, value).\n      return Properties.PutValue(realm, lhs, value);\n    }\n  }\n\n  // ECMA262 12.3.1.3 and 13.7.5.6\n  IsDestructuring(ast: BabelNode): boolean {\n    switch (ast.type) {\n      case \"VariableDeclaration\":\n        for (let decl of ((ast: any): BabelNodeVariableDeclaration).declarations) {\n          switch (decl.type) {\n            case \"VariableDeclarator\":\n              switch (decl.id.type) {\n                case \"ArrayPattern\":\n                case \"AssignmentPattern\":\n                case \"ObjectPattern\":\n                  return true;\n                default:\n                  break;\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        return false;\n      case \"ArrayLiteral\":\n      case \"ObjectLiteral\":\n        return true;\n      case \"ArrayPattern\":\n      case \"ObjectPattern\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // ECMA262 13.3.3.7\n  KeyedBindingInitialization(\n    realm: Realm,\n    node: BabelNodeIdentifier | BabelNodePattern,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment,\n    propertyName: PropertyKeyValue\n  ): void | boolean | Value {\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n    let Initializer;\n    if (node.type === \"AssignmentPattern\") {\n      Initializer = node.right;\n      node = node.left;\n    }\n\n    if (node.type === \"Identifier\") {\n      // SingleNameBinding : BindingIdentifier Initializer\n\n      // 1. Let bindingId be StringValue of BindingIdentifier.\n      let bindingId = node.name;\n\n      // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n      let lhs = this.ResolveBinding(realm, bindingId, strictCode, environment);\n\n      // 3. Let v be ? GetV(value, propertyName).\n      let v = GetV(realm, value, propertyName);\n\n      // 4. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = this.GetValue(realm, defaultValue);\n\n        // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n        if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n          // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n          let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n          // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n          if (hasNameProperty === false) {\n            Functions.SetFunctionName(realm, v, bindingId);\n          }\n        }\n      }\n\n      // 5. If environment is undefined, return ? PutValue(lhs, v).\n      if (!environment) return Properties.PutValue(realm, lhs, v);\n\n      // 6. Return InitializeReferencedBinding(lhs, v).\n      return this.InitializeReferencedBinding(realm, lhs, v);\n    } else if (node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\") {\n      // BindingElement : BindingPattern Initializer\n\n      // 1. Let v be ? GetV(value, propertyName).\n      let v = GetV(realm, value, propertyName);\n\n      // 2. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = this.GetValue(realm, defaultValue);\n      }\n\n      // 3. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.\n      return this.BindingInitialization(realm, node, v, strictCode, env);\n    }\n  }\n}\n"]}