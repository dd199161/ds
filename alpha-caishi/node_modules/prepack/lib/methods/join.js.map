{"version":3,"sources":["../../src/methods/join.js"],"names":["joinGenerators","realm","joinCondition","generator1","generator2","result","empty","joinArrays","v1","v2","getAbstractValue","e","joinArraysOfValues","joinArrayOfsMapEntries","a1","a2","intrinsics","n","Math","max","length","i","$Key","$Value","key1","val1","key2","val2","undefined","key3","val3","JoinImplementation","c1","c2","getCapturedEffects","stopEffectCaptureAndUndoEffects","joined_effects","joinPossiblyNormalCompletionWithAbruptCompletion","applyEffects","completionOrValue","completion","value","leftCompletion","rightCompletion","resultValue","updatePossiblyNormalCompletionWithValue","composePossiblyNormalCompletions","pnc","c","savedEffects","composedPath","pathConditions","concat","savedPathConditions","consequent","alternate","alternateEffects","g","b","p","o","newAlternateEffects","consequentEffects","new_alternate","newConsequentEffects","new_consequent","subsequentEffects","v","composeEffects","updatePossiblyNormalCompletionWithSubsequentEffects","ac","joinEffects","alternate_effects","composedEffects","consequent_effects","joinValuesAsConditional","joinPossiblyNormalCompletionWithValue","joinValueWithPossiblyNormalCompletion","a","rJoinCondition","cp","ap","createFromLogicalOp","notA","createFromUnaryOp","notC","ce1","ce2","ae1","ae2","rce","rae","rc","ra","rv","nested_effects","e1","joinEffectsAndPromoteNestedReturnCompletions","e2","currentLocation","r1","r2","r1jr2c","or","r1jr2a","notR2jc","r2jr1c","r2jr1a","notR1jc","empty_effects","negation","removeNormalEffects","result1","gen1","bindings1","properties1","createdObj1","result2","gen2","bindings2","properties2","createdObj2","joinResults","bindings","joinBindings","properties","joinPropertyBindings","createdObjects","Set","forEach","add","generator","reportIntrospectionError","target","expressionLocation","val","joinValues","location","joinPossiblyNormalCompletions","composeGenerators","m1","m2","join","m3","Map","key","map1","get","set","map2","has","b1","b2","l1","hasLeaked","l2","joinMaps","Array","isArray","throwIfNotConcrete","condition","createFromConditionalOp","d1","d2","object","descriptor","joinDescriptors","clone_with_abstract_value","d","d3","dc","dcValue","elem0","map","descriptor2","descriptor1"],"mappings":"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","file":"join.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type {\n  Bindings,\n  BindingEntry,\n  Effects,\n  EvaluationResult,\n  PropertyBindings,\n  CreatedObjects,\n  Realm,\n} from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  PossiblyNormalCompletion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ObjectValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\n\nfunction joinGenerators(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  generator1: Generator,\n  generator2: Generator\n): Generator {\n  let result = new Generator(realm);\n  if (!generator1.empty() || !generator2.empty()) {\n    result.joinGenerators(joinCondition, generator1, generator2);\n  }\n  return result;\n}\n\nfunction joinArrays(\n  realm: Realm,\n  v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n  let e = (v1 && v1[0]) || (v2 && v2[0]);\n  if (e instanceof Value) return joinArraysOfValues(realm, (v1: any), (v2: any), getAbstractValue);\n  else return joinArrayOfsMapEntries(realm, (v1: any), (v2: any), getAbstractValue);\n}\n\nfunction joinArrayOfsMapEntries(\n  realm: Realm,\n  a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  a2: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<{ $Key: void | Value, $Value: void | Value }> {\n  let empty = realm.intrinsics.empty;\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n    let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n    if (key1 === undefined && key2 === undefined) {\n      result[i] = { $Key: undefined, $Value: undefined };\n    } else {\n      let key3 = getAbstractValue(key1, key2);\n      let val3 = getAbstractValue(val1, val2);\n      result[i] = { $Key: key3, $Value: val3 };\n    }\n  }\n  return result;\n}\n\nfunction joinArraysOfValues(\n  realm: Realm,\n  a1: void | Array<Value>,\n  a2: void | Array<Value>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> {\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = getAbstractValue((a1 && a1[i]) || undefined, (a2 && a2[i]) || undefined);\n  }\n  return result;\n}\n\nexport class JoinImplementation {\n  stopEffectCaptureJoinApplyAndReturnCompletion(\n    c1: PossiblyNormalCompletion,\n    c2: AbruptCompletion,\n    realm: Realm\n  ): AbruptCompletion {\n    let e = realm.getCapturedEffects(c1);\n    invariant(e !== undefined);\n    realm.stopEffectCaptureAndUndoEffects(c1);\n    let joined_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, c1, c2, e);\n    realm.applyEffects(joined_effects);\n    let result = joined_effects[0];\n    invariant(result instanceof AbruptCompletion);\n    return result;\n  }\n\n  unbundleNormalCompletion(\n    completionOrValue: Completion | Value | Reference\n  ): [void | NormalCompletion, Value | Reference] {\n    let completion, value;\n    if (completionOrValue instanceof PossiblyNormalCompletion) {\n      completion = completionOrValue;\n      value = completionOrValue.value;\n    } else {\n      invariant(completionOrValue instanceof Value || completionOrValue instanceof Reference);\n      value = completionOrValue;\n    }\n    return [completion, value];\n  }\n\n  composeNormalCompletions(\n    leftCompletion: void | NormalCompletion,\n    rightCompletion: void | NormalCompletion,\n    resultValue: Value,\n    realm: Realm\n  ): PossiblyNormalCompletion | Value {\n    if (leftCompletion instanceof PossiblyNormalCompletion) {\n      if (rightCompletion instanceof PossiblyNormalCompletion) {\n        this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n        return this.composePossiblyNormalCompletions(realm, leftCompletion, rightCompletion);\n      }\n      this.updatePossiblyNormalCompletionWithValue(realm, leftCompletion, resultValue);\n      return leftCompletion;\n    } else if (rightCompletion instanceof PossiblyNormalCompletion) {\n      this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n      return rightCompletion;\n    } else {\n      invariant(leftCompletion === undefined && rightCompletion === undefined);\n      return resultValue;\n    }\n  }\n\n  composePossiblyNormalCompletions(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    c: PossiblyNormalCompletion\n  ): PossiblyNormalCompletion {\n    invariant(c.savedEffects === undefined); // the caller should ensure this\n    //merge the two pathConditions\n    let composedPath = [];\n    composedPath = pnc.pathConditions.concat(c.pathConditions);\n    let savedPathConditions = pnc.savedPathConditions;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        let [, g, b, p, o] = pnc.alternateEffects;\n        let newAlternateEffects = [c, g, b, p, o];\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          pnc.consequent,\n          pnc.consequentEffects,\n          c,\n          newAlternateEffects,\n          composedPath,\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let new_alternate = this.composePossiblyNormalCompletions(realm, pnc.alternate, c);\n      let [, g, b, p, o] = pnc.alternateEffects;\n      let newAlternateEffects = [new_alternate, g, b, p, o];\n      return new PossiblyNormalCompletion(\n        new_alternate.value,\n        pnc.joinCondition,\n        pnc.consequent,\n        pnc.consequentEffects,\n        new_alternate,\n        newAlternateEffects,\n        composedPath,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    } else {\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      if (pnc.consequent instanceof Value) {\n        let [, g, b, p, o] = pnc.consequentEffects;\n        let newConsequentEffects = [c, g, b, p, o];\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          c,\n          newConsequentEffects,\n          pnc.alternate,\n          pnc.alternateEffects,\n          composedPath,\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let new_consequent = this.composePossiblyNormalCompletions(realm, pnc.consequent, c);\n      let [, g, b, p, o] = pnc.consequentEffects;\n      let newConsequentEffects = [new_consequent, g, b, p, o];\n      return new PossiblyNormalCompletion(\n        new_consequent.value,\n        pnc.joinCondition,\n        new_consequent,\n        newConsequentEffects,\n        pnc.alternate,\n        pnc.alternateEffects,\n        composedPath,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    }\n  }\n\n  updatePossiblyNormalCompletionWithSubsequentEffects(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    subsequentEffects: Effects\n  ) {\n    let v = subsequentEffects[0];\n    invariant(v instanceof Value);\n    pnc.value = v;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = v;\n        pnc.alternateEffects[0] = v;\n        pnc.alternateEffects = realm.composeEffects(pnc.alternateEffects, subsequentEffects);\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.alternate, subsequentEffects);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = v;\n        pnc.consequentEffects[0] = v;\n        pnc.consequentEffects = realm.composeEffects(pnc.consequentEffects, subsequentEffects);\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.consequent, subsequentEffects);\n      }\n    }\n  }\n\n  updatePossiblyNormalCompletionWithValue(realm: Realm, pnc: PossiblyNormalCompletion, v: Value) {\n    pnc.value = v;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = v;\n        pnc.alternateEffects[0] = v;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithValue(realm, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = v;\n        pnc.consequentEffects[0] = v;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithValue(realm, pnc.consequent, v);\n      }\n    }\n  }\n\n  // Returns the joined effects of all of the paths in pnc.\n  // The normal path in pnc is modified to become terminated by ac,\n  // so the overall completion will always be an instance of JoinedAbruptCompletions\n  joinPossiblyNormalCompletionWithAbruptCompletion(\n    realm: Realm,\n    // a forked path with a non abrupt (normal) component\n    pnc: PossiblyNormalCompletion,\n    // an abrupt completion that completes the normal path\n    ac: AbruptCompletion,\n    // effects collected after pnc was constructed\n    e: Effects\n  ): Effects {\n    // set up e with ac as the completion. It's OK to do this repeatedly since ac is not changed by recursive calls.\n    e[0] = ac;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        return this.joinEffects(\n          realm,\n          pnc.joinCondition,\n          pnc.consequentEffects,\n          realm.composeEffects(pnc.alternateEffects, e)\n        );\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let alternate_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.alternate, ac, e);\n      let composedEffects = realm.composeEffects(pnc.alternateEffects, alternate_effects);\n      invariant(pnc.consequent instanceof AbruptCompletion);\n      return this.joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, composedEffects);\n    } else {\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      if (pnc.consequent instanceof Value) {\n        return this.joinEffects(\n          realm,\n          pnc.joinCondition,\n          realm.composeEffects(pnc.consequentEffects, e),\n          pnc.alternateEffects\n        );\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let consequent_effects = this.joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.consequent, ac, e);\n      let composedEffects = realm.composeEffects(pnc.consequentEffects, consequent_effects);\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      return this.joinEffects(realm, pnc.joinCondition, composedEffects, pnc.alternateEffects);\n    }\n  }\n\n  joinPossiblyNormalCompletionWithValue(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ) {\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, pnc.alternate, v);\n        pnc.alternateEffects[0] = pnc.alternate;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, pnc.consequent, v);\n        pnc.consequentEffects[0] = pnc.consequent;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, pnc.consequent, v);\n      }\n    }\n  }\n\n  joinValueWithPossiblyNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ) {\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        pnc.alternate = this.joinValuesAsConditional(realm, joinCondition, v, pnc.alternate);\n        pnc.alternateEffects[0] = pnc.alternate;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.alternate, v);\n      }\n    } else {\n      if (pnc.consequent instanceof Value) {\n        pnc.consequent = this.joinValuesAsConditional(realm, joinCondition, v, pnc.consequent);\n        pnc.consequentEffects[0] = pnc.consequent;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, pnc.consequent, v);\n      }\n    }\n  }\n\n  joinPossiblyNormalCompletions(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    c: PossiblyNormalCompletion,\n    a: PossiblyNormalCompletion\n  ): PossiblyNormalCompletion {\n    let rJoinCondition: Value;\n    let cp: [Effects, Effects];\n    let ap: [Effects, Effects];\n    if (c.consequent instanceof AbruptCompletion) {\n      if (a.consequent instanceof AbruptCompletion) {\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", c.joinCondition, a.joinCondition);\n        cp = [c.consequentEffects, a.consequentEffects];\n        ap = [c.alternateEffects, a.alternateEffects];\n      } else {\n        let notA = AbstractValue.createFromUnaryOp(realm, \"!\", a.joinCondition);\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", c.joinCondition, notA);\n        cp = [c.consequentEffects, a.alternateEffects];\n        ap = [c.alternateEffects, a.consequentEffects];\n      }\n    } else {\n      let notC = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n      if (a.consequent instanceof AbruptCompletion) {\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", notC, a.joinCondition);\n        cp = [c.alternateEffects, a.consequentEffects];\n        ap = [c.consequentEffects, a.alternateEffects];\n      } else {\n        let notA = AbstractValue.createFromUnaryOp(realm, \"!\", a.joinCondition);\n        rJoinCondition = AbstractValue.createFromLogicalOp(realm, \"&&\", notC, notA);\n        cp = [c.alternateEffects, a.alternateEffects];\n        ap = [c.consequentEffects, a.consequentEffects];\n      }\n    }\n    invariant(rJoinCondition instanceof AbstractValue); // the transformations will not result in tautologies\n    let [ce1, ce2] = cp;\n    let [ae1, ae2] = ap;\n    let rce = this.joinEffects(realm, joinCondition, ce1, ce2);\n    let rae = this.joinEffects(realm, joinCondition, ae1, ae2);\n    let rc = rce[0];\n    invariant(rc instanceof Value || rc instanceof Completion);\n    let ra = rae[0];\n    invariant(ra instanceof Value || ra instanceof Completion);\n    let rv = ra instanceof PossiblyNormalCompletion ? ra.value : ra;\n    invariant(rv instanceof Value);\n    return new PossiblyNormalCompletion(rv, rJoinCondition, rc, rce, ra, rae, [], []);\n  }\n\n  joinEffectsAndPromoteNestedReturnCompletions(\n    realm: Realm,\n    c: Completion | Value,\n    e: Effects,\n    nested_effects?: Effects\n  ): Effects {\n    if (c instanceof Value) {\n      // If not undefined, the nested effects were captured when evaluating a conditional code block that ended normally.\n      // e represent effects that were captured since reaching the join point where the normal and abrupt\n      // completions came together into the completion supplied to the outermost call to this recursive function.\n      if (nested_effects !== undefined) e = realm.composeEffects(nested_effects, e);\n      return e;\n    }\n    if (c instanceof AbruptCompletion && !(c instanceof JoinedAbruptCompletions)) {\n      // The nested effects were captured when evaluating a conditional code block that ended abruptly.\n      // An abrupt completion does not care about the effects that were collected since the join point.\n      invariant(nested_effects !== undefined);\n      return nested_effects;\n    }\n    if (c instanceof PossiblyNormalCompletion) {\n      let e1 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.consequent, e, c.consequentEffects);\n      let e2 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.alternate, e, c.alternateEffects);\n      if (e1[0] instanceof AbruptCompletion) {\n        if (e2[0] instanceof Value) e2[0] = new ReturnCompletion(realm.intrinsics.undefined, realm.currentLocation);\n        return this.joinEffects(realm, c.joinCondition, e1, e2);\n      } else if (e2[0] instanceof AbruptCompletion) {\n        if (e1[0] instanceof Value) e1[0] = new ReturnCompletion(realm.intrinsics.undefined, realm.currentLocation);\n        return this.joinEffects(realm, c.joinCondition, e1, e2);\n      }\n    }\n    invariant(c instanceof JoinedAbruptCompletions);\n    // e will be ignored in the calls below since the branches are all abrupt.\n    let e1 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.consequent, e, c.consequentEffects);\n    let e2 = this.joinEffectsAndPromoteNestedReturnCompletions(realm, c.alternate, e, c.alternateEffects);\n    let [r1, r2] = [e1[0], e2[0]];\n    if (r1 instanceof ReturnCompletion) {\n      invariant(!(r2 instanceof ReturnCompletion)); // Otherwise their values should have been joined\n      if (r2 instanceof JoinedAbruptCompletions) {\n        if (r2.consequent instanceof ReturnCompletion) {\n          let r1jr2c = this.joinEffects(realm, c.joinCondition, e1, r2.consequentEffects);\n          invariant(r1jr2c[0] instanceof ReturnCompletion);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, r2.joinCondition);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r1jr2c, r2.alternateEffects);\n        }\n        if (r2.alternate instanceof ReturnCompletion) {\n          let r1jr2a = this.joinEffects(realm, c.joinCondition, e1, r2.alternateEffects);\n          invariant(r1jr2a[0] instanceof ReturnCompletion);\n          let notR2jc = AbstractValue.createFromUnaryOp(realm, \"!\", r2.joinCondition);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, notR2jc);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r1jr2a, r2.consequentEffects);\n        }\n      }\n    } else if (r2 instanceof ReturnCompletion) {\n      invariant(!(r1 instanceof ReturnCompletion)); // Otherwise their values should have been joined\n      if (r1 instanceof JoinedAbruptCompletions) {\n        if (r1.consequent instanceof ReturnCompletion) {\n          let r2jr1c = this.joinEffects(realm, c.joinCondition, r1.consequentEffects, e2);\n          invariant(r2jr1c[0] instanceof ReturnCompletion);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, r1.joinCondition);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r2jr1c, r1.alternateEffects);\n        }\n        if (r1.alternate instanceof ReturnCompletion) {\n          let r2jr1a = this.joinEffects(realm, c.joinCondition, r1.alternateEffects, e2);\n          let notR1jc = AbstractValue.createFromUnaryOp(realm, \"!\", r1.joinCondition);\n          invariant(r2jr1a[0] instanceof ReturnCompletion);\n          let or = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, notR1jc);\n          invariant(or instanceof AbstractValue);\n          return this.joinEffects(realm, or, r2jr1a, r1.consequentEffects);\n        }\n      }\n    }\n    return this.joinEffects(realm, c.joinCondition, e1, e2);\n  }\n\n  unbundleReturnCompletion(realm: Realm, c: JoinedAbruptCompletions): [Effects, PossiblyNormalCompletion] {\n    let empty_effects = construct_empty_effects(realm);\n    // The nested generators are already reachable from the current generator\n    // so there is no need to keep tracking them separately and doing so would cause them to be serialized twice.\n    c.alternateEffects[1] = new Generator(realm);\n    c.consequentEffects[1] = new Generator(realm);\n    let v = realm.intrinsics.empty;\n    if (c.consequent instanceof ReturnCompletion) {\n      let negation = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n      // Simply negating the (known to be abstract) join condition should\n      // not become a concrete value\n      invariant(negation instanceof AbstractValue);\n      let pathConditions = [negation];\n      let pnc = new PossiblyNormalCompletion(\n        v,\n        c.joinCondition,\n        v,\n        empty_effects,\n        c.alternate,\n        c.alternateEffects,\n        pathConditions,\n        []\n      );\n      return [c.consequentEffects, pnc];\n    } else if (c.alternate instanceof ReturnCompletion) {\n      let pnc = new PossiblyNormalCompletion(\n        v,\n        c.joinCondition,\n        c.consequent,\n        c.consequentEffects,\n        v,\n        empty_effects,\n        [c.joinCondition],\n        []\n      );\n      return [c.alternateEffects, pnc];\n    } else {\n      invariant(false, \"unbundleReturnCompletion needs an argument that contains a non nested return completion\");\n    }\n  }\n\n  removeNormalEffects(realm: Realm, c: PossiblyNormalCompletion): Effects {\n    if (c.consequent instanceof AbruptCompletion) {\n      if (c.alternate instanceof Value) {\n        let result = c.alternateEffects;\n        c.alternateEffects = construct_empty_effects(realm);\n        return result;\n      } else {\n        invariant(c.alternate instanceof PossiblyNormalCompletion);\n        let result = realm.composeEffects(c.alternateEffects, this.removeNormalEffects(realm, c.alternate));\n        c.alternateEffects = construct_empty_effects(realm);\n        return result;\n      }\n    } else {\n      if (c.consequent instanceof Value) {\n        let result = c.consequentEffects;\n        c.consequentEffects = construct_empty_effects(realm);\n        return result;\n      } else {\n        invariant(c.consequent instanceof PossiblyNormalCompletion);\n        let result = realm.composeEffects(c.consequentEffects, this.removeNormalEffects(realm, c.consequent));\n        c.consequentEffects = construct_empty_effects(realm);\n        return result;\n      }\n    }\n  }\n\n  joinEffects(realm: Realm, joinCondition: AbstractValue, e1: Effects, e2: Effects): Effects {\n    let [result1, gen1, bindings1, properties1, createdObj1] = e1;\n    let [result2, gen2, bindings2, properties2, createdObj2] = e2;\n\n    let result = this.joinResults(realm, joinCondition, result1, result2, e1, e2);\n    if (result1 instanceof AbruptCompletion) {\n      if (!(result2 instanceof AbruptCompletion)) {\n        invariant(result instanceof PossiblyNormalCompletion);\n        return [result, gen2, bindings2, properties2, createdObj2];\n      }\n    } else if (result2 instanceof AbruptCompletion) {\n      invariant(result instanceof PossiblyNormalCompletion);\n      return [result, gen1, bindings1, properties1, createdObj1];\n    }\n\n    let bindings = this.joinBindings(realm, joinCondition, bindings1, bindings2);\n    let properties = this.joinPropertyBindings(\n      realm,\n      joinCondition,\n      properties1,\n      properties2,\n      createdObj1,\n      createdObj2\n    );\n    let createdObjects = new Set();\n    createdObj1.forEach(o => {\n      createdObjects.add(o);\n    });\n    createdObj2.forEach(o => {\n      createdObjects.add(o);\n    });\n\n    let generator = joinGenerators(realm, joinCondition, gen1, gen2);\n\n    return [result, generator, bindings, properties, createdObjects];\n  }\n\n  joinResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    result1: EvaluationResult,\n    result2: EvaluationResult,\n    e1: Effects,\n    e2: Effects\n  ): AbruptCompletion | PossiblyNormalCompletion | Value {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    if (result1 instanceof Reference || result2 instanceof Reference) {\n      AbstractValue.reportIntrospectionError(joinCondition);\n      throw new FatalError();\n    }\n    if (result1 instanceof BreakCompletion && result2 instanceof BreakCompletion && result1.target === result2.target) {\n      return new BreakCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);\n    }\n    if (\n      result1 instanceof ContinueCompletion &&\n      result2 instanceof ContinueCompletion &&\n      result1.target === result2.target\n    ) {\n      return new ContinueCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, result1.target);\n    }\n    if (result1 instanceof ReturnCompletion && result2 instanceof ReturnCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ReturnCompletion(val, joinCondition.expressionLocation);\n    }\n    if (result1 instanceof ThrowCompletion && result2 instanceof ThrowCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ThrowCompletion(val, result1.location);\n    }\n    if (result1 instanceof AbruptCompletion && result2 instanceof AbruptCompletion) {\n      return new JoinedAbruptCompletions(realm, joinCondition, result1, e1, result2, e2);\n    }\n    if (result1 instanceof Value && result2 instanceof Value) {\n      let val = this.joinValues(realm, result1, result2, getAbstractValue);\n      invariant(val instanceof Value);\n      return val;\n    }\n    if (result1 instanceof PossiblyNormalCompletion && result2 instanceof PossiblyNormalCompletion) {\n      return this.joinPossiblyNormalCompletions(realm, joinCondition, result1, result2);\n    }\n    if (result1 instanceof AbruptCompletion) {\n      let value = result2;\n      let savedEffects;\n      let pathConditions;\n      let savedPathConditions = [];\n      if (result2 instanceof PossiblyNormalCompletion) {\n        value = result2.value;\n        savedEffects = result2.savedEffects;\n        pathConditions = [joinCondition].concat(result2.pathConditions);\n        savedPathConditions = result2.savedPathConditions;\n      } else {\n        pathConditions = [joinCondition];\n      }\n      invariant(value instanceof Value);\n      return new PossiblyNormalCompletion(\n        value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        pathConditions,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result2 instanceof AbruptCompletion) {\n      let value = result1;\n      let savedEffects;\n      let pathConditions;\n      let savedPathConditions = [];\n      if (result1 instanceof PossiblyNormalCompletion) {\n        value = result1.value;\n        savedEffects = result1.savedEffects;\n        pathConditions = [joinCondition].concat(result1.pathConditions);\n        savedPathConditions = result1.savedPathConditions;\n      } else {\n        pathConditions = [joinCondition];\n      }\n      invariant(value instanceof Value);\n      return new PossiblyNormalCompletion(\n        value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        pathConditions,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result1 instanceof PossiblyNormalCompletion) {\n      invariant(result2 instanceof Value);\n      this.joinPossiblyNormalCompletionWithValue(realm, joinCondition, result1, result2);\n      return result1;\n    }\n    if (result2 instanceof PossiblyNormalCompletion) {\n      invariant(result1 instanceof Value);\n      this.joinValueWithPossiblyNormalCompletion(realm, joinCondition, result2, result1);\n      return result2;\n    }\n    invariant(false);\n  }\n\n  composeGenerators(realm: Realm, generator1: Generator, generator2: Generator): Generator {\n    let result = new Generator(realm);\n    if (!generator1.empty() || !generator2.empty()) {\n      result.composeGenerators(generator1, generator2);\n    }\n    return result;\n  }\n\n  // Creates a single map that joins together maps m1 and m2 using the given join\n  // operator. If an entry is present in one map but not the other, the missing\n  // entry is treated as if it were there and its value were undefined.\n  joinMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, join: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = join(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, join(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  // Creates a single map that has an key, value pair for the union of the key\n  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n  // where the join is defined to be just m1[key] if m1[key] === m2[key] and\n  // and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\n  joinBindings(realm: Realm, joinCondition: AbstractValue, m1: Bindings, m2: Bindings): Bindings {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    let join = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;\n      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;\n      let v1 = b1 === undefined ? b.value : b1.value;\n      let v2 = b2 === undefined ? b.value : b2.value;\n      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.\n      let value = this.joinValues(realm, v1, v2, getAbstractValue);\n      invariant(value instanceof Value);\n      return { hasLeaked, value };\n    };\n    return this.joinMaps(m1, m2, join);\n  }\n\n  // If v1 is known and defined and v1 === v2 return v1,\n  // otherwise return getAbstractValue(v1, v2)\n  joinValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    getAbstractValue: (void | Value, void | Value) => Value\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(v1 === undefined || Array.isArray(v1));\n      invariant(v2 === undefined || Array.isArray(v2));\n      return joinArrays(realm, ((v1: any): void | Array<Value>), ((v2: any): void | Array<Value>), getAbstractValue);\n    }\n    invariant(v1 === undefined || v1 instanceof Value);\n    invariant(v2 === undefined || v2 instanceof Value);\n    if (\n      v1 !== undefined &&\n      v2 !== undefined &&\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1;\n    } else {\n      return getAbstractValue(v1, v2);\n    }\n  }\n\n  joinValuesAsConditional(realm: Realm, condition: AbstractValue, v1: void | Value, v2: void | Value): Value {\n    return AbstractValue.createFromConditionalOp(realm, condition, v1, v2);\n  }\n\n  joinPropertyBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let join = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      // If the PropertyBinding object has been freshly allocated do not join\n      if (d1 === undefined) {\n        if (b.object instanceof ObjectValue && c2.has(b.object)) return d2; // no join\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was deleted\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d1 = b.descriptor; //Get value of property before the split\n        }\n      }\n      if (d2 === undefined) {\n        if (b.object instanceof ObjectValue && c1.has(b.object)) return d1; // no join\n        if (b.descriptor !== undefined && m2.has(b)) {\n          // property was deleted\n          d2 = cloneDescriptor(b.descriptor);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d2 = b.descriptor; //Get value of property before the split\n        }\n      }\n      return this.joinDescriptors(realm, joinCondition, d1, d2);\n    };\n    return this.joinMaps(m1, m2, join);\n  }\n\n  joinDescriptors(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    d1: void | Descriptor,\n    d2: void | Descriptor\n  ): void | Descriptor {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return this.joinValuesAsConditional(realm, joinCondition, v1, v2);\n    };\n    let clone_with_abstract_value = (d: Descriptor) => {\n      if (!IsDataDescriptor(realm, d)) {\n        let d3: Descriptor = {};\n        d3.joinCondition = joinCondition;\n        return d3;\n      }\n      let dc = cloneDescriptor(d);\n      invariant(dc !== undefined);\n      let dcValue = dc.value;\n      if (Array.isArray(dcValue)) {\n        invariant(dcValue.length > 0);\n        let elem0 = dcValue[0];\n        if (elem0 instanceof Value) {\n          dc.value = dcValue.map(e => getAbstractValue((e: any), realm.intrinsics.empty));\n        } else {\n          dc.value = dcValue.map(e => {\n            let { $Key: key1, $Value: val1 } = (e: any);\n            let key3 = getAbstractValue(key1, realm.intrinsics.empty);\n            let val3 = getAbstractValue(val1, realm.intrinsics.empty);\n            return { $Key: key3, $Value: val3 };\n          });\n        }\n      } else {\n        invariant(dcValue === undefined || dcValue instanceof Value);\n        dc.value = getAbstractValue(dcValue, realm.intrinsics.empty);\n      }\n      return dc;\n    };\n    if (d1 === undefined) {\n      if (d2 === undefined) return undefined;\n      // d2 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d2);\n      if (!IsDataDescriptor(realm, d2)) d3.descriptor2 = d2;\n      return d3;\n    } else if (d2 === undefined) {\n      invariant(d1 !== undefined);\n      // d1 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d1);\n      if (!IsDataDescriptor(realm, d1)) d3.descriptor1 = d1;\n      return d3;\n    } else {\n      if (equalDescriptors(d1, d2) && IsDataDescriptor(realm, d1)) {\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        dc.value = this.joinValues(realm, d1.value, d2.value, getAbstractValue);\n        return dc;\n      }\n      let d3: Descriptor = {};\n      d3.joinCondition = joinCondition;\n      d3.descriptor1 = d1;\n      d3.descriptor2 = d2;\n      return d3;\n    }\n  }\n}\n"]}