{"version":3,"sources":["../../src/methods/widen.js"],"names":["t","WidenImplementation","realm","v1","v2","e","_widenArraysOfValues","_widenArrayOfsMapEntries","a1","a2","empty","intrinsics","n","Math","max","length","result","i","$Key","$Value","key1","val1","key2","val2","undefined","key3","widenValues","val3","wv","e1","e2","result1","bindings1","properties1","createdObj1","result2","bindings2","properties2","createdObj2","widenResults","bindings","widenBindings","properties","widenPropertyBindings","createdObjects","Set","generator","val","m1","m2","widen","m3","Map","forEach","key","map1","get","set","map2","has","b","b1","b2","l1","hasLeaked","l2","value","kind","phiNode","derive","types","values","skipInvariant","intrinsicName","phiName","_buildNode","identifier","widenMaps","Array","isArray","_widenArrays","throwIfNotConcrete","createFromWidening","c1","c2","d1","d2","object","descriptor","widenDescriptors","rval","pathNode","mightNotBeString","mightNotBeNumber","createFromWidenedProperty","o","memberExpression","p","initVal","emitVoidExpression","v","assignmentExpression","dc","containsResults","containsBindings","containsPropertyBindings","_containsValues","f","entries","keys","containsBinding","containsMap","containsPropertyBinding","_containsArray","containsArraysOfValue","_containsArrayOfsMapEntries","equals","isTypeCompatibleWith","getType","containsValue"],"mappings":"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","file":"widen.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type {\n  Bindings,\n  BindingEntry,\n  Effects,\n  EvaluationResult,\n  PropertyBindings,\n  CreatedObjects,\n  Realm,\n} from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ArrayValue, EmptyValue, ObjectValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport class WidenImplementation {\n  _widenArrays(\n    realm: Realm,\n    v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    let e = (v1 && v1[0]) || (v2 && v2[0]);\n    if (e instanceof Value) return this._widenArraysOfValues(realm, (v1: any), (v2: any));\n    else return this._widenArrayOfsMapEntries(realm, (v1: any), (v2: any));\n  }\n\n  _widenArrayOfsMapEntries(\n    realm: Realm,\n    a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: void | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<{ $Key: void | Value, $Value: void | Value }> {\n    let empty = realm.intrinsics.empty;\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result: Array<{ $Key: void | Value, $Value: void | Value }> = [];\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n      let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n      if (key1 === undefined && key2 === undefined) {\n        result[i] = { $Key: undefined, $Value: undefined };\n      } else {\n        let key3 = this.widenValues(realm, key1, key2);\n        invariant(key3 instanceof Value);\n        let val3 = this.widenValues(realm, val1, val2);\n        invariant(val3 === undefined || val3 instanceof Value);\n        result[i] = { $Key: key3, $Value: val3 };\n      }\n    }\n    return result;\n  }\n\n  _widenArraysOfValues(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): Array<Value> {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result = [];\n    for (let i = 0; i < n; i++) {\n      let wv = this.widenValues(realm, (a1 && a1[i]) || undefined, (a2 && a2[i]) || undefined);\n      invariant(wv === undefined || wv instanceof Value);\n      result[i] = wv;\n    }\n    return result;\n  }\n\n  // Returns a new effects summary that includes both e1 and e2.\n  widenEffects(realm: Realm, e1: Effects, e2: Effects): Effects {\n    let [result1, , bindings1, properties1, createdObj1] = e1;\n    let [result2, , bindings2, properties2, createdObj2] = e2;\n\n    let result = this.widenResults(realm, result1, result2);\n    let bindings = this.widenBindings(realm, bindings1, bindings2);\n    let properties = this.widenPropertyBindings(realm, properties1, properties2, createdObj1, createdObj2);\n    let createdObjects = new Set(); // Top, since the empty set knows nothing. There is no other choice for widen.\n    let generator = new Generator(realm, \"widen\"); // code subject to widening will be generated somewhere else\n    return [result, generator, bindings, properties, createdObjects];\n  }\n\n  widenResults(realm: Realm, result1: EvaluationResult, result2: EvaluationResult): PossiblyNormalCompletion | Value {\n    invariant(!(result1 instanceof Reference || result2 instanceof Reference), \"loop bodies should not result in refs\");\n    invariant(\n      !(result1 instanceof AbruptCompletion || result2 instanceof AbruptCompletion),\n      \"if a loop iteration ends abruptly, there is no need for fixed point computation\"\n    );\n    if (result1 instanceof Value && result2 instanceof Value) {\n      let val = this.widenValues(realm, result1, result2);\n      invariant(val instanceof Value);\n      return val;\n    }\n    if (result1 instanceof PossiblyNormalCompletion || result2 instanceof PossiblyNormalCompletion) {\n      //todo: #1174 figure out how to deal with loops that have embedded conditional exits\n      // widen join pathConditions\n      // widen normal result and Effects\n      // use abrupt part of result2, depend stability to make this safe. See below.\n      throw new FatalError();\n    }\n    invariant(false);\n  }\n\n  widenMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, widen: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = widen(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, widen(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  widenBindings(realm: Realm, m1: Bindings, m2: Bindings): Bindings {\n    let widen = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;\n      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;\n      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.\n      let v1 = b1 === undefined || b1.value === undefined ? b.value : b1.value;\n      invariant(b2 !== undefined); // Local variables are not going to get deleted as a result of widening\n      let v2 = b2.value;\n      invariant(v2 !== undefined);\n      let result = this.widenValues(realm, v1, v2);\n      if (result instanceof AbstractValue && result.kind === \"widened\") {\n        let phiNode = b.phiNode;\n        if (phiNode === undefined) {\n          // Create a temporal location for binding\n          let generator = realm.generator;\n          invariant(generator !== undefined);\n          phiNode = generator.derive(result.types, result.values, [b.value || realm.intrinsics.undefined], ([n]) => n, {\n            skipInvariant: true,\n          });\n          b.phiNode = phiNode;\n        }\n        // Let the widened value be a reference to the phiNode of the binding\n        invariant(phiNode.intrinsicName !== undefined);\n        let phiName = phiNode.intrinsicName;\n        result.intrinsicName = phiName;\n        result._buildNode = args => t.identifier(phiName);\n      }\n      invariant(result instanceof Value);\n      return { hasLeaked, value: result };\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  // Returns an abstract value that includes both v1 and v2 as potential values.\n  widenValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(v1 === undefined || Array.isArray(v1));\n      invariant(v2 === undefined || Array.isArray(v2));\n      return this._widenArrays(realm, ((v1: any): void | Array<Value>), ((v2: any): void | Array<Value>));\n    }\n    invariant(v1 === undefined || v1 instanceof Value);\n    invariant(v2 === undefined || v2 instanceof Value);\n    if (\n      v1 !== undefined &&\n      v2 !== undefined &&\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1; // no need to widen a loop invariant value\n    } else {\n      return AbstractValue.createFromWidening(realm, v1 || realm.intrinsics.empty, v2 || realm.intrinsics.undefined);\n    }\n  }\n\n  widenPropertyBindings(\n    realm: Realm,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let widen = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      if (d1 === undefined && d2 === undefined) return undefined;\n      // If the PropertyBinding object has been freshly allocated do not widen (that happens in AbstractObjectValue)\n      if (d1 === undefined) {\n        if (b.object instanceof ObjectValue && c2.has(b.object)) return d2; // no widen\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was present in (n-1)th iteration and deleted in nth iteration\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in nth iteration, use the value from the (n-1)th iteration\n          d1 = b.descriptor;\n          if (d1 === undefined) {\n            d1 = cloneDescriptor(d2);\n            invariant(d1 !== undefined);\n            d1.value = realm.intrinsics.empty;\n          }\n        }\n      }\n      if (d2 === undefined) {\n        if (b.object instanceof ObjectValue && c1.has(b.object)) return d1; // no widen\n        if (m2.has(b)) {\n          // property was present in nth iteration and deleted in (n+1)th iteration\n          d2 = cloneDescriptor(d1);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in (n+1)th iteration, use the value from the nth iteration\n          d2 = d1;\n        }\n        invariant(d2 !== undefined);\n      }\n      let result = this.widenDescriptors(realm, d1, d2);\n      if (result && result.value instanceof AbstractValue && result.value.kind === \"widened\") {\n        let rval = result.value;\n        let pathNode = b.pathNode;\n        if (pathNode === undefined) {\n          //Since properties already have mutable storage locations associated with them, we do not\n          //need phi nodes. What we need is an abstract value with a build node that results in a memberExpression\n          //that resolves to the storage location of the property.\n\n          // For now, we only handle loop invariant properties\n          //i.e. properties where the member expresssion does not involve any values written to inside the loop.\n          let key = b.key;\n          if (typeof key === \"string\" || !(key.mightNotBeString() && key.mightNotBeNumber())) {\n            if (typeof key === \"string\") {\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object], ([o]) =>\n                t.memberExpression(o, t.identifier(key))\n              );\n            } else {\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object, key], ([o, p]) => {\n                return t.memberExpression(o, p, true);\n              });\n            }\n            // The value of the property at the start of the loop needs to be written to the property\n            // before the loop commences, otherwise the memberExpression will result in an undefined value.\n            let generator = realm.generator;\n            invariant(generator !== undefined);\n            let initVal = (b.descriptor && b.descriptor.value) || realm.intrinsics.empty;\n            if (!(initVal instanceof Value)) throw new FatalError(\"todo: handle internal properties\");\n            if (!(initVal instanceof EmptyValue)) {\n              if (key === \"length\" && b.object instanceof ArrayValue) {\n                // do nothing, the array length will already be initialized\n              } else if (typeof key === \"string\") {\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, initVal], ([o, v]) =>\n                  t.assignmentExpression(\"=\", t.memberExpression(o, t.identifier(key)), v)\n                );\n              } else {\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, b.key, initVal], ([o, p, v]) =>\n                  t.assignmentExpression(\"=\", t.memberExpression(o, p, true), v)\n                );\n              }\n            }\n          } else {\n            throw new FatalError(\"todo: handle the case where key is an abstract value\");\n          }\n          b.pathNode = pathNode;\n        }\n        result.value = pathNode;\n      }\n      return result;\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  widenDescriptors(realm: Realm, d1: void | Descriptor, d2: Descriptor): void | Descriptor {\n    if (d1 === undefined) {\n      // d2 is a property written to only in the (n+1)th iteration\n      if (!IsDataDescriptor(realm, d2)) return d2; // accessor properties need not be widened.\n      let dc = cloneDescriptor(d2);\n      invariant(dc !== undefined);\n      dc.value = this.widenValues(realm, d2.value, d2.value);\n      return dc;\n    } else {\n      if (equalDescriptors(d1, d2)) {\n        if (!IsDataDescriptor(realm, d1)) return d1; // identical accessor properties need not be widened.\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        dc.value = this.widenValues(realm, d1.value, d2.value);\n        return dc;\n      }\n      //todo: #1174 if we get here, the loop body contains a call to create a property and different iterations\n      // create them differently. That seems beyond what a fixpoint computation can reasonably handle without\n      // losing precision. Report an error here.\n      throw new FatalError();\n    }\n  }\n\n  // If e2 is the result of a loop iteration starting with effects e1 and it has a subset of elements of e1,\n  // then we have reached a fixed point and no further calls to widen are needed. e1/e2 represent a general\n  // summary of the loop, regardless of how many iterations will be performed at runtime.\n  containsEffects(e1: Effects, e2: Effects): boolean {\n    let [result1, , bindings1, properties1] = e1;\n    let [result2, , bindings2, properties2] = e2;\n\n    if (!this.containsResults(result1, result2)) return false;\n    if (!this.containsBindings(bindings1, bindings2)) return false;\n    if (!this.containsPropertyBindings(properties1, properties2)) return false;\n    return true;\n  }\n\n  containsResults(result1: EvaluationResult, result2: EvaluationResult): boolean {\n    if (result1 instanceof Value && result2 instanceof Value) return this._containsValues(result1, result2);\n    return false;\n  }\n\n  containsMap<K, V>(m1: Map<K, V>, m2: Map<K, V>, f: (void | V, void | V) => boolean): boolean {\n    for (const [key1, val1] of m1.entries()) {\n      if (val1 === undefined) continue; // deleted\n      let val2 = m2.get(key1);\n      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key\n      if (!f(val1, val2)) return false;\n    }\n    for (const key2 of m2.keys()) {\n      if (!m1.has(key2)) return false;\n    }\n    return true;\n  }\n\n  containsBindings(m1: Bindings, m2: Bindings): boolean {\n    let containsBinding = (b1: void | BindingEntry, b2: void | BindingEntry) => {\n      if (\n        b1 === undefined ||\n        b2 === undefined ||\n        b1.value === undefined ||\n        b2.value === undefined ||\n        !this._containsValues(b1.value, b2.value) ||\n        b1.hasLeaked !== b2.hasLeaked\n      ) {\n        return false;\n      }\n      return true;\n    };\n    return this.containsMap(m1, m2, containsBinding);\n  }\n\n  containsPropertyBindings(m1: PropertyBindings, m2: PropertyBindings): boolean {\n    let containsPropertyBinding = (d1: void | Descriptor, d2: void | Descriptor) => {\n      let [v1, v2] = [d1 && d1.value, d2 && d2.value];\n      if (v1 === undefined) return v2 === undefined;\n      if (v1 instanceof Value && v2 instanceof Value) return this._containsValues(v1, v2);\n      if (Array.isArray(v1) && Array.isArray(v2)) {\n        return this._containsArray(((v1: any): Array<Value>), ((v2: any): Array<Value>));\n      }\n      return v2 === undefined;\n    };\n    return this.containsMap(m1, m2, containsPropertyBinding);\n  }\n\n  _containsArray(\n    v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let e = (v1 && v1[0]) || (v2 && v2[0]);\n    if (e instanceof Value) return this.containsArraysOfValue((v1: any), (v2: any));\n    else return this._containsArrayOfsMapEntries((v1: any), (v2: any));\n  }\n\n  _containsArrayOfsMapEntries(\n    realm: Realm,\n    a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: void | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let empty = realm.intrinsics.empty;\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n      let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n      if (key1 === undefined) {\n        if (key2 !== undefined) return false;\n      } else {\n        if (key1 instanceof Value && key2 instanceof Value && key1.equals(key2)) {\n          if (val1 instanceof Value && val2 instanceof Value && this._containsValues(val1, val2)) continue;\n        }\n        return false;\n      }\n    }\n    return true;\n  }\n\n  containsArraysOfValue(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): boolean {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let [val1, val2] = [a1 && a1[i], a2 && a2[i]];\n      if (val1 instanceof Value && val2 instanceof Value && !this._containsValues(val1, val2)) return false;\n    }\n    return true;\n  }\n\n  _containsValues(val1: Value, val2: Value) {\n    if (val1 instanceof AbstractValue) {\n      if (!Value.isTypeCompatibleWith(val2.getType(), val1.getType())) return false;\n      return val1.values.containsValue(val2);\n    }\n    return val1.equals(val2);\n  }\n}\n"]}