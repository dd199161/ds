{"version":3,"sources":["../../src/methods/to.js"],"names":["modulo","x","y","ToImplementation","ElementConv","Int8","ToInt8","bind","Int16","ToInt16","Int32","ToInt32","Uint8","ToUint8","Uint16","ToUint16","Uint32","ToUint32","Uint8Clamped","ToUint8Clamp","realm","argument","number","ToNumber","isNaN","isFinite","int","Math","floor","abs","int32bit","pow","int16bit","int8bit","f","value","$BooleanData","booleanData","throwIfNotConcreteBoolean","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$NumberData","numberData","throwIfNotConcreteNumber","$StringData","stringData","throwIfNotConcreteString","Obj","desc","hasEnumerable","enu","ToBooleanPartial","enumerable","hasConfigurable","conf","configurable","hasValue","hasWritable","writable","hasGet","getter","mightBeUndefined","get","hasSet","setter","set","arg","obj","BooleanPrototype","NumberPrototype","StringCreate","StringPrototype","SymbolPrototype","$SymbolData","types","getType","isInPureScope","createFromType","args","throwIfNotConcreteObject","_WrapAbstractInObject","ToObject","len","ToInteger","Infinity","min","index","integerIndex","RangeError","ToLength","ToIndex","val","num","ToNumberOrAbstract","reportIntrospectionError","NaN","prim","ToPrimitiveOrAbstract","Number","IsToPrimitivePure","type","input","hint","throwIfNotConcretePrimitive","exoticToPrim","SymbolToPrimitive","result","OrdinaryToPrimitiveOrAbstract","mightBeObject","undefined","GetToPrimitivePureResultType","methodNames","name","method","resultType","isTypeCompatibleWith","primValue","ToPrimitive","ToString","str","ToStringPartial","length","mightNotBeObject","ToBoolean","key","ToPropertyKey","mightNotBeString","mightNotBeNumber","n"],"mappings":"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","file":"to.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Descriptor, CallableObjectValue } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { GetMethod, Get } from \"./get.js\";\nimport { Create } from \"../singletons.js\";\nimport { HasProperty } from \"./has.js\";\nimport { Call } from \"./call.js\";\nimport { FatalError } from \"../errors.js\";\nimport { IsCallable } from \"./is.js\";\nimport { SameValue, SameValueZero } from \"./abstract.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\ntype ElementConvType = {\n  Int8: (Realm, numberOrValue) => number,\n  Int16: (Realm, numberOrValue) => number,\n  Int32: (Realm, numberOrValue) => number,\n  Uint8: (Realm, numberOrValue) => number,\n  Uint16: (Realm, numberOrValue) => number,\n  Uint32: (Realm, numberOrValue) => number,\n  Uint8Clamped: (Realm, numberOrValue) => number,\n};\ntype numberOrValue = number | Value;\n\nfunction modulo(x: number, y: number): number {\n  return x < 0 ? x % y + y : x % y;\n}\n\nexport class ToImplementation {\n  constructor() {\n    this.ElementConv = {\n      Int8: this.ToInt8.bind(this),\n      Int16: this.ToInt16.bind(this),\n      Int32: this.ToInt32.bind(this),\n      Uint8: this.ToUint8.bind(this),\n      Uint16: this.ToUint16.bind(this),\n      Uint32: this.ToUint32.bind(this),\n      Uint8Clamped: this.ToUint8Clamp.bind(this),\n    };\n  }\n\n  ElementConv: ElementConvType;\n\n  // ECMA262 7.1.5\n  ToInt32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. If int32bit ≥ 2^31, return int32bit - 2^32; otherwise return int32bit.\n    return int32bit >= Math.pow(2, 31) ? int32bit - Math.pow(2, 32) : int32bit;\n  }\n\n  // ECMA262 7.1.6\n  ToUint32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. Return int32bit.\n    return int32bit;\n  }\n\n  // ECMA262 7.1.7\n  ToInt16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. If int16bit ≥ 2^15, return int16bit - 2^16; otherwise return int16bit.\n    return int16bit >= Math.pow(2, 15) ? int16bit - Math.pow(2, 16) : int16bit;\n  }\n\n  // ECMA262 7.1.8\n  ToUint16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. Return int16bit.\n    return int16bit;\n  }\n\n  // ECMA262 7.1.9\n  ToInt8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. If int8bit ≥ 2^7, return int8bit - 2^8; otherwise return int8bit.\n    return int8bit >= Math.pow(2, 7) ? int8bit - Math.pow(2, 8) : int8bit;\n  }\n\n  // ECMA262 7.1.10\n  ToUint8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. Return int8bit.\n    return int8bit;\n  }\n\n  // ECMA262 7.1.11\n  ToUint8Clamp(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number ≤ 0, return +0.\n    if (number <= 0) return +0;\n\n    // 4. If number ≥ 255, return 255.\n    if (number >= 255) return 255;\n\n    // 5. Let f be floor(number).\n    let f = Math.floor(number);\n\n    // 6. If f + 0.5 < number, return f + 1.\n    if (f + 0.5 < number) return f + 1;\n\n    // 7. If number < f + 0.5, return f.\n    if (number < f + 0.5) return f;\n\n    // 8. If f is odd, return f + 1.\n    if (f % 2 === 1) return f + 1;\n\n    // 9. Return f.\n    return f;\n  }\n\n  // ECMA262 19.3.3.1\n  thisBooleanValue(realm: Realm, value: Value): BooleanValue {\n    // 1. If Type(value) is Boolean, return value.\n    if (value instanceof BooleanValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[BooleanData]] internal slot, then\n    if (value instanceof ObjectValue && value.$BooleanData) {\n      const booleanData = value.$BooleanData.throwIfNotConcreteBoolean();\n      // a. Assert: value's [[BooleanData]] internal slot is a Boolean value.\n      invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n\n      // b. Return the value of value's [[BooleanData]] internal slot.\n      return booleanData;\n    }\n\n    value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 20.1.3\n  thisNumberValue(realm: Realm, value: Value): NumberValue {\n    // 1. If Type(value) is Number, return value.\n    if (value instanceof NumberValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then\n    if (value instanceof ObjectValue && value.$NumberData) {\n      const numberData = value.$NumberData.throwIfNotConcreteNumber();\n      // a. Assert: value's [[NumberData]] internal slot is a Number value.\n      invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n\n      // b. Return the value of value's [[NumberData]] internal slot.\n      return numberData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 21.1.3\n  thisStringValue(realm: Realm, value: Value): StringValue {\n    // 1. If Type(value) is String, return value.\n    if (value instanceof StringValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[StringData]] internal slot, then\n    if (value instanceof ObjectValue && value.$StringData) {\n      const stringData = value.$StringData.throwIfNotConcreteString();\n      // a. Assert: value's [[StringData]] internal slot is a String value.\n      invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n\n      // b. Return the value of value's [[StringData]] internal slot.\n      return stringData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 6.2.4.5\n  ToPropertyDescriptor(realm: Realm, Obj: Value): Descriptor {\n    Obj = Obj.throwIfNotConcrete();\n\n    // 1. If Type(Obj) is not Object, throw a TypeError exception.\n    if (!(Obj instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 2. Let desc be a new Property Descriptor that initially has no fields.\n    let desc: Descriptor = {};\n\n    // 3. Let hasEnumerable be ? HasProperty(Obj, \"enumerable\").\n    let hasEnumerable = HasProperty(realm, Obj, \"enumerable\");\n\n    // 4. If hasEnumerable is true, then\n    if (hasEnumerable === true) {\n      // a. Let enum be ToBoolean(? Get(Obj, \"enumerable\")).\n      let enu = this.ToBooleanPartial(realm, Get(realm, Obj, \"enumerable\"));\n\n      // b. Set the [[Enumerable]] field of desc to enum.\n      desc.enumerable = enu === true;\n    }\n\n    // 5. Let hasConfigurable be ? HasProperty(Obj, \"configurable\").\n    let hasConfigurable = HasProperty(realm, Obj, \"configurable\");\n\n    // 6. If hasConfigurable is true, then\n    if (hasConfigurable === true) {\n      // a. Let conf be ToBoolean(? Get(Obj, \"configurable\")).\n      let conf = this.ToBooleanPartial(realm, Get(realm, Obj, \"configurable\"));\n\n      // b. Set the [[Configurable]] field of desc to conf.\n      desc.configurable = conf === true;\n    }\n\n    // 7. Let hasValue be ? HasProperty(Obj, \"value\").\n    let hasValue = HasProperty(realm, Obj, \"value\");\n\n    // 8. If hasValue is true, then\n    if (hasValue === true) {\n      // a. Let value be ? Get(Obj, \"value\").\n      let value = Get(realm, Obj, \"value\");\n\n      // b. Set the [[Value]] field of desc to value.\n      desc.value = value;\n    }\n\n    // 9. Let hasWritable be ? HasProperty(Obj, \"writable\").\n    let hasWritable = HasProperty(realm, Obj, \"writable\");\n\n    // 10. If hasWritable is true, then\n    if (hasWritable === true) {\n      // a. Let writable be ToBoolean(? Get(Obj, \"writable\")).\n      let writable = this.ToBooleanPartial(realm, Get(realm, Obj, \"writable\"));\n\n      // b. Set the [[Writable]] field of desc to writable.\n      desc.writable = writable === true;\n    }\n\n    // 11. Let hasGet be ? HasProperty(Obj, \"get\").\n    let hasGet = HasProperty(realm, Obj, \"get\");\n\n    // 12. If hasGet is true, then\n    if (hasGet === true) {\n      // a. Let getter be ? Get(Obj, \"get\").\n      let getter = Get(realm, Obj, \"get\");\n\n      // b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, getter) === false && !getter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      getter.throwIfNotConcrete();\n\n      // c. Set the [[Get]] field of desc to getter.\n      desc.get = ((getter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 13. Let hasSet be ? HasProperty(Obj, \"set\").\n    let hasSet = HasProperty(realm, Obj, \"set\");\n\n    // 14. If hasSet is true, then\n    if (hasSet === true) {\n      // a. Let setter be ? Get(Obj, \"set\").\n      let setter = Get(realm, Obj, \"set\");\n\n      // b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, setter) === false && !setter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      setter.throwIfNotConcrete();\n\n      // c. Set the [[Set]] field of desc to setter.\n      desc.set = ((setter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 15. If either desc.[[Get]] or desc.[[Set]] is present, then\n    if (desc.get || desc.set) {\n      // a. If either desc.[[Value]] or desc.[[Writable]] is present, throw a TypeError exception.\n      if (\"value\" in desc || \"writable\" in desc) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 16. Return desc.\n    return desc;\n  }\n\n  // ECMA262 7.1.13\n  ToObject(realm: Realm, arg: ConcreteValue): ObjectValue {\n    if (arg instanceof UndefinedValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof BooleanValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n      obj.$BooleanData = arg;\n      return obj;\n    } else if (arg instanceof NumberValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n      obj.$NumberData = arg;\n      return obj;\n    } else if (arg instanceof StringValue) {\n      let obj = Create.StringCreate(realm, arg, realm.intrinsics.StringPrototype);\n      return obj;\n    } else if (arg instanceof SymbolValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n      obj.$SymbolData = arg;\n      return obj;\n    } else if (arg instanceof ObjectValue) {\n      return arg;\n    }\n    invariant(false);\n  }\n\n  _WrapAbstractInObject(realm: Realm, arg: AbstractValue): ObjectValue | AbstractObjectValue {\n    let obj;\n    switch (arg.types.getType()) {\n      case NumberValue:\n        obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n        obj.$NumberData = arg;\n        break;\n\n      case StringValue:\n        obj = new ObjectValue(realm, realm.intrinsics.StringPrototype);\n        obj.$StringData = arg;\n        break;\n\n      case BooleanValue:\n        obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n        obj.$BooleanData = arg;\n        break;\n\n      case SymbolValue:\n        obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n        obj.$SymbolData = arg;\n        break;\n\n      case UndefinedValue:\n      case NullValue:\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n\n      default:\n        if (realm.isInPureScope()) {\n          // Create a placeholder value to represent the ObjectValue that we would've\n          // received, but this object should never leak so as an optimization we will\n          // let operations on top of this object force the ToObject operations instead.\n          obj = AbstractValue.createFromType(realm, ObjectValue, \"sentinel ToObject\");\n          invariant(obj instanceof AbstractObjectValue);\n          obj.args = [arg];\n        } else {\n          obj = arg.throwIfNotConcreteObject();\n        }\n        break;\n    }\n    return obj;\n  }\n\n  ToObjectPartial(realm: Realm, arg: Value): ObjectValue | AbstractObjectValue {\n    if (arg instanceof AbstractObjectValue) return arg;\n    if (arg instanceof AbstractValue) {\n      return this._WrapAbstractInObject(realm, arg);\n    }\n    arg = arg.throwIfNotConcrete();\n    return this.ToObject(realm, arg);\n  }\n\n  // ECMA262 7.1.15\n  ToLength(realm: Realm, argument: numberOrValue): number {\n    // Let len be ? ToInteger(argument).\n    let len = this.ToInteger(realm, argument);\n\n    // If len ≤ +0, return +0.\n    if (len <= 0) return +0;\n\n    // If len is +∞, return 2^53-1.\n    if (len === +Infinity) return Math.pow(2, 53) - 1;\n\n    // Return min(len, 2^53-1).\n    return Math.min(len, Math.pow(2, 53) - 1);\n  }\n\n  // ECMA262 7.1.4\n  ToInteger(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number is +0, -0, +∞, or -∞, return number.\n    if (!isFinite(number) || number === 0) return number;\n\n    // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\n    return number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n  }\n\n  // ECMA262 7.1.17\n  ToIndex(realm: Realm, value: number | ConcreteValue): number {\n    let index;\n    // 1. If value is undefined, then\n    if (value instanceof UndefinedValue) {\n      // a. Let index be 0.\n      index = 0;\n    } else {\n      // 2. Else,\n      // a. Let integerIndex be ? ToInteger(value).\n      let integerIndex = this.ToInteger(realm, value);\n\n      // b. If integerIndex < 0, throw a RangeError exception.\n      if (integerIndex < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n\n      // c. Let index be ! ToLength(integerIndex).\n      index = this.ToLength(realm, integerIndex);\n\n      // d. If SameValueZero(integerIndex, index) is false, throw a RangeError exception.\n      if (SameValueZero(realm, new NumberValue(realm, integerIndex), new NumberValue(realm, index)) === false) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n    }\n    // 3. Return index.\n    return index;\n  }\n\n  ToIndexPartial(realm: Realm, value: numberOrValue): number {\n    return this.ToIndex(realm, typeof value === \"number\" ? value : value.throwIfNotConcrete());\n  }\n\n  ToNumber(realm: Realm, val: numberOrValue): number {\n    const num = this.ToNumberOrAbstract(realm, val);\n    if (typeof num !== \"number\") {\n      AbstractValue.reportIntrospectionError(num);\n      throw new FatalError();\n    }\n    return num;\n  }\n\n  // ECMA262 7.1.3\n  ToNumberOrAbstract(realm: Realm, val: numberOrValue | AbstractValue): AbstractValue | number {\n    if (typeof val === \"number\") {\n      return val;\n    } else if (val instanceof AbstractValue) {\n      return val;\n    } else if (val instanceof UndefinedValue) {\n      return NaN;\n    } else if (val instanceof NullValue) {\n      return +0;\n    } else if (val instanceof ObjectValue) {\n      let prim = this.ToPrimitiveOrAbstract(realm, val, \"number\");\n      return this.ToNumberOrAbstract(realm, prim);\n    } else if (val instanceof BooleanValue) {\n      if (val.value === true) {\n        return 1;\n      } else {\n        // `val.value === false`\n        return 0;\n      }\n    } else if (val instanceof NumberValue) {\n      return val.value;\n    } else if (val instanceof StringValue) {\n      return Number(val.value);\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else {\n      invariant(false, \"unexpected type of value\");\n    }\n  }\n\n  IsToNumberPure(realm: Realm, val: numberOrValue): boolean {\n    if (val instanceof Value) {\n      if (this.IsToPrimitivePure(realm, val)) {\n        let type = val.getType();\n        return type !== SymbolValue && type !== PrimitiveValue && type !== Value;\n      }\n      return false;\n    }\n    return true;\n  }\n\n  // ECMA262 7.1.1\n  ToPrimitive(realm: Realm, input: ConcreteValue, hint?: \"default\" | \"string\" | \"number\"): PrimitiveValue {\n    return this.ToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  ToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ConcreteValue,\n    hint?: \"default\" | \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    if (input instanceof PrimitiveValue) {\n      return input;\n    }\n\n    // When Type(input) is Object, the following steps are taken\n    invariant(input instanceof ObjectValue, \"expected an object\");\n\n    // 1. If PreferredType was not passed, let hint be \"default\".\n    hint = hint || \"default\";\n\n    // Following two steps are redundant since we just pass string hints.\n    // 2. Else if PreferredType is hint String, let hint be \"string\".\n    // 3. Else PreferredType is hint Number, let hint be \"number\".\n\n    // 4. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\n    let exoticToPrim = GetMethod(realm, input, realm.intrinsics.SymbolToPrimitive);\n\n    // 5. If exoticToPrim is not undefined, then\n    if (!(exoticToPrim instanceof UndefinedValue)) {\n      // a. Let result be ? Call(exoticToPrim, input, « hint »).\n      let result = Call(realm, exoticToPrim, input, [new StringValue(realm, hint)]);\n\n      // b. If Type(result) is not Object, return result.\n      if (!(result instanceof ObjectValue)) {\n        invariant(result instanceof PrimitiveValue);\n        return result;\n      }\n\n      // c. Throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If hint is \"default\", let hint be \"number\".\n    if (hint === \"default\") hint = \"number\";\n\n    // 7. Return ? OrdinaryToPrimitive(input, hint).\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint);\n  }\n\n  // Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\n  GetToPrimitivePureResultType(realm: Realm, input: Value): void | typeof Value {\n    let type = input.getType();\n    if (input instanceof PrimitiveValue) return type;\n    if (input instanceof AbstractValue && !input.mightBeObject()) return PrimitiveValue;\n    return undefined;\n  }\n\n  IsToPrimitivePure(realm: Realm, input: Value) {\n    return this.GetToPrimitivePureResultType(realm, input) !== undefined;\n  }\n\n  // ECMA262 7.1.1\n  OrdinaryToPrimitive(realm: Realm, input: ObjectValue, hint: \"string\" | \"number\"): PrimitiveValue {\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  OrdinaryToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ObjectValue,\n    hint: \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    let methodNames;\n\n    // 1. Assert: Type(O) is Object.\n    invariant(input instanceof ObjectValue, \"Expected object\");\n\n    // 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\n    invariant(hint === \"string\" || hint === \"number\", \"Expected string or number hint\");\n\n    // 3. If hint is \"string\", then\n    if (hint === \"string\") {\n      // a. Let methodNames be « \"toString\", \"valueOf\" ».\n      methodNames = [\"toString\", \"valueOf\"];\n    } else {\n      // 4. Else,\n      // a. Let methodNames be « \"valueOf\", \"toString\" ».\n      methodNames = [\"valueOf\", \"toString\"];\n    }\n\n    // 5. For each name in methodNames in List order, do\n    for (let name of methodNames) {\n      // a. Let method be ? Get(O, name).\n      let method = Get(realm, input, new StringValue(realm, name));\n\n      // b. If IsCallable(method) is true, then\n      if (IsCallable(realm, method)) {\n        // i. Let result be ? Call(method, O).\n        let result = Call(realm, method, input);\n        let resultType = result.getType();\n\n        // ii. If Type(result) is not Object, return result.\n        if (Value.isTypeCompatibleWith(resultType, PrimitiveValue)) {\n          invariant(result instanceof AbstractValue || result instanceof PrimitiveValue);\n          return result;\n        }\n      }\n    }\n\n    // 6. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"can't turn to primitive\");\n  }\n\n  // ECMA262 7.1.12\n  ToString(realm: Realm, val: string | ConcreteValue): string {\n    if (typeof val === \"string\") {\n      return val;\n    } else if (val instanceof StringValue) {\n      return val.value;\n    } else if (val instanceof NumberValue) {\n      return val.value + \"\";\n    } else if (val instanceof UndefinedValue) {\n      return \"undefined\";\n    } else if (val instanceof NullValue) {\n      return \"null\";\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (val instanceof BooleanValue) {\n      return val.value ? \"true\" : \"false\";\n    } else if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitive(realm, val, \"string\");\n      return this.ToString(realm, primValue);\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to string\");\n    }\n  }\n\n  ToStringPartial(realm: Realm, val: string | Value): string {\n    return this.ToString(realm, typeof val === \"string\" ? val : val.throwIfNotConcrete());\n  }\n\n  ToStringValue(realm: Realm, val: Value): Value {\n    if (val.getType() === StringValue) return val;\n    let str;\n    if (typeof val === \"string\") {\n      str = val;\n    } else if (val instanceof NumberValue) {\n      str = val.value + \"\";\n    } else if (val instanceof UndefinedValue) {\n      str = \"undefined\";\n    } else if (val instanceof NullValue) {\n      str = \"null\";\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (val instanceof BooleanValue) {\n      str = val.value ? \"true\" : \"false\";\n    } else if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitiveOrAbstract(realm, val, \"string\");\n      if (primValue.getType() === StringValue) return primValue;\n      str = this.ToStringPartial(realm, primValue);\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to string\");\n    }\n    return new StringValue(realm, str);\n  }\n\n  // ECMA262 7.1.2\n  ToBoolean(realm: Realm, val: ConcreteValue): boolean {\n    if (val instanceof BooleanValue) {\n      return val.value;\n    } else if (val instanceof UndefinedValue) {\n      return false;\n    } else if (val instanceof NullValue) {\n      return false;\n    } else if (val instanceof NumberValue) {\n      return val.value !== 0 && !isNaN(val.value);\n    } else if (val instanceof StringValue) {\n      return val.value.length > 0;\n    } else if (val instanceof ObjectValue) {\n      return true;\n    } else if (val instanceof SymbolValue) {\n      return true;\n    } else {\n      invariant(!(val instanceof AbstractValue));\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"unknown value type, can't coerce to a boolean\"\n      );\n    }\n  }\n\n  ToBooleanPartial(realm: Realm, val: Value): boolean {\n    if (!val.mightNotBeObject()) return true;\n    return this.ToBoolean(realm, val.throwIfNotConcrete());\n  }\n\n  // ECMA262 7.1.14\n  ToPropertyKey(realm: Realm, arg: ConcreteValue): SymbolValue | string /* but not StringValue */ {\n    // 1. Let key be ? ToPrimitive(argument, hint String).\n    let key = this.ToPrimitive(realm, arg, \"string\");\n\n    // 2. If Type(key) is Symbol, then\n    if (key instanceof SymbolValue) {\n      // a. Return key.\n      return key;\n    }\n\n    // 3. Return ! ToString(key).\n    return this.ToString(realm, key);\n  }\n\n  ToPropertyKeyPartial(realm: Realm, arg: Value): AbstractValue | SymbolValue | string /* but not StringValue */ {\n    if (arg instanceof ConcreteValue) return this.ToPropertyKey(realm, arg);\n    if (arg.mightNotBeString() && arg.mightNotBeNumber()) arg.throwIfNotConcrete();\n    invariant(arg instanceof AbstractValue);\n    return arg;\n  }\n\n  // ECMA262 7.1.16\n  CanonicalNumericIndexString(realm: Realm, argument: StringValue): number | void {\n    // 1. Assert: Type(argument) is String.\n    invariant(argument instanceof StringValue);\n\n    // 2. If argument is \"-0\", return −0.\n    if (argument.value === \"-0\") return -0;\n\n    // 3. Let n be ToNumber(argument).\n    let n = this.ToNumber(realm, argument);\n\n    // 4. If SameValue(ToString(n), argument) is false, return undefined.\n    if (SameValue(realm, new StringValue(realm, this.ToString(realm, new NumberValue(realm, n))), argument) === false)\n      return undefined;\n\n    // 5. Return n.\n    return n;\n  }\n}\n"]}