{"version":3,"sources":["../../src/methods/function.js"],"names":["t","InternalCall","realm","F","thisArgument","argsList","tracerIndex","tracer","tracers","nextIndex","detourResult","detourCall","undefined","length","$FunctionKind","createErrorThrowCompletion","intrinsics","TypeError","callerContext","getRunningContext","calleeContext","calleeEnv","lexicalEnvironment","result","t1","beforeCall","popContext","onDestroyScope","t2","afterCall","value","$BoundCall","argumentsList","target","$BoundTargetFunction","boundThis","$BoundThis","boundArgs","$BoundArguments","args","concat","$BoundConstruct","newTarget","$Construct","InternalConstruct","hasRunningContext","useAbstractInterpretation","kind","$ConstructorKind","OrdinaryCreateFromConstructor","envRec","constructorEnv","environmentRecord","mightBeObject","throwIfNotConcreteObject","mightBeUndefined","throwIfNotConcrete","envRecThisBinding","GetThisBinding","FunctionImplementation","ast_node","FindVarScopedDeclarationsFor","ast","level","statements","type","body","astIfStatement","consequent","alternate","astForStatement","init","astForInStatement","left","astForOfStatement","cases","switchCase","astTryStatement","block","finalizer","push","handler","decls","statement","func","env","code","$ECMAScriptCode","strict","$Strict","formals","$FormalParameters","parameterNames","Object","create","param","paramBindings","getBindingIdentifiers","name","hasDuplicates","identifiers","keys","simpleParameterList","hasParameterExpressions","ContainsExpression","varNames","node","varDeclarations","FindVarScopedDeclarations","lexicalNames","functionNames","functionsToInitialize","reverse","d","fn","BoundNames","indexOf","unshift","argumentsObjectNeeded","$ThisMode","paramName","alreadyDeclared","HasBinding","CreateMutableBinding","InitializeBinding","ao","CreateUnmappedArgumentsObject","CreateMappedArgumentsObject","CreateImmutableBinding","iteratorRecord","$Iterator","$Done","IteratorBindingInitialization","varEnv","varEnvRec","instantiatedVarNames","slice","n","NewDeclarativeEnvironment","activeLexicalEnvironments","delete","variableEnvironment","initialValue","GetBindingValue","lexEnv","add","lexEnvRec","lexDeclarations","dn","f","fo","evaluate","SetMutableBinding","empty","prefix","getExtensible","description","$Description","emptyString","throwIfNotConcreteString","prefixVal","createFromBinaryOp","expressionLocation","DefinePropertyOrThrow","enumerable","writable","configurable","ParameterList","Body","Scope","isNewObject","len","FormalParameter","Strict","$Environment","uniqueOrderedTag","functionBodyUniqueTagSeed","$ScriptOrModule","GetActiveScriptOrModule","functionPrototype","Generator","FunctionAllocate","FunctionInitialize","thrower","ThrowTypeError","desc","get","set","functionKind","needsConstruct","$Call","$Prototype","setExtensible","$Realm","targetFunction","proto","$GetPrototypeOf","obj","x","evalRealm","strictCaller","direct","script","program","blockStatement","directives","strictEval","ctx","$GlobalEnv","suspend","evalCxt","isStrict","setFunction","setRealm","ScriptOrModule","pushContext","EvalDeclarationInstantiation","e","directive","EvaluateStatements","resume","c","savedCompletion","savedPathConditions","pathConditions","updatePossiblyNormalCompletionWithValue","getCapturedEffects","stopEffectCaptureAndUndoEffects","joined_effects","joinPossiblyNormalCompletionWithAbruptCompletion","applyEffects","jc","initialBlockValue","strictCode","blockEnv","blockValue","res","evaluateCompletionDeref","statementAsts","partiallyEvaluateCompletionDeref","nast","nio","ioAst","prototype","FunctionPrototype","allocKind","HasLexicalDeclaration","SyntaxError","thisLex","thisEnvRec","parent","declaredFunctionNames","fnDefinable","CanDeclareGlobalFunction","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","s","CreateGlobalFunctionBinding","bindingExists","CreateGlobalVarBinding","homeObject","$HomeObject","prop","propKey","scope","closure","FunctionCreate","params","MakeMethod","$Key","$Closure"],"mappings":"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","file":"function.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue, FunctionBodyAstNode } from \"../types.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ECMAScriptFunctionValue } from \"../values/index.js\";\nimport { Completion, ReturnCompletion, AbruptCompletion, NormalCompletion } from \"../completions.js\";\nimport { ExecutionContext } from \"../realm.js\";\nimport { GlobalEnvironmentRecord, ObjectEnvironmentRecord } from \"../environment.js\";\nimport {\n  AbstractValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { OrdinaryCallEvaluateBody, OrdinaryCallBindThis, PrepareForOrdinaryCall, Call } from \"./call.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { CreateListIterator } from \"../methods/iterator.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport { Create, Environment, Join, Properties } from \"../singletons.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNode,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeBlockStatement,\n  BabelNodeProgram,\n  BabelNodeDoWhileStatement,\n  BabelNodeWhileStatement,\n  BabelNodeLabeledStatement,\n  BabelNodeWithStatement,\n  BabelNodeSwitchStatement,\n  BabelNodeIfStatement,\n  BabelNodeForStatement,\n  BabelNodeForInStatement,\n  BabelNodeForOfStatement,\n  BabelNodeTryStatement,\n  BabelNodeObjectMethod,\n  BabelNodeClassMethod,\n} from \"babel-types\";\n\nfunction InternalCall(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  thisArgument: Value,\n  argsList: Array<Value>,\n  tracerIndex: number\n): Value {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function value\");\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argsList, undefined, () =>\n      InternalCall(realm, F, thisArgument, argsList, nextIndex)\n    );\n    if (detourResult instanceof Value) return detourResult;\n  }\n\n  // 2. If F's [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.\n  if (F.$FunctionKind === \"classConstructor\")\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, undefined);\n  let calleeEnv = calleeContext.lexicalEnvironment;\n\n  let result;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argsList, undefined);\n\n    // 5. Assert: calleeContext is now the running execution context.\n    invariant(realm.getRunningContext() === calleeContext, \"calleeContext should be current execution context\");\n\n    // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n\n    // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argsList);\n  } finally {\n    // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    realm.onDestroyScope(calleeContext.lexicalEnvironment);\n    if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argsList, undefined, (result: any));\n  }\n\n  // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).\n  if (result instanceof ReturnCompletion) {\n    return result.value;\n  }\n\n  // 10. ReturnIfAbrupt(result).  or if possibly abrupt\n  if (result instanceof Completion) {\n    throw result;\n  }\n\n  // 11. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 9.4.1.1\nfunction $BoundCall(realm: Realm, F: BoundFunctionValue, thisArgument: Value, argumentsList: Array<Value>): Value {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Let boundThis be the value of F's [[BoundThis]] internal slot.\n  let boundThis = F.$BoundThis;\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. Return ? Call(target, boundThis, args).\n  return Call(realm, target, boundThis, args);\n}\n\n// ECMA262 9.4.1.2\nfunction $BoundConstruct(\n  realm: Realm,\n  F: BoundFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue\n): ObjectValue {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Assert: target has a [[Construct]] internal method.\n  invariant(target.$Construct !== undefined, \"doesn't have a construct internal method\");\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. If SameValue(F, newTarget) is true, let newTarget be target.\n  if (SameValue(realm, F, newTarget)) newTarget = target;\n\n  // 6. Return ? Construct(target, args, newTarget).\n  return Construct(realm, target, args, newTarget);\n}\n\nfunction InternalConstruct(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue,\n  thisArgument: void | ObjectValue,\n  tracerIndex: number\n): ObjectValue {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function\");\n\n  // 2. Assert: Type(newTarget) is Object.\n  invariant(newTarget instanceof ObjectValue, \"expected object\");\n\n  if (!realm.hasRunningContext()) {\n    invariant(realm.useAbstractInterpretation);\n    throw new FatalError(\"no running context\");\n  }\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let kind be F's [[ConstructorKind]] internal slot.\n  let kind = F.$ConstructorKind;\n\n  // 5. If kind is \"base\", then\n  if (thisArgument === undefined && kind === \"base\") {\n    // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n    thisArgument = Create.OrdinaryCreateFromConstructor(realm, newTarget, \"ObjectPrototype\");\n  }\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argumentsList, newTarget, () =>\n      InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, nextIndex)\n    );\n    if (detourResult instanceof ObjectValue) return detourResult;\n    invariant(detourResult === undefined);\n  }\n\n  // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, newTarget);\n  let calleeEnv = calleeContext.lexicalEnvironment;\n\n  // 7. Assert: calleeContext is now the running execution context.\n  invariant(realm.getRunningContext() === calleeContext, \"expected calleeContext to be running context\");\n\n  let result, envRec;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argumentsList, newTarget);\n\n    // 8. If kind is \"base\", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n    }\n\n    // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.\n    let constructorEnv = calleeContext.lexicalEnvironment;\n\n    // 10. Let envRec be constructorEnv's EnvironmentRecord.\n    envRec = constructorEnv.environmentRecord;\n\n    // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argumentsList);\n  } finally {\n    // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    realm.onDestroyScope(calleeContext.lexicalEnvironment);\n    if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argumentsList, newTarget, result);\n  }\n\n  // 13. If result.[[Type]] is return, then\n  if (result instanceof ReturnCompletion) {\n    // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).\n    if (result.value.mightBeObject()) {\n      return result.value.throwIfNotConcreteObject();\n    }\n\n    // b. If kind is \"base\", return NormalCompletion(thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      return thisArgument;\n    }\n\n    // c. If result.[[Value]] is not undefined, throw a TypeError exception.\n    if (!result.value.mightBeUndefined())\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"constructor must return Object\");\n    result.value.throwIfNotConcrete();\n  } else if (result instanceof AbruptCompletion) {\n    // 14. Else, ReturnIfAbrupt(result).\n    throw result;\n  }\n\n  // 15. Return ? envRec.GetThisBinding().\n  let envRecThisBinding = envRec.GetThisBinding();\n  invariant(envRecThisBinding instanceof ObjectValue);\n  return envRecThisBinding;\n}\n\nexport class FunctionImplementation {\n  FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode> {\n    function FindVarScopedDeclarationsFor(ast: BabelNode, level: number) {\n      let statements = [];\n      switch (ast.type) {\n        case \"Program\":\n          statements = ((ast: any): BabelNodeProgram).body;\n          break;\n        case \"BlockStatement\":\n          statements = ((ast: any): BabelNodeBlockStatement).body;\n          break;\n        case \"DoWhileStatement\":\n          statements = [((ast: any): BabelNodeDoWhileStatement).body];\n          break;\n        case \"WhileStatement\":\n          statements = [((ast: any): BabelNodeWhileStatement).body];\n          break;\n        case \"IfStatement\":\n          let astIfStatement: BabelNodeIfStatement = (ast: any);\n          statements = [astIfStatement.consequent, astIfStatement.alternate];\n          break;\n        case \"ForStatement\":\n          let astForStatement: BabelNodeForStatement = (ast: any);\n          statements = [astForStatement.init, astForStatement.body];\n          break;\n        case \"ForInStatement\":\n          let astForInStatement: BabelNodeForInStatement = (ast: any);\n          statements = [astForInStatement.left, astForInStatement.body];\n          break;\n        case \"ForOfStatement\":\n          let astForOfStatement: BabelNodeForOfStatement = (ast: any);\n          statements = [astForOfStatement.left, astForOfStatement.body];\n          break;\n        case \"LabeledStatement\":\n          statements = [((ast: any): BabelNodeLabeledStatement).body];\n          break;\n        case \"WithStatement\":\n          statements = [((ast: any): BabelNodeWithStatement).body];\n          break;\n        case \"SwitchStatement\":\n          for (let switchCase of ((ast: any): BabelNodeSwitchStatement).cases) {\n            statements = statements.concat(switchCase.consequent);\n          }\n          break;\n        case \"TryStatement\":\n          let astTryStatement: BabelNodeTryStatement = (ast: any);\n          statements = [astTryStatement.block];\n          if (astTryStatement.finalizer) statements.push(astTryStatement.finalizer);\n          if (astTryStatement.handler) statements.push(astTryStatement.handler.body);\n          break;\n        case \"VariableDeclaration\":\n          return ast.kind === \"var\" ? [ast] : [];\n        case \"FunctionDeclaration\":\n          return level < 2 ? [ast] : [];\n        default:\n          return [];\n      }\n\n      let decls = [];\n      for (let statement of statements) {\n        if (statement) {\n          decls = decls.concat(FindVarScopedDeclarationsFor(statement, level + 1));\n        }\n      }\n\n      return decls;\n    }\n    return FindVarScopedDeclarationsFor(ast_node, 0);\n  }\n\n  // ECMA262 9.2.12\n  FunctionDeclarationInstantiation(\n    realm: Realm,\n    func: ECMAScriptSourceFunctionValue,\n    argumentsList: Array<Value>\n  ): EmptyValue {\n    // 1. Let calleeContext be the running execution context.\n    let calleeContext = realm.getRunningContext();\n\n    // 2. Let env be the LexicalEnvironment of calleeContext.\n    let env = calleeContext.lexicalEnvironment;\n\n    // 3. Let envRec be env's EnvironmentRecord.\n    let envRec = env.environmentRecord;\n\n    // 4. Let code be the value of the [[ECMAScriptCode]] internal slot of func.\n    let code = func.$ECMAScriptCode;\n    invariant(code !== undefined);\n\n    // 5. Let strict be the value of the [[Strict]] internal slot of func.\n    let strict = func.$Strict;\n\n    // 6. Let formals be the value of the [[FormalParameters]] internal slot of func.\n    let formals = func.$FormalParameters;\n    invariant(formals !== undefined);\n\n    // 7. Let parameterNames be the BoundNames of formals.\n    let parameterNames = Object.create(null);\n    for (let param of formals) {\n      let paramBindings = t.getBindingIdentifiers(param, true);\n\n      for (let name in paramBindings) {\n        parameterNames[name] = (parameterNames[name] || []).concat(paramBindings[name]);\n      }\n    }\n\n    // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.\n    let hasDuplicates = false;\n    for (let name in parameterNames) {\n      let identifiers = parameterNames[name];\n      if (identifiers.length > 1) hasDuplicates = true;\n    }\n    parameterNames = Object.keys(parameterNames);\n\n    // 9. Let simpleParameterList be IsSimpleParameterList of formals.\n    let simpleParameterList = true;\n    for (let param of formals) {\n      if (param.type !== \"Identifier\") {\n        simpleParameterList = false;\n        break;\n      }\n    }\n\n    // 10. Let hasParameterExpressions be ContainsExpression of formals.\n    let hasParameterExpressions = false;\n    invariant(formals !== undefined);\n    for (let param of formals) {\n      if (Environment.ContainsExpression(realm, param)) {\n        hasParameterExpressions = true;\n        break;\n      }\n    }\n\n    // 11. Let varNames be the VarDeclaredNames of code.\n    let varNames = [];\n    traverseFast(code, node => {\n      if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 12. Let varDeclarations be the VarScopedDeclarations of code.\n    let varDeclarations = this.FindVarScopedDeclarations(code);\n\n    // 13. Let lexicalNames be the LexicallyDeclaredNames of code.\n    let lexicalNames = [];\n\n    // 14. Let functionNames be an empty List.\n    let functionNames = [];\n\n    // 15. Let functionsToInitialize be an empty List.\n    let functionsToInitialize = [];\n\n    // 16. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iii. If fn is not an element of functionNames, then\n        if (functionNames.indexOf(fn) < 0) {\n          // 1. Insert fn as the first element of functionNames.\n          functionNames.unshift(fn);\n          // 2. NOTE If there are multiple FunctionDeclarations or GeneratorDeclarations for the same name, the last declaration is used.\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 17. Let argumentsObjectNeeded be true.\n    let argumentsObjectNeeded = true;\n\n    // 18. If the value of the [[realmMode]] internal slot of func is lexical, then\n    if (func.$ThisMode === \"lexical\") {\n      // a. NOTE Arrow functions never have an arguments objects.\n      // b. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (parameterNames.indexOf(\"arguments\") >= 0) {\n      // 19. Else if \"arguments\" is an element of parameterNames, then\n      // a. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (hasParameterExpressions === false) {\n      // 20. Else if hasParameterExpressions is false, then\n      // a. If \"arguments\" is an element of functionNames or if \"arguments\" is an element of lexicalNames, then\n      if (functionNames.indexOf(\"arguments\") >= 0 || lexicalNames.indexOf(\"arguments\") >= 0) {\n        // i. Let argumentsObjectNeeded be false.\n        argumentsObjectNeeded = true;\n      }\n    }\n\n    // 21. For each String paramName in parameterNames, do\n    for (let paramName of parameterNames) {\n      // a. Let alreadyDeclared be envRec.HasBinding(paramName).\n      let alreadyDeclared = envRec.HasBinding(paramName);\n\n      // b. NOTE Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n\n      // c. If alreadyDeclared is false, then\n      if (alreadyDeclared === false) {\n        // i. Perform ! envRec.CreateMutableBinding(paramName, false).\n        envRec.CreateMutableBinding(paramName, false);\n\n        // ii. If hasDuplicates is true, then\n        if (hasDuplicates === true) {\n          // 1. Perform ! envRec.InitializeBinding(paramName, undefined).\n          envRec.InitializeBinding(paramName, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 22. If argumentsObjectNeeded is true, then\n    if (argumentsObjectNeeded === true) {\n      let ao;\n\n      // a. If strict is true or if simpleParameterList is false, then\n      if (strict === true || simpleParameterList === false) {\n        // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).\n        ao = Create.CreateUnmappedArgumentsObject(realm, argumentsList);\n      } else {\n        // b. Else,\n        // i. NOTE mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n        // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).\n        invariant(formals !== undefined);\n        ao = Create.CreateMappedArgumentsObject(realm, func, formals, argumentsList, envRec);\n      }\n\n      // c. If strict is true, then\n      if (strict === true) {\n        // i. Perform ! envRec.CreateImmutableBinding(\"arguments\", false).\n        envRec.CreateImmutableBinding(\"arguments\", false);\n      } else {\n        // d. Else,\n        // i. Perform ! envRec.CreateMutableBinding(\"arguments\", false).\n        envRec.CreateMutableBinding(\"arguments\", false);\n      }\n\n      // e. Call envRec.InitializeBinding(\"arguments\", ao).\n      envRec.InitializeBinding(\"arguments\", ao);\n\n      // f. Append \"arguments\" to parameterNames.\n      parameterNames.push(\"arguments\");\n    }\n\n    // 23. Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: CreateListIterator(realm, argumentsList),\n      $Done: false,\n    };\n\n    // 24. If hasDuplicates is true, then\n    if (hasDuplicates === true) {\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict);\n    } else {\n      // 25. Else,\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict, env);\n    }\n\n    // 26. If hasParameterExpressions is false, then\n    let varEnv, varEnvRec;\n    if (hasParameterExpressions === false) {\n      // a. NOTE Only a single lexical environment is needed for the parameters and top-level vars.\n      // b. Let instantiatedVarNames be a copy of the List parameterNames.\n      let instantiatedVarNames = parameterNames.slice();\n\n      // c. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! envRec.CreateMutableBinding(n, false).\n          envRec.CreateMutableBinding(n, false);\n\n          // 3. Call envRec.InitializeBinding(n, undefined).\n          envRec.InitializeBinding(n, realm.intrinsics.undefined);\n        }\n      }\n\n      // e. Let varEnv be env.\n      varEnv = env;\n\n      // f. Let varEnvRec be envRec.\n      varEnvRec = envRec;\n    } else {\n      // 27. Else,\n      // a. NOTE A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n\n      // b. Let varEnv be NewDeclarativeEnvironment(env).\n      varEnv = Environment.NewDeclarativeEnvironment(realm, env);\n      // At this point we haven't set any context's lexical environment to varEnv (and we might never do so),\n      // so it shouldn't be active\n      realm.activeLexicalEnvironments.delete(varEnv);\n\n      // c. Let varEnvRec be varEnv's EnvironmentRecord.\n      varEnvRec = varEnv.environmentRecord;\n\n      // d. Set the VariableEnvironment of calleeContext to varEnv.\n      calleeContext.variableEnvironment = varEnv;\n\n      // e. Let instantiatedVarNames be a new empty List.\n      let instantiatedVarNames = [];\n\n      // f. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! varEnvRec.CreateMutableBinding(n, false).\n          varEnvRec.CreateMutableBinding(n, false);\n\n          // 3. If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.\n          let initialValue;\n          if (parameterNames.indexOf(n) < 0 || functionNames.indexOf(n) < 0) {\n            initialValue = realm.intrinsics.undefined;\n          } else {\n            // 4. Else,\n            // a. Let initialValue be ! envRec.GetBindingValue(n, false).\n            initialValue = envRec.GetBindingValue(n, false);\n          }\n\n          // 5. Call varEnvRec.InitializeBinding(n, initialValue).\n          varEnvRec.InitializeBinding(n, initialValue);\n\n          // 6. NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.\n        }\n      }\n    }\n\n    // 28. NOTE: Annex B.3.3.1 adds additional steps at realm point.\n\n    let lexEnv;\n\n    // 29. If strict is false, then\n    if (strict === false) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, varEnv);\n\n      // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval (see 12.3.4.1) can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. realm is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n    } else {\n      // 30. Else, let lexEnv be varEnv.\n      lexEnv = varEnv;\n      // Since we previously removed varEnv, make sure to re-add it when it's used.\n      realm.activeLexicalEnvironments.add(varEnv);\n    }\n\n    // 31. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 32. Set the LexicalEnvironment of calleeContext to lexEnv.\n    calleeContext.lexicalEnvironment = lexEnv;\n\n    // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n    let lexDeclarations = [];\n\n    // 34. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // i. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // ii. Else,\n          // 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 35. For each parsed grammar phrase f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n      varEnvRec.SetMutableBinding(fn, fo, false);\n    }\n\n    // 36. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA262 9.2.11\n  SetFunctionName(realm: Realm, F: ObjectValue, name: PropertyKeyValue | AbstractValue, prefix?: string): boolean {\n    // 1. Assert: F is an extensible object that does not have a name own property.\n    invariant(F.getExtensible(), \"expected object to be extensible and not have a name property\");\n\n    // 2. Assert: Type(name) is either Symbol or String.\n    invariant(\n      typeof name === \"string\" ||\n        name instanceof StringValue ||\n        name instanceof SymbolValue ||\n        name instanceof AbstractValue,\n      \"expected name to be a string or symbol\"\n    );\n    if (typeof name === \"string\") name = new StringValue(realm, name);\n\n    // 3. Assert: If prefix was passed, then Type(prefix) is String.\n    invariant(prefix === undefined || typeof prefix === \"string\", \"expected prefix to be a string if passed\");\n\n    // 4. If Type(name) is Symbol, then\n    if (name instanceof SymbolValue) {\n      // a. Let description be name's [[Description]] value.\n      let description = name.$Description;\n\n      // b. If description is undefined, let name be the empty String.\n      if (description === undefined) {\n        name = realm.intrinsics.emptyString;\n      } else {\n        // c. Else, let name be the concatenation of \"[\", description, and \"]\".\n        invariant(description instanceof Value);\n        name = new StringValue(realm, `[${description.throwIfNotConcreteString().value}]`);\n      }\n    }\n\n    // 5. If prefix was passed, then\n    if (prefix) {\n      // a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and name.\n      if (name instanceof AbstractValue) {\n        let prefixVal = new StringValue(realm, prefix + \" \");\n        name = AbstractValue.createFromBinaryOp(realm, \"+\", prefixVal, name, name.expressionLocation);\n      } else {\n        name = new StringValue(realm, `${prefix} ${name.value}`);\n      }\n    }\n\n    // 6. Return ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(realm, F, \"name\", {\n      value: name,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // ECMA262 9.2.3\n  FunctionInitialize(\n    realm: Realm,\n    F: ECMAScriptSourceFunctionValue,\n    kind: \"normal\" | \"method\" | \"arrow\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment\n  ): ECMAScriptSourceFunctionValue {\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an extensible object that does not have a length own property.\n    invariant(F.getExtensible(), \"expected to be extensible and no length property\");\n\n    // 2. Let len be the ExpectedArgumentCount of ParameterList.\n    let len = 0;\n    for (let FormalParameter of ParameterList) {\n      if (FormalParameter.type === \"AssignmentPattern\") {\n        break;\n      }\n      len += 1;\n    }\n\n    // 3. Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, F, \"length\", {\n      value: new NumberValue(realm, len),\n      writable: false,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 4. Let Strict be the value of the [[Strict]] internal slot of F.\n    let Strict = F.$Strict;\n    if (!Strict) {\n      Properties.DefinePropertyOrThrow(realm, F, \"caller\", {\n        value: new UndefinedValue(realm),\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      });\n    }\n\n    // 5. Set the [[Environment]] internal slot of F to the value of Scope.\n    F.$Environment = Scope;\n\n    // 6. Set the [[FormalParameters]] internal slot of F to ParameterList.\n    F.$FormalParameters = ParameterList;\n\n    // 7. Set the [[ECMAScriptCode]] internal slot of F to Body.\n    ((Body: any): FunctionBodyAstNode).uniqueOrderedTag = realm.functionBodyUniqueTagSeed++;\n    F.$ECMAScriptCode = Body;\n\n    // 8. Set the [[ScriptOrModule]] internal slot of F to GetActiveScriptOrModule().\n    F.$ScriptOrModule = Environment.GetActiveScriptOrModule(realm);\n\n    // 9. If kind is Arrow, set the [[realmMode]] internal slot of F to lexical.\n    if (kind === \"arrow\") {\n      F.$ThisMode = \"lexical\";\n    } else if (Strict === true) {\n      // 10. Else if Strict is true, set the [[realmMode]] internal slot of F to strict.\n      F.$ThisMode = \"strict\";\n    } else {\n      // 11. Else set the [[realmMode]] internal slot of F to global.\n      F.$ThisMode = \"global\";\n    }\n\n    // Return F.\n    return F;\n  }\n\n  // ECMA262 9.2.6\n  GeneratorFunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Let functionPrototype be the intrinsic object %Generator%.\n    let functionPrototype = realm.intrinsics.Generator;\n\n    // 2. Let F be FunctionAllocate(functionPrototype, Strict, \"generator\").\n    let F = this.FunctionAllocate(realm, functionPrototype, Strict, \"generator\");\n\n    // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n  }\n\n  // ECMA262 9.2.7\n  AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm): boolean {\n    // 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n    // 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].\n    let thrower = realm.intrinsics.ThrowTypeError;\n    invariant(thrower);\n\n    let desc = {\n      get: thrower,\n      set: thrower,\n      enumerable: false,\n      configurable: true,\n    };\n    // 3. Perform ! DefinePropertyOrThrow(F, \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, F, \"caller\", desc);\n    // 4. Return ! DefinePropertyOrThrow(F, \"arguments\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(realm, F, \"arguments\", desc);\n  }\n\n  // ECMA262 9.2.1\n  $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value {\n    return InternalCall(realm, F, thisArgument, argsList, 0);\n  }\n\n  // ECMA262 9.2.2\n  $Construct(\n    realm: Realm,\n    F: ECMAScriptFunctionValue,\n    argumentsList: Array<Value>,\n    newTarget: ObjectValue\n  ): ObjectValue {\n    return InternalConstruct(realm, F, argumentsList, newTarget, undefined, 0);\n  }\n\n  // ECMA262 9.2.3\n  FunctionAllocate(\n    realm: Realm,\n    functionPrototype: ObjectValue,\n    strict: boolean,\n    functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Assert: Type(functionPrototype) is Object.\n    invariant(functionPrototype instanceof ObjectValue, \"expected functionPrototype to be an object\");\n\n    // 2. Assert: functionKind is either \"normal\", \"non-constructor\" or \"generator\".\n    invariant(\n      functionKind === \"normal\" || functionKind === \"non-constructor\" || functionKind === \"generator\",\n      \"invalid functionKind\"\n    );\n\n    // 3. If functionKind is \"normal\", let needsConstruct be true.\n    let needsConstruct;\n    if (functionKind === \"normal\") {\n      needsConstruct = true;\n    } else {\n      // 4. Else, let needsConstruct be false.\n      needsConstruct = false;\n    }\n\n    // 5. If functionKind is \"non-constructor\", let functionKind be \"normal\".\n    if (functionKind === \"non-constructor\") {\n      functionKind = \"normal\";\n    }\n\n    // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.\n    let F = new ECMAScriptSourceFunctionValue(realm);\n\n    // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 8. Set F's [[Call]] internal method to the definition specified in 9.2.1.\n    F.$Call = (thisArgument, argsList) => {\n      return this.$Call(realm, F, thisArgument, argsList);\n    };\n\n    // 9. If needsConstruct is true, then\n    if (needsConstruct === true) {\n      // a. Set F's [[Construct]] internal method to the definition specified in 9.2.2.\n      F.$Construct = (argumentsList, newTarget) => {\n        return this.$Construct(realm, F, argumentsList, newTarget);\n      };\n\n      // b. Set the [[ConstructorKind]] internal slot of F to \"base\".\n      F.$ConstructorKind = \"base\";\n    }\n\n    // 10. Set the [[Strict]] internal slot of F to strict.\n    F.$Strict = strict;\n\n    // 11. Set the [[FunctionKind]] internal slot of F to functionKind.\n    F.$FunctionKind = functionKind;\n\n    // 12. Set the [[Prototype]] internal slot of F to functionPrototype.\n    F.$Prototype = functionPrototype;\n\n    // 13. Set the [[Extensible]] internal slot of F to true.\n    F.setExtensible(true);\n\n    // 14. Set the [[Realm]] internal slot of F to the current Realm Record.\n    F.$Realm = realm;\n\n    // 15. Return F.\n    return F;\n  }\n\n  // ECMA262 9.4.1.3\n  BoundFunctionCreate(\n    realm: Realm,\n    targetFunction: ObjectValue,\n    boundThis: Value,\n    boundArgs: Array<Value>\n  ): ObjectValue {\n    // 1. Assert: Type(targetFunction) is Object.\n    invariant(targetFunction instanceof ObjectValue, \"expected an object\");\n\n    // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().\n    let proto = targetFunction.$GetPrototypeOf();\n\n    // 3. Let obj be a newly created object.\n    let obj = new BoundFunctionValue(realm);\n\n    // 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 5. Set the [[Call]] internal method of obj as described in 9.4.1.1.\n    obj.$Call = (thisArgument, argsList) => {\n      return $BoundCall(realm, obj, thisArgument, argsList);\n    };\n\n    // 6. If targetFunction has a [[Construct]] internal method, then\n    if (targetFunction.$Construct) {\n      // a. Set the [[Construct]] internal method of obj as described in 9.4.1.2.\n      obj.$Construct = (thisArgument, argsList) => {\n        return $BoundConstruct(realm, obj, thisArgument, argsList);\n      };\n    }\n\n    // 7. Set the [[Prototype]] internal slot of obj to proto.\n    obj.$Prototype = proto;\n\n    // 8. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 9. Set the [[BoundTargetFunction]] internal slot of obj to targetFunction.\n    obj.$BoundTargetFunction = targetFunction;\n\n    // 10. Set the [[BoundThis]] internal slot of obj to the value of boundThis.\n    obj.$BoundThis = boundThis;\n\n    // 11. Set the [[BoundArguments]] internal slot of obj to boundArgs.\n    obj.$BoundArguments = boundArgs;\n\n    // 12. Return obj.\n    return obj;\n  }\n\n  // ECMA262 18.2.1.1\n  PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value {\n    // 1. Assert: If direct is false, then strictCaller is also false.\n    if (direct === false) invariant(strictCaller === false, \"strictCaller is only allowed on direct eval\");\n\n    // 2. If Type(x) is not String, return x.\n    if (!(x instanceof StringValue)) return x;\n\n    // 3. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text\n    //    as described in 6.1.4, for the goal symbol Script. If the parse fails, throw a SyntaxError exception. If any\n    //    early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the\n    //    error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation\n    //    dependent manner.\n    let ast = parse(realm, x.value, \"eval\", \"script\");\n    let script = ast.program;\n\n    // 4. If script Contains ScriptBody is false, return undefined.\n    if (!script.body) return realm.intrinsics.undefined;\n\n    // 5. Let body be the ScriptBody of script.\n    let body = t.blockStatement(script.body, script.directives);\n\n    // 6. If strictCaller is true, let strictEval be true.\n    let strictEval;\n    if (strictCaller) {\n      strictEval = true;\n    } else {\n      // 7. Else, let strictEval be IsStrict of script.\n      strictEval = IsStrict(script);\n    }\n\n    // 8. Let ctx be the running execution context. If direct is true, ctx will be the execution context that\n    //    performed the direct eval. If direct is false, ctx will be the execution context for the invocation of\n    //    the eval function.\n    let ctx = realm.getRunningContext();\n\n    // 9. If direct is true, then\n    let lexEnv, varEnv;\n    if (direct) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, ctx.lexicalEnvironment);\n\n      // b. Let varEnv be ctx's VariableEnvironment.\n      varEnv = ctx.variableEnvironment;\n    } else {\n      // 10. Else,\n      // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, evalRealm.$GlobalEnv);\n\n      // b. Let varEnv be evalRealm.[[GlobalEnv]].\n      varEnv = evalRealm.$GlobalEnv;\n    }\n\n    // 11. If strictEval is true, let varEnv be lexEnv.\n    if (strictEval) varEnv = lexEnv;\n\n    // 12. If ctx is not already suspended, suspend ctx.\n    ctx.suspend();\n\n    // 13. Let evalCxt be a new ECMAScript code execution context.\n    let evalCxt = new ExecutionContext();\n    evalCxt.isStrict = strictEval;\n\n    // 14. Set the evalCxt's Function to null.\n    evalCxt.setFunction(null);\n\n    // 15. Set the evalCxt's Realm to evalRealm.\n    evalCxt.setRealm(evalRealm);\n\n    // 16. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.\n    evalCxt.ScriptOrModule = ctx.ScriptOrModule;\n\n    // 17. Set the evalCxt's VariableEnvironment to varEnv.\n    evalCxt.variableEnvironment = varEnv;\n\n    // 18. Set the evalCxt's LexicalEnvironment to lexEnv.\n    evalCxt.lexicalEnvironment = lexEnv;\n\n    // 19. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.\n    realm.pushContext(evalCxt);\n\n    let result;\n    try {\n      // 20. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).\n      invariant(varEnv);\n      try {\n        result = this.EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strictEval);\n      } catch (e) {\n        if (e instanceof AbruptCompletion) {\n          result = e;\n        } else {\n          throw e;\n        }\n      }\n      invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n      // 21. If result.[[Type]] is normal, then\n      if (result instanceof Value) {\n        // Evaluate expressions that passed for directives.\n        if (script.directives) {\n          for (let directive of script.directives) {\n            result = new StringValue(realm, directive.value.value);\n          }\n        }\n\n        // a. Let result be the result of evaluating body.\n        result = this.EvaluateStatements(script.body, result, strictEval, lexEnv, realm);\n      }\n\n      // 22. If result.[[Type]] is normal and result.[[Value]] is empty, then\n      if (result instanceof EmptyValue) {\n        // a. Let result be NormalCompletion(undefined).\n        result = realm.intrinsics.undefined;\n      }\n    } finally {\n      // 23. Suspend evalCxt and remove it from the execution context stack.\n      evalCxt.suspend();\n      realm.popContext(evalCxt);\n      realm.onDestroyScope(evalCxt.lexicalEnvironment);\n    }\n\n    // 24. Resume the context that is now on the top of the execution context stack as the running execution context.\n    invariant(realm.getRunningContext() === ctx);\n    ctx.resume();\n\n    // 25. Return Completion(result).\n    if (result instanceof Value) {\n      return result;\n    } else {\n      invariant(result instanceof AbruptCompletion);\n      throw result;\n    }\n  }\n\n  // If c is an abrupt completion and realm.savedCompletion is defined, the result is an instance of\n  // JoinedAbruptCompletions and the effects that have been captured since the PossiblyNormalCompletion instance\n  // in realm.savedCompletion has been created, becomes the effects of the branch that terminates in c.\n  // If c is a normal completion, the result is realm.savedCompletion, with its value updated to c.\n  // If c is undefined, the result is just realm.savedCompletion.\n  // Call this only when a join point has been reached.\n  incorporateSavedCompletion(realm: Realm, c: void | AbruptCompletion | Value): void | Completion | Value {\n    let savedCompletion = realm.savedCompletion;\n    if (savedCompletion !== undefined) {\n      if (savedCompletion.savedPathConditions) {\n        realm.pathConditions = savedCompletion.savedPathConditions;\n      }\n      realm.savedCompletion = undefined;\n      if (c === undefined) return savedCompletion;\n      if (c instanceof Value) {\n        Join.updatePossiblyNormalCompletionWithValue(realm, savedCompletion, c);\n        return savedCompletion;\n      } else {\n        let e = realm.getCapturedEffects(savedCompletion);\n        invariant(e !== undefined);\n        realm.stopEffectCaptureAndUndoEffects(savedCompletion);\n        let joined_effects = Join.joinPossiblyNormalCompletionWithAbruptCompletion(realm, savedCompletion, c, e);\n        realm.applyEffects(joined_effects);\n        let jc = joined_effects[0];\n        invariant(jc instanceof AbruptCompletion);\n        return jc;\n      }\n    }\n    return c;\n  }\n\n  EvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    initialBlockValue: void | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): Value {\n    let blockValue = initialBlockValue;\n    for (let node of body) {\n      if (node.type !== \"FunctionDeclaration\") {\n        let res = blockEnv.evaluateCompletionDeref(node, strictCode);\n        if (!(res instanceof EmptyValue)) {\n          if (res instanceof AbruptCompletion) throw UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty);\n          invariant(res instanceof Value);\n          blockValue = res;\n        }\n      }\n    }\n\n    // 7. Return blockValue.\n    return blockValue || realm.intrinsics.empty;\n  }\n\n  PartiallyEvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    blockValue: void | NormalCompletion | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): [Completion | Value, Array<BabelNodeStatement>] {\n    let statementAsts = [];\n    for (let node of body) {\n      if (node.type !== \"FunctionDeclaration\") {\n        let [res, nast, nio] = blockEnv.partiallyEvaluateCompletionDeref(node, strictCode);\n        for (let ioAst of nio) statementAsts.push(ioAst);\n        statementAsts.push((nast: any));\n        if (!(res instanceof EmptyValue)) {\n          if (blockValue === undefined || blockValue instanceof Value) {\n            if (res instanceof AbruptCompletion)\n              return [UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty), statementAsts];\n            invariant(res instanceof NormalCompletion || res instanceof Value);\n            blockValue = res;\n          }\n        }\n      }\n    }\n\n    // 7. Return blockValue.\n    return [blockValue || realm.intrinsics.empty, statementAsts];\n  }\n\n  // ECMA262 9.2.5\n  FunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"arrow\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean,\n    prototype?: ObjectValue\n  ): ECMAScriptSourceFunctionValue {\n    // 1. If the prototype argument was not passed, then\n    if (!prototype) {\n      // a. Let prototype be the intrinsic object %FunctionPrototype%.\n      prototype = realm.intrinsics.FunctionPrototype;\n    }\n\n    // 2. If kind is not Normal, let allocKind be \"non-constructor\".\n    let allocKind;\n    if (kind !== \"normal\") {\n      allocKind = \"non-constructor\";\n    } else {\n      // 3. Else, let allocKind be \"normal\".\n      allocKind = \"normal\";\n    }\n\n    // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).\n    let F = this.FunctionAllocate(realm, prototype, Strict, allocKind);\n\n    // ECMAScript 2016, section 17:\n    //   \"Every other data property described in clauses 18 through 26 and in Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified.\"\n    // Because we call `AddRestrictedFunctionProperties` on `FunctionPrototype`, accessing property \"arguments\" will raise a `TypeError` by default.\n    // However, in non-strict mode this behavior is not desired, so we will add them as own properties of each `FunctionValue`, in accordance with ECMA 17.\n    // Note: \"arguments\" ***MUST NOT*** be set if the function is in strict mode or is an arrow, method, constructor, or generator function.\n    //   See 16.2 \"Forbidden Extensions\"\n    if (!Strict && kind === \"normal\") {\n      Properties.DefinePropertyOrThrow(realm, F, \"arguments\", {\n        value: realm.intrinsics.undefined,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      });\n    }\n\n    // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n  }\n\n  // ECMA262 18.2.1.2\n  EvalDeclarationInstantiation(\n    realm: Realm,\n    body: BabelNodeBlockStatement,\n    varEnv: LexicalEnvironment,\n    lexEnv: LexicalEnvironment,\n    strict: boolean\n  ): Value {\n    // 1. Let varNames be the VarDeclaredNames of body.\n    let varNames = [];\n    traverseFast(body, node => {\n      if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 2. Let varDeclarations be the VarScopedDeclarations of body.\n    let varDeclarations = this.FindVarScopedDeclarations(body);\n\n    // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 4. Let varEnvRec be varEnv's EnvironmentRecord.\n    let varEnvRec = varEnv.environmentRecord;\n\n    // 5. If strict is false, then\n    if (!strict) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. For each name in varNames, do\n        for (let name of varNames) {\n          // 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n          if (varEnvRec.HasLexicalDeclaration(name)) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.SyntaxError,\n              new StringValue(realm, name + \" global object is restricted\")\n            );\n          }\n          // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.\n        }\n      }\n      // b. Let thisLex be lexEnv.\n      let thisLex = lexEnv;\n      // c. Assert: The following loop will terminate.\n      // d. Repeat while thisLex is not the same as varEnv,\n      while (thisLex !== varEnv) {\n        // i. Let thisEnvRec be thisLex's EnvironmentRecord.\n        let thisEnvRec = thisLex.environmentRecord;\n        // ii. If thisEnvRec is not an object Environment Record, then\n        if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {\n          // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n          // 2. For each name in varNames, do\n          for (let name of varNames) {\n            // a. If thisEnvRec.HasBinding(name) is true, then\n            if (thisEnvRec.HasBinding(name)) {\n              // i. Throw a SyntaxError exception.\n              throw realm.createErrorThrowCompletion(\n                realm.intrinsics.SyntaxError,\n                name + \" global object is restricted\"\n              );\n              // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.\n            }\n            // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n          }\n        }\n        // iii. Let thisLex be thisLex's outer environment reference.\n        thisLex = thisLex.parent;\n        invariant(thisLex !== null);\n      }\n    }\n\n    // 6. Let functionsToInitialize be a new empty List.\n    let functionsToInitialize = [];\n\n    // 7. Let declaredFunctionNames be a new empty List.\n    let declaredFunctionNames = [];\n\n    // 8. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n        // iii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iv. If fn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(fn) < 0) {\n          // 1. If varEnvRec is a global Environment Record, then\n          if (varEnvRec instanceof GlobalEnvironmentRecord) {\n            // a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).\n            let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn);\n            // b. If fnDefinable is false, throw a TypeError exception.\n            if (!fnDefinable) {\n              throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, fn + \" is not definable\");\n            }\n          }\n          // 2. Append fn to declaredFunctionNames.\n          declaredFunctionNames.push(fn);\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.\n\n    // 10. Let declaredVarNames be a new empty List.\n    let declaredVarNames = [];\n\n    // 11. For each d in varDeclarations, do\n    for (let d of varDeclarations) {\n      // a. If d is a VariableDeclaration or a ForBinding, then\n      if (d.type === \"VariableDeclaration\") {\n        // i. For each String vn in the BoundNames of d, do\n        for (let vn of Environment.BoundNames(realm, d)) {\n          // 1. If vn is not an element of declaredFunctionNames, then\n          if (declaredFunctionNames.indexOf(vn) < 0) {\n            // a. If varEnvRec is a global Environment Record, then\n            if (varEnvRec instanceof GlobalEnvironmentRecord) {\n              // i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).\n              let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn);\n              // ii. If vnDefinable is false, throw a TypeError exception.\n              if (!vnDefinable) {\n                throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, vn + \" is not definable\");\n              }\n            }\n            // b. If vn is not an element of declaredVarNames, then\n            if (declaredVarNames.indexOf(vn) < 0) {\n              // i. Append vn to declaredVarNames.\n              declaredVarNames.push(vn);\n            }\n          }\n        }\n      }\n    }\n\n    // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.\n\n    // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.\n    let lexDeclarations = [];\n    for (let s of body.body) {\n      if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n        lexDeclarations.push(s);\n      }\n    }\n\n    // 14. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // c. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // i. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // d. Else,\n          // i. Perform ? lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 15. For each production f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).\n        varEnvRec.CreateGlobalFunctionBinding(fn, fo, true);\n      } else {\n        // d. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(fn).\n        let bindingExists = varEnvRec.HasBinding(fn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).\n          varEnvRec.CreateMutableBinding(fn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(fn, fo).\n          varEnvRec.InitializeBinding(fn, fo);\n        } else {\n          // iii. Else,\n          // 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n          varEnvRec.SetMutableBinding(fn, fo, false);\n        }\n      }\n    }\n\n    // 16. For each String vn in declaredVarNames, in list order do\n    for (let vn of declaredVarNames) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).\n        varEnvRec.CreateGlobalVarBinding(vn, true);\n      } else {\n        // b. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(vn).\n        let bindingExists = varEnvRec.HasBinding(vn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).\n          varEnvRec.CreateMutableBinding(vn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).\n          varEnvRec.InitializeBinding(vn, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 17. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA 9.2.10\n  MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue): Value {\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an ECMAScript function object.\n    invariant(F instanceof ECMAScriptSourceFunctionValue, \"F is an ECMAScript function object.\");\n\n    // 2. Assert: Type(homeObject) is Object.\n    invariant(homeObject instanceof ObjectValue, \"Type(homeObject) is Object.\");\n\n    // 3. Set the [[HomeObject]] internal slot of F to homeObject.\n    F.$HomeObject = homeObject;\n\n    // 4. Return NormalCompletion(undefined).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA 14.3.8\n  DefineMethod(\n    realm: Realm,\n    prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n    obj: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    functionPrototype?: ObjectValue\n  ): { $Key: PropertyKeyValue, $Closure: ECMAScriptSourceFunctionValue } {\n    // 1. Let propKey be the result of evaluating PropertyName.\n    let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(propKey).\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    let strict = strictCode || IsStrict(prop.body);\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    let scope = env;\n\n    // 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method.\n    let kind;\n    if (functionPrototype) {\n      // let kind be Normal;\n      kind = \"normal\";\n    } else {\n      // otherwise let kind be Method.\n      kind = \"method\";\n    }\n\n    // 6. Let closure be FunctionCreate(kind, StrictFormalParameters, FunctionBody, scope, strict). If functionPrototype was passed as a parameter, then pass its value as the prototype optional argument of FunctionCreate.\n    let closure = this.FunctionCreate(realm, kind, prop.params, prop.body, scope, strict, functionPrototype);\n\n    // 7. Perform MakeMethod(closure, object).\n    this.MakeMethod(realm, closure, obj);\n\n    // 8. Return the Record{[[Key]]: propKey, [[Closure]]: closure}.\n    return { $Key: propKey, $Closure: closure };\n  }\n}\n"]}