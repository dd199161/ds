{"version":3,"sources":["../../src/serializer/ResidualFunctions.js"],"names":["t","ResidualFunctions","realm","statistics","options","modules","requireReturns","locationService","prelude","initializerNameGenerator","factoryNameGenerator","scopeNameGenerator","referentializedNameGenerator","residualFunctionInfos","residualFunctionInstances","residualClassMethodInstances","additionalFunctionValueInfos","additionalFunctionValueNestedFunctions","functionPrototypes","Map","firstFunctionUsages","functions","classes","functionInstances","residualFunctionInitializers","referentializer","values","instance","undefined","has","functionValue","addFunctionInstance","simpleClosures","push","code","$ECMAScriptCode","constructor","prototypeId","set","val","bodyReference","funcBody","instances","shouldInlineFunction","shouldInline","start","end","bodySize","functionInfo","get","usesArguments","length","rewrittenAdditionalFunctions","find","factoryFunctionInfos","functionBody","factoryId","suffix","__originalName","debugNames","_shouldUseFactoryFunction","_hasRewrittenFunctionInstance","identifier","generate","getLocation","functionUniqueTag","uniqueOrderedTag","functionEntries","sort","funcA","funcB","funcAUniqueTag","funcBUniqueTag","scrubFunctionInitializers","functionBodies","additionalFunctionPreludes","additionalFunctionModifiedBindingsSegment","getModifiedBindingsSegment","additionalFunction","getFunctionBody","globalPrelude","getPrelude","containingAdditionalFunction","b","requireStatistics","replaced","count","Array","from","entries","_sortFunctionByOriginalOrdering","unstrictFunctionBodies","strictFunctionBodies","funcNodes","referentialize","unbound","defineFunction","funcId","funcOrClassNode","initializationStatements","initializationBody","prototype","apply","body","isFunctionExpression","isCallExpression","isClassExpression","variableDeclaration","variableDeclarator","id","memberExpression","funcValue","funcInfo","modifiedBindings","residualBinding","scope","referentialized","bodySegment","decl","name","numericLiteral","init","getReferentializedScopeInitialization","newValue","additionalValueSerialized","binding_reference","serializedValue","isLVal","expressionStatement","assignmentExpression","additionalFunctionInfo","params","$FormalParameters","rewrittenBody","blockStatement","funcParams","slice","classMethodInstance","methodType","classMethodKeyNode","classSuperNode","classMethodComputed","classPrototype","classMethodIsStatic","isConstructor","isExpression","isIdentifier","_getOrCreateClassNode","classMethod","unshift","superClass","functionExpression","$Strict","_generateFactoryFunctionInfos","modified","usesThis","normalInstances","additionalFunctionNestedInstances","naiveProcessInstances","functionClones","instancesToSplice","residualFunctionBindings","scopeInstances","hasEmptyConstructor","$HasEmptyConstructor","methodParams","methodBody","cloneDeep","file","program","classExpression","classBody","isRequire","getIsRequire","scopeInitialization","scopeName","concat","factoryInfo","factoryNames","sameResidualBindings","isDifferent","lastBinding","firstBinding","factoryParams","key","factoryNode","factoryDeclaration","map","insertionPoint","functionId","hasFunctionArg","flatArgs","value","entry","funcNode","firstUsage","hasInitializerStatement","isNotEarlierThan","callArgs","thisExpression","flatArg","param","type","callee","childBody","returnStatement","callExpression","referentializationState","keys","referentializationScope","createCaptureScopeAccessFunction","createCapturedScopesArrayInitialization","reverse","splice","index","isReturnStatement","pop","initializerStatement","getInitializerStatement"],"mappings":"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","file":"ResidualFunctions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue, type ECMAScriptSourceFunctionValue, ObjectValue } from \"../values/index.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeSpreadElement,\n  BabelNodeFunctionExpression,\n  BabelNodeClassExpression,\n} from \"babel-types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { NameGenerator } from \"../utils/generator.js\";\nimport traverse from \"babel-traverse\";\nimport invariant from \"../invariant.js\";\nimport type { FunctionInfo, FactoryFunctionInfo, FunctionInstance, AdditionalFunctionInfo } from \"./types.js\";\nimport { BodyReference, AreSameResidualBinding, SerializerStatistics } from \"./types.js\";\nimport { ClosureRefReplacer } from \"./visitors.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualFunctionInitializers } from \"./ResidualFunctionInitializers.js\";\nimport { nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService, ClassMethodInstance } from \"./types.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport { getOrDefault } from \"./utils.js\";\n\ntype ResidualFunctionsResult = {\n  unstrictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeClassExpression>,\n  strictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeClassExpression>,\n  requireStatistics: { replaced: number, count: number },\n};\n\nexport class ResidualFunctions {\n  constructor(\n    realm: Realm,\n    statistics: SerializerStatistics,\n    options: SerializerOptions,\n    modules: Modules,\n    requireReturns: Map<number | string, BabelNodeExpression>,\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    initializerNameGenerator: NameGenerator,\n    factoryNameGenerator: NameGenerator,\n    scopeNameGenerator: NameGenerator,\n    referentializedNameGenerator: NameGenerator,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    additionalFunctionValueNestedFunctions: Set<FunctionValue>\n  ) {\n    this.realm = realm;\n    this.statistics = statistics;\n    this.modules = modules;\n    this.requireReturns = requireReturns;\n    this.locationService = locationService;\n    this.prelude = prelude;\n    this.factoryNameGenerator = factoryNameGenerator;\n    this.functionPrototypes = new Map();\n    this.firstFunctionUsages = new Map();\n    this.functions = new Map();\n    this.classes = new Map();\n    this.functionInstances = [];\n    this.residualFunctionInitializers = new ResidualFunctionInitializers(\n      locationService,\n      prelude,\n      initializerNameGenerator\n    );\n    this.residualFunctionInfos = residualFunctionInfos;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.referentializer = new Referentializer(options, scopeNameGenerator, referentializedNameGenerator, statistics);\n    for (let instance of residualFunctionInstances.values()) {\n      invariant(instance !== undefined);\n      if (!additionalFunctionValueInfos.has(instance.functionValue)) this.addFunctionInstance(instance);\n    }\n    this.additionalFunctionValueNestedFunctions = additionalFunctionValueNestedFunctions;\n    this.simpleClosures = !!options.simpleClosures;\n  }\n\n  realm: Realm;\n  modules: Modules;\n  statistics: SerializerStatistics;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  factoryNameGenerator: NameGenerator;\n  functionPrototypes: Map<FunctionValue, BabelNodeIdentifier>;\n  firstFunctionUsages: Map<FunctionValue, BodyReference>;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  classes: Map<ObjectValue, BabelNodeClassExpression>;\n  functionInstances: Array<FunctionInstance>;\n  residualFunctionInitializers: ResidualFunctionInitializers;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  referentializer: Referentializer;\n  simpleClosures: boolean;\n\n  addFunctionInstance(instance: FunctionInstance) {\n    this.functionInstances.push(instance);\n    let code = instance.functionValue.$ECMAScriptCode;\n    invariant(code != null);\n    getOrDefault(this.functions, code, () => []).push(instance);\n  }\n\n  setFunctionPrototype(constructor: FunctionValue, prototypeId: BabelNodeIdentifier) {\n    this.functionPrototypes.set(constructor, prototypeId);\n  }\n\n  addFunctionUsage(val: FunctionValue, bodyReference: BodyReference) {\n    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);\n  }\n\n  _shouldUseFactoryFunction(funcBody: BabelNodeBlockStatement, instances: Array<FunctionInstance>) {\n    function shouldInlineFunction(): boolean {\n      let shouldInline = true;\n      if (funcBody.start && funcBody.end) {\n        let bodySize = funcBody.end - funcBody.start;\n        shouldInline = bodySize <= 30;\n      }\n      return shouldInline;\n    }\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { usesArguments } = functionInfo;\n    return !shouldInlineFunction() && instances.length > 1 && !usesArguments && !this.simpleClosures;\n  }\n\n  // Note: this function takes linear time. Please do not call it inside loop.\n  _hasRewrittenFunctionInstance(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>,\n    instances: Array<FunctionInstance>\n  ): boolean {\n    return instances.find(instance => rewrittenAdditionalFunctions.has(instance.functionValue)) !== undefined;\n  }\n\n  _generateFactoryFunctionInfos(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): Map<number, FactoryFunctionInfo> {\n    const factoryFunctionInfos = new Map();\n    for (const [functionBody, instances] of this.functions) {\n      invariant(instances.length > 0);\n\n      let factoryId;\n      const suffix = instances[0].functionValue.__originalName || this.realm.debugNames ? \"factoryFunction\" : \"\";\n      if (this._shouldUseFactoryFunction(functionBody, instances)) {\n        // Rewritten function should never use factory function.\n        invariant(!this._hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances));\n        factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));\n      } else {\n        // For inline function body case, use the first function as the factory function.\n        factoryId = this.locationService.getLocation(instances[0].functionValue);\n      }\n\n      const functionUniqueTag = ((functionBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(functionUniqueTag);\n\n      const functionInfo = this.residualFunctionInfos.get(functionBody);\n      invariant(functionInfo);\n      factoryFunctionInfos.set(functionUniqueTag, { factoryId, functionInfo });\n    }\n    return factoryFunctionInfos;\n  }\n\n  // Preserve residual functions' ordering based on its ast dfs traversal order.\n  // This is necessary to prevent unexpected code locality issues.\n  _sortFunctionByOriginalOrdering(functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]>): void {\n    functionEntries.sort((funcA, funcB) => {\n      const funcAUniqueTag = ((funcA[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcAUniqueTag);\n\n      const funcBUniqueTag = ((funcB[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcBUniqueTag);\n      return funcAUniqueTag - funcBUniqueTag;\n    });\n  }\n\n  spliceFunctions(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): ResidualFunctionsResult {\n    this.residualFunctionInitializers.scrubFunctionInitializers();\n\n    let functionBodies = new Map();\n    // these need to get spliced in at the end\n    let additionalFunctionPreludes = new Map();\n    let additionalFunctionModifiedBindingsSegment: Map<FunctionValue, Array<BabelNodeStatement>> = new Map();\n    let getModifiedBindingsSegment = additionalFunction =>\n      getOrDefault(additionalFunctionModifiedBindingsSegment, additionalFunction, () => []);\n    let getFunctionBody = (instance: FunctionInstance): Array<BabelNodeStatement> =>\n      getOrDefault(functionBodies, instance, () => []);\n    let globalPrelude = this.prelude;\n    function getPrelude(instance: FunctionInstance): Array<BabelNodeStatement> {\n      let additionalFunction = instance.containingAdditionalFunction;\n      let b;\n      if (additionalFunction) {\n        b = getOrDefault(additionalFunctionPreludes, additionalFunction, () => []);\n      } else {\n        b = globalPrelude;\n      }\n      return b;\n    }\n\n    let requireStatistics = { replaced: 0, count: 0 };\n\n    let functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]> = Array.from(\n      this.functions.entries()\n    );\n    this._sortFunctionByOriginalOrdering(functionEntries);\n    this.statistics.functions = functionEntries.length;\n    let unstrictFunctionBodies = [];\n    let strictFunctionBodies = [];\n    let funcNodes: Map<FunctionValue, BabelNodeFunctionExpression> = new Map();\n\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      this.referentializer.referentialize(\n        functionInfo.unbound,\n        instances,\n        instance => !rewrittenAdditionalFunctions.has(instance.functionValue)\n      );\n    }\n\n    let defineFunction = (instance, funcId, funcOrClassNode) => {\n      let { functionValue } = instance;\n\n      if (instance.initializationStatements.length > 0) {\n        // always add initialization statements to insertion point\n        let initializationBody = getFunctionBody(instance);\n        Array.prototype.push.apply(initializationBody, instance.initializationStatements);\n      }\n\n      let body;\n      if (t.isFunctionExpression(funcOrClassNode)) {\n        funcNodes.set(functionValue, ((funcOrClassNode: any): BabelNodeFunctionExpression));\n        body = getPrelude(instance);\n      } else {\n        invariant(t.isCallExpression(funcOrClassNode) || t.isClassExpression(funcOrClassNode)); // .bind call\n        body = getFunctionBody(instance);\n      }\n      body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(funcId, funcOrClassNode)]));\n      let prototypeId = this.functionPrototypes.get(functionValue);\n      if (prototypeId !== undefined) {\n        let id = this.locationService.getLocation(functionValue);\n        invariant(id !== undefined);\n        body.push(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    // Emit code for ModifiedBindings for additional functions\n    for (let [funcValue, funcInfo] of this.additionalFunctionValueInfos) {\n      for (let [, residualBinding] of funcInfo.modifiedBindings) {\n        let scope = residualBinding.scope;\n\n        // TODO #989: This should probably be an invariant once captures work properly\n        // Currently we don't referentialize bindings in additional functions (but we\n        // do for bindings nested in additional functions)\n        if (!residualBinding.referentialized) continue;\n\n        // Find the proper prelude to emit to (global vs additional function's prelude)\n        let bodySegment = getModifiedBindingsSegment(funcValue);\n\n        // binding has been referentialized, so setup the scope to be able to\n        // access bindings from other __captured_scopes initializers\n        if (scope && scope.containingAdditionalFunction !== funcValue) {\n          let decl = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(t.identifier(scope.name), t.numericLiteral(scope.id)),\n          ]);\n          let init = this.referentializer.getReferentializedScopeInitialization(scope);\n          bodySegment.push(decl);\n          // flow forces me to do this\n          Array.prototype.push.apply(bodySegment, init);\n        }\n\n        let newValue = residualBinding.additionalValueSerialized;\n        invariant(newValue);\n        let binding_reference = ((residualBinding.serializedValue: any): BabelNodeLVal);\n        invariant(binding_reference);\n        invariant(t.isLVal(binding_reference), \"Referentialized values are always LVals\");\n        // This mutation is safe because it should always be either a global identifier (for global bindings)\n        // or an accessor to a referentialized value.\n        bodySegment.push(t.expressionStatement(t.assignmentExpression(\"=\", binding_reference, newValue)));\n      }\n    }\n\n    // Process Additional Functions\n    for (let [funcValue, additionalFunctionInfo] of this.additionalFunctionValueInfos.entries()) {\n      let { instance } = additionalFunctionInfo;\n      let functionValue = ((funcValue: any): ECMAScriptSourceFunctionValue);\n      let params = functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      let rewrittenBody = rewrittenAdditionalFunctions.get(funcValue);\n      invariant(rewrittenBody);\n\n      // rewritten functions shouldn't have references fixed up because the body,\n      // consists of serialized code. For simplicity we emit their instances in a naive way\n      let functionBody = t.blockStatement(rewrittenBody);\n      let funcParams = params.slice();\n      let funcOrClassNode;\n\n      if (this.residualClassMethodInstances.has(funcValue)) {\n        let classMethodInstance = this.residualClassMethodInstances.get(funcValue);\n        invariant(classMethodInstance);\n        let {\n          methodType,\n          classMethodKeyNode,\n          classSuperNode,\n          classMethodComputed,\n          classPrototype,\n          classMethodIsStatic,\n        } = classMethodInstance;\n\n        let isConstructor = methodType === \"constructor\";\n        invariant(classPrototype instanceof ObjectValue);\n        invariant(classMethodKeyNode && (t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode)));\n        // we use the classPrototype as the key to get the class expression ast node\n        funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n        let classMethod = t.classMethod(\n          methodType,\n          classMethodKeyNode,\n          funcParams,\n          functionBody,\n          classMethodComputed,\n          classMethodIsStatic\n        );\n        // add the class method to the class expression node body\n        if (isConstructor) {\n          funcOrClassNode.body.body.unshift(classMethod);\n        } else {\n          funcOrClassNode.body.body.push(classMethod);\n        }\n        // we only return the funcOrClassNode if this is the constructor\n        if (!isConstructor) {\n          continue;\n        }\n        // handle the class super\n        if (classSuperNode !== undefined) {\n          funcOrClassNode.superClass = classSuperNode;\n        }\n      } else {\n        funcOrClassNode = t.functionExpression(null, funcParams, functionBody);\n      }\n      let id = this.locationService.getLocation(funcValue);\n      invariant(id !== undefined);\n\n      if (funcValue.$Strict) {\n        strictFunctionBodies.push(funcOrClassNode);\n      } else {\n        unstrictFunctionBodies.push(funcOrClassNode);\n      }\n      defineFunction(instance, id, funcOrClassNode);\n    }\n\n    // Process normal functions\n    const factoryFunctionInfos = this._generateFactoryFunctionInfos(rewrittenAdditionalFunctions);\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      let { unbound, modified, usesThis } = functionInfo;\n      let params = instances[0].functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      // Split instances into normal or nested in an additional function\n      let normalInstances = [];\n      let additionalFunctionNestedInstances = [];\n      for (let instance of instances) {\n        if (this.additionalFunctionValueNestedFunctions.has(instance.functionValue))\n          additionalFunctionNestedInstances.push(instance);\n        else normalInstances.push(instance);\n      }\n\n      let naiveProcessInstances = instancesToSplice => {\n        this.statistics.functionClones += instancesToSplice.length - 1;\n\n        for (let instance of instancesToSplice) {\n          let { functionValue, residualFunctionBindings, scopeInstances } = instance;\n          let funcOrClassNode;\n\n          if (this.residualClassMethodInstances.has(functionValue)) {\n            let classMethodInstance = this.residualClassMethodInstances.get(functionValue);\n            invariant(classMethodInstance);\n            let {\n              classSuperNode,\n              classMethodKeyNode,\n              methodType,\n              classMethodComputed,\n              classPrototype,\n              classMethodIsStatic,\n            } = classMethodInstance;\n\n            let isConstructor = methodType === \"constructor\";\n            invariant(classPrototype instanceof ObjectValue);\n            invariant(classMethodKeyNode);\n            invariant(t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode));\n            // we use the classPrototype as the key to get the class expression ast node\n            funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n            // if we are dealing with a constructor, don't serialize it if the original\n            // had an empty user-land constructor (because we create a constructor behind the scenes for them)\n            let hasEmptyConstructor = !!functionValue.$HasEmptyConstructor;\n            if (!isConstructor || (isConstructor && !hasEmptyConstructor)) {\n              let methodParams = params.slice();\n              let methodBody = ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement);\n              // create the class method AST\n              let classMethod = t.classMethod(\n                methodType,\n                classMethodKeyNode,\n                methodParams,\n                methodBody,\n                classMethodComputed,\n                classMethodIsStatic\n              );\n              // traverse and replace refs in the class method\n              traverse(\n                t.file(\n                  t.program([t.expressionStatement(t.classExpression(null, null, t.classBody([classMethod]), []))])\n                ),\n                ClosureRefReplacer,\n                null,\n                {\n                  residualFunctionBindings,\n                  modified,\n                  requireReturns: this.requireReturns,\n                  requireStatistics,\n                  isRequire: this.modules.getIsRequire(methodParams, [functionValue]),\n                  factoryFunctionInfos,\n                }\n              );\n              // add the class method to the class expression node body\n              if (isConstructor) {\n                funcOrClassNode.body.body.unshift(classMethod);\n              } else {\n                funcOrClassNode.body.body.push(classMethod);\n              }\n            }\n            // we only return the funcOrClassNode if this is the constructor\n            if (!isConstructor) {\n              continue;\n            }\n            // handle the class super\n            if (classSuperNode !== undefined) {\n              funcOrClassNode.superClass = classSuperNode;\n            }\n          } else {\n            let funcParams = params.slice();\n            funcOrClassNode = t.functionExpression(\n              null,\n              funcParams,\n              ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n            );\n            let scopeInitialization = [];\n            for (let [scopeName, scope] of scopeInstances) {\n              scopeInitialization.push(\n                t.variableDeclaration(\"var\", [\n                  t.variableDeclarator(t.identifier(scopeName), t.numericLiteral(scope.id)),\n                ])\n              );\n              scopeInitialization = scopeInitialization.concat(\n                this.referentializer.getReferentializedScopeInitialization(scope)\n              );\n            }\n            funcOrClassNode.body.body = scopeInitialization.concat(funcOrClassNode.body.body);\n\n            traverse(t.file(t.program([t.expressionStatement(funcOrClassNode)])), ClosureRefReplacer, null, {\n              residualFunctionBindings,\n              modified,\n              requireReturns: this.requireReturns,\n              requireStatistics,\n              isRequire: this.modules.getIsRequire(funcParams, [functionValue]),\n              factoryFunctionInfos,\n            });\n          }\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n\n          if (functionValue.$Strict) {\n            strictFunctionBodies.push(funcOrClassNode);\n          } else {\n            unstrictFunctionBodies.push(funcOrClassNode);\n          }\n          invariant(id !== undefined);\n          invariant(funcOrClassNode !== undefined);\n          defineFunction(instance, id, funcOrClassNode);\n        }\n      };\n\n      if (additionalFunctionNestedInstances.length > 0) naiveProcessInstances(additionalFunctionNestedInstances);\n      if (!this._shouldUseFactoryFunction(funcBody, normalInstances)) {\n        naiveProcessInstances(normalInstances);\n      } else if (normalInstances.length > 0) {\n        const functionUniqueTag = ((funcBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n        invariant(functionUniqueTag);\n        const factoryInfo = factoryFunctionInfos.get(functionUniqueTag);\n        invariant(factoryInfo);\n        const { factoryId } = factoryInfo;\n\n        // filter included variables to only include those that are different\n        let factoryNames: Array<string> = [];\n        let sameResidualBindings = new Map();\n        for (let name of unbound) {\n          let isDifferent = false;\n          let lastBinding;\n\n          let firstBinding = normalInstances[0].residualFunctionBindings.get(name);\n          invariant(firstBinding);\n          if (firstBinding.modified) {\n            // Must modify for traversal\n            sameResidualBindings.set(name, firstBinding);\n            continue;\n          }\n\n          for (let { residualFunctionBindings } of normalInstances) {\n            let residualBinding = residualFunctionBindings.get(name);\n\n            invariant(residualBinding);\n            invariant(!residualBinding.modified);\n            if (!lastBinding) {\n              lastBinding = residualBinding;\n            } else if (!AreSameResidualBinding(this.realm, residualBinding, lastBinding)) {\n              isDifferent = true;\n              break;\n            }\n          }\n\n          if (isDifferent) {\n            factoryNames.push(name);\n          } else {\n            invariant(lastBinding);\n            sameResidualBindings.set(name, lastBinding);\n          }\n        }\n\n        let factoryParams: Array<BabelNodeLVal> = [];\n        for (let key of factoryNames) {\n          factoryParams.push(t.identifier(key));\n        }\n\n        let scopeInitialization = [];\n        for (let [scopeName, scope] of normalInstances[0].scopeInstances) {\n          factoryParams.push(t.identifier(scopeName));\n          scopeInitialization = scopeInitialization.concat(\n            this.referentializer.getReferentializedScopeInitialization(scope)\n          );\n        }\n\n        factoryParams = factoryParams.concat(params).slice();\n\n        // The Replacer below mutates the AST while the original AST may still be referenced\n        // by another outer residual function so let's clone the original AST to avoid modifying it.\n        let factoryNode = t.functionExpression(\n          null,\n          factoryParams,\n          ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n        );\n\n        if (normalInstances[0].functionValue.$Strict) {\n          strictFunctionBodies.push(factoryNode);\n        } else {\n          unstrictFunctionBodies.push(factoryNode);\n        }\n\n        factoryNode.body.body = scopeInitialization.concat(factoryNode.body.body);\n\n        // factory functions do not depend on any nested generator scope, so they go to the prelude\n        let factoryDeclaration = t.variableDeclaration(\"var\", [t.variableDeclarator(factoryId, factoryNode)]);\n        this.prelude.push(factoryDeclaration);\n\n        traverse(t.file(t.program([t.expressionStatement(factoryNode)])), ClosureRefReplacer, null, {\n          residualFunctionBindings: sameResidualBindings,\n          modified,\n          requireReturns: this.requireReturns,\n          requireStatistics,\n          isRequire: this.modules.getIsRequire(factoryParams, normalInstances.map(instance => instance.functionValue)),\n          factoryFunctionInfos,\n        });\n\n        for (let instance of normalInstances) {\n          let { functionValue, residualFunctionBindings, insertionPoint } = instance;\n          let functionId = this.locationService.getLocation(functionValue);\n          invariant(functionId !== undefined);\n          let hasFunctionArg = false;\n          let flatArgs: Array<BabelNodeExpression> = factoryNames.map(name => {\n            let residualBinding = residualFunctionBindings.get(name);\n            invariant(residualBinding);\n            let serializedValue = residualBinding.serializedValue;\n            hasFunctionArg =\n              hasFunctionArg || (residualBinding.value && residualBinding.value instanceof FunctionValue);\n            invariant(serializedValue);\n            return serializedValue;\n          });\n          for (let entry of instance.scopeInstances) {\n            flatArgs.push(t.numericLiteral(entry[1].id));\n          }\n          let funcNode;\n          let firstUsage = this.firstFunctionUsages.get(functionValue);\n          invariant(insertionPoint !== undefined);\n          if (\n            // The same free variables in shared instances may refer to objects with different initialization values\n            // so a stub forward function is needed during delay initializations.\n            this.residualFunctionInitializers.hasInitializerStatement(functionValue) ||\n            usesThis ||\n            hasFunctionArg ||\n            (firstUsage !== undefined && !firstUsage.isNotEarlierThan(insertionPoint)) ||\n            this.functionPrototypes.get(functionValue) !== undefined ||\n            this.simpleClosures\n          ) {\n            let callArgs: Array<BabelNodeExpression | BabelNodeSpreadElement> = [t.thisExpression()];\n            for (let flatArg of flatArgs) callArgs.push(flatArg);\n            for (let param of params) {\n              if (param.type !== \"Identifier\") {\n                throw new FatalError(\"TODO: do not know how to deal with non-Identifier parameters\");\n              }\n              callArgs.push(((param: any): BabelNodeIdentifier));\n            }\n\n            let callee = t.memberExpression(factoryId, t.identifier(\"call\"));\n\n            let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);\n\n            funcNode = t.functionExpression(null, params, childBody);\n            if (functionValue.$Strict) {\n              strictFunctionBodies.push(funcNode);\n            } else {\n              unstrictFunctionBodies.push(funcNode);\n            }\n          } else {\n            funcNode = t.callExpression(\n              t.memberExpression(factoryId, t.identifier(\"bind\")),\n              [nullExpression].concat(flatArgs)\n            );\n          }\n\n          defineFunction(instance, functionId, funcNode);\n        }\n      }\n    }\n\n    for (let referentializationScope of this.referentializer.referentializationState.keys()) {\n      let prelude = this.prelude;\n      // Get the prelude for this additional function value\n      if (referentializationScope !== \"GLOBAL\") {\n        let additionalFunction = referentializationScope;\n        prelude = getOrDefault(additionalFunctionPreludes, additionalFunction, () => []);\n      }\n      prelude.unshift(this.referentializer.createCaptureScopeAccessFunction(referentializationScope));\n      prelude.unshift(this.referentializer.createCapturedScopesArrayInitialization(referentializationScope));\n    }\n\n    for (let instance of this.functionInstances.reverse()) {\n      let functionBody = functionBodies.get(instance);\n      if (functionBody !== undefined) {\n        let insertionPoint = instance.insertionPoint;\n        invariant(insertionPoint instanceof BodyReference);\n        // v8 seems to do something clever with array splicing, so this potentially\n        // expensive operations seems to be actually cheap.\n        Array.prototype.splice.apply(\n          insertionPoint.body.entries,\n          ([insertionPoint.index, 0]: Array<any>).concat((functionBody: Array<any>))\n        );\n      }\n    }\n\n    for (let [additionalFunction, body] of rewrittenAdditionalFunctions.entries()) {\n      let bodySegment = additionalFunctionModifiedBindingsSegment.get(additionalFunction);\n      let prelude = additionalFunctionPreludes.get(additionalFunction);\n      if (prelude) body.unshift(...prelude);\n      if (bodySegment) {\n        if (body.length > 0 && t.isReturnStatement(body[body.length - 1])) {\n          let returnStatement = body.pop();\n          body.push(...bodySegment, returnStatement);\n        } else {\n          body.push(...bodySegment);\n        }\n      }\n    }\n\n    // Inject initializer code for indexed vars into functions (for delay initializations)\n    for (let [functionValue, funcNode] of funcNodes) {\n      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);\n      if (initializerStatement !== undefined) {\n        invariant(t.isFunctionExpression(funcNode));\n        let blockStatement: BabelNodeBlockStatement = ((funcNode: any): BabelNodeFunctionExpression).body;\n        blockStatement.body.unshift(initializerStatement);\n      }\n    }\n\n    return { unstrictFunctionBodies, strictFunctionBodies, requireStatistics };\n  }\n  _getOrCreateClassNode(classPrototype: ObjectValue): BabelNodeClassExpression {\n    if (!this.classes.has(classPrototype)) {\n      let funcOrClassNode = t.classExpression(null, null, t.classBody([]), []);\n      this.classes.set(classPrototype, funcOrClassNode);\n      return funcOrClassNode;\n    } else {\n      let funcOrClassNode = this.classes.get(classPrototype);\n      invariant(funcOrClassNode && t.isClassExpression(funcOrClassNode));\n      return funcOrClassNode;\n    }\n  }\n}\n"]}