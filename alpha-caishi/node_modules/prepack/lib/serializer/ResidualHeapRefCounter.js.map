{"version":3,"sources":["../../src/serializer/ResidualHeapRefCounter.js"],"names":["ResidualHeapRefCounter","realm","logger","modules","additionalFunctionValuesAndEffects","_valueToEdgeRecord","Map","_path","val","isIntrinsic","isLeaf","_shouldIgnore","length","_updateParentOutgoingEdgeCount","push","_updateValueIncomingEdgeCount","parent","edgeRecord","get","outGoing","undefined","set","inComing","pop"],"mappings":";;;;;;;;;;;AAgBA;;;;AACA;;AACA;;AACA;;;;;;;;+eAnBA;;;;;;;;;AAqBA;;;IAGaA,sB,WAAAA,sB;;;AACX,kCACEC,KADF,EAEEC,MAFF,EAGEC,OAHF,EAIEC,kCAJF,EAKE;AAAA;;AAAA,gJACMH,KADN,EACaC,MADb,EACqBC,OADrB,EAC8BC,kCAD9B;;AAEA,UAAKC,kBAAL,GAA0B,IAAIC,GAAJ,EAA1B;AACA,UAAKC,KAAL,GAAa,EAAb;AAHA;AAID;;;;AAGoB;;gCAEmB;AACtC,aAAO,KAAKF,kBAAZ;AACD;;;kCAEaG,G,EAAqB;AACjC,aAAOA,oCAA6BA,IAAIC,WAAJ,EAA7B,IAAkD,6CAAsBC,MAAtB,CAA6BF,GAA7B,CAAzD;AACD;;;oCAEeA,G,EAAqB;AACnC,UAAI,KAAKG,aAAL,CAAmBH,GAAnB,CAAJ,EAA6B;AAC3B,eAAO,KAAP;AACD;;AAED,UAAI,KAAKD,KAAL,CAAWK,MAAX,GAAoB,CAAxB,EAA2B;AACzB,aAAKC,8BAAL;AACD;AACD,WAAKN,KAAL,CAAWO,IAAX,CAAgBN,GAAhB;;AAEA,aAAO,KAAKO,6BAAL,CAAmCP,GAAnC,CAAP;AACD;;;qDAEgC;AAC/B,UAAMQ,SAAS,KAAKT,KAAL,CAAW,KAAKA,KAAL,CAAWK,MAAX,GAAoB,CAA/B,CAAf;AACA,UAAMK,aAAa,KAAKZ,kBAAL,CAAwBa,GAAxB,CAA4BF,MAA5B,CAAnB;AACA,+BAAUC,UAAV;AACA,QAAEA,WAAWE,QAAb;AACD;;;kDAE6BX,G,EAAqB;AACjD,UAAIS,aAAa,KAAKZ,kBAAL,CAAwBa,GAAxB,CAA4BV,GAA5B,CAAjB;AACA,UAAIS,eAAeG,SAAnB,EAA8B;AAC5B,aAAKf,kBAAL,CAAwBgB,GAAxB,CAA4Bb,GAA5B,EAAiC;AAC/Bc,oBAAU,CADqB;AAE/BH,oBAAU;AAFqB,SAAjC;AAIA,eAAO,IAAP;AACD,OAND,MAMO;AACL,UAAEF,WAAWK,QAAb;AACA,eAAO,KAAP,CAFK,CAES;AACf;AACF;;AAED;;;;qCACiBd,G,EAAY;AAC3B,UAAI,KAAKG,aAAL,CAAmBH,GAAnB,CAAJ,EAA6B;AAC3B;AACD;AACD,+BAAU,KAAKD,KAAL,CAAWK,MAAX,GAAoB,CAA9B;AACA,WAAKL,KAAL,CAAWgB,GAAX;AACD;;AAED;;;;iCACmB;AACjB;AACA,+BAAU,KAAKhB,KAAL,CAAWK,MAAX,KAAsB,CAAhC,EAAmC,gDAAnC;AACD","file":"ResidualHeapRefCounter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Logger } from \"../utils/logger.js\";\nimport type { Modules } from \"../utils/modules.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ObjectRefCount, AdditionalFunctionEffects } from \"./types.js\";\n\nimport invariant from \"../invariant.js\";\nimport { Value, EmptyValue, FunctionValue } from \"../values/index.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { ResidualHeapVisitor } from \"./ResidualHeapVisitor.js\";\n\n/**\n * Record residual heap object's incoming and outgoing reference counts.\n */\nexport class ResidualHeapRefCounter extends ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>\n  ) {\n    super(realm, logger, modules, additionalFunctionValuesAndEffects);\n    this._valueToEdgeRecord = new Map();\n    this._path = [];\n  }\n\n  _valueToEdgeRecord: Map<Value, ObjectRefCount>;\n  _path: Array<Value>; // Contains the path of nodes from root to current visiting node.\n\n  getResult(): Map<Value, ObjectRefCount> {\n    return this._valueToEdgeRecord;\n  }\n\n  _shouldIgnore(val: Value): boolean {\n    return val instanceof EmptyValue || val.isIntrinsic() || ResidualHeapInspector.isLeaf(val);\n  }\n\n  preProcessValue(val: Value): boolean {\n    if (this._shouldIgnore(val)) {\n      return false;\n    }\n\n    if (this._path.length > 0) {\n      this._updateParentOutgoingEdgeCount();\n    }\n    this._path.push(val);\n\n    return this._updateValueIncomingEdgeCount(val);\n  }\n\n  _updateParentOutgoingEdgeCount() {\n    const parent = this._path[this._path.length - 1];\n    const edgeRecord = this._valueToEdgeRecord.get(parent);\n    invariant(edgeRecord);\n    ++edgeRecord.outGoing;\n  }\n\n  _updateValueIncomingEdgeCount(val: Value): boolean {\n    let edgeRecord = this._valueToEdgeRecord.get(val);\n    if (edgeRecord === undefined) {\n      this._valueToEdgeRecord.set(val, {\n        inComing: 1,\n        outGoing: 0,\n      });\n      return true;\n    } else {\n      ++edgeRecord.inComing;\n      return false; // visited node, skip its children.\n    }\n  }\n\n  // Override.\n  postProcessValue(val: Value) {\n    if (this._shouldIgnore(val)) {\n      return;\n    }\n    invariant(this._path.length > 0);\n    this._path.pop();\n  }\n\n  // Override.\n  visitRoots(): void {\n    super.visitRoots();\n    invariant(this._path.length === 0, \"Path should be balanced empty after traversal.\");\n  }\n}\n"]}