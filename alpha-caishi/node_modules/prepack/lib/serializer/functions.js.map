{"version":3,"sources":["../../src/serializer/functions.js"],"names":["t","Functions","realm","functions","moduleTracer","writeEffects","Map","functionExpressions","calls","fname","fun","fnameAst","expression","e","evaluateNodeForEffectsInGlobalEnv","undefined","ex","error","handleError","set","call","callExpression","push","globalKey","recordedAdditionalFunctions","globalRecordedAdditionalFunctionsMap","modules","logger","tryQuery","$GlobalObject","intrinsics","getOwnPropertyKeysArray","funcId","property","properties","get","funcValue","descriptor","value","effects","transforms","statistics","react","recordedReactRootComponents","__generateAdditionalFunctions","componentType","simpleClassComponents","Set","reconciler","render","output","additionalFunctionEffects","_createAdditionalEffects","has","prototype","renderMethod","memberExpression","identifier","_generateAdditionalFunctionCallsFromInput","concat","_generateAdditionalFunctionCallsFromDirective","evaluatePure","getName","conflicts","fun1","call1","funcLength","getLength","e1","fun1Name","intrinsicName","location","call2","reportWriteConflicts","size","values","diagnostic","pbs","reportConflict","writtenObjects","forEach","val","key","m","add","object","oldReportObjectGetOwnProperties","reportObjectGetOwnProperties","ob","currentLocation","oldReportPropertyAccess","reportPropertyAccess","pb"],"mappings":"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","file":"functions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeCallExpression, BabelNodeSourceLocation } from \"babel-types\";\nimport { Completion, ThrowCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport { type Effects, type PropertyBindings, Realm } from \"../realm.js\";\nimport type { AdditionalFunctionEffects } from \"./types.js\";\nimport type { PropertyBinding } from \"../types.js\";\nimport { ignoreErrorsIn } from \"../utils/errors.js\";\nimport {\n  Value,\n  AbstractObjectValue,\n  FunctionValue,\n  ObjectValue,\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport { ModuleTracer } from \"../utils/modules.js\";\nimport buildTemplate from \"babel-template\";\nimport { ReactStatistics, type ReactSerializerState } from \"./types\";\nimport { Reconciler } from \"../react/reconcilation.js\";\nimport {\n  valueIsClassComponent,\n  convertSimpleClassComponentToFunctionalComponent,\n  normalizeFunctionalComponentParamaters,\n} from \"../react/utils.js\";\nimport * as t from \"babel-types\";\n\nexport class Functions {\n  constructor(realm: Realm, functions: ?Array<string>, moduleTracer: ModuleTracer) {\n    this.realm = realm;\n    this.functions = functions;\n    this.moduleTracer = moduleTracer;\n    this.writeEffects = new Map();\n    this.functionExpressions = new Map();\n  }\n\n  realm: Realm;\n  functions: ?Array<string>;\n  // maps back from FunctionValue to the expression string\n  functionExpressions: Map<FunctionValue, string>;\n  moduleTracer: ModuleTracer;\n  writeEffects: Map<FunctionValue, AdditionalFunctionEffects>;\n\n  _generateAdditionalFunctionCallsFromInput(): Array<[FunctionValue, BabelNodeCallExpression]> {\n    // lookup functions\n    let calls = [];\n    for (let fname of this.functions || []) {\n      let fun;\n      let fnameAst = buildTemplate(fname)({}).expression;\n      if (fnameAst) {\n        try {\n          let e = ignoreErrorsIn(this.realm, () => this.realm.evaluateNodeForEffectsInGlobalEnv(fnameAst));\n          fun = e ? e[0] : undefined;\n        } catch (ex) {\n          if (!(ex instanceof ThrowCompletion)) throw ex;\n        }\n      }\n      if (!(fun instanceof FunctionValue)) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fname} not defined in the global environment`,\n          null,\n          \"PP1001\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      this.functionExpressions.set(fun, fname);\n      let call = t.callExpression(fnameAst, []);\n      calls.push([fun, call]);\n    }\n    return calls;\n  }\n\n  __generateAdditionalFunctions(globalKey: string) {\n    let recordedAdditionalFunctions: Map<FunctionValue, string> = new Map();\n    let realm = this.realm;\n    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(realm, realm.$GlobalObject, globalKey),\n      realm.intrinsics.undefined,\n      false\n    );\n    invariant(globalRecordedAdditionalFunctionsMap instanceof ObjectValue);\n    for (let funcId of globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray()) {\n      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);\n      if (property) {\n        let funcValue = property.descriptor && property.descriptor.value;\n        if (!(funcValue instanceof FunctionValue)) {\n          invariant(funcValue instanceof AbstractValue);\n          realm.handleError(\n            new CompilerDiagnostic(\n              `Additional Function Value ${funcId} is an AbstractValue which is not allowed`,\n              undefined,\n              \"PP0001\",\n              \"FatalError\"\n            )\n          );\n          throw new FatalError(\"Additional Function values cannot be AbstractValues\");\n        }\n        recordedAdditionalFunctions.set(funcValue, funcId);\n      }\n    }\n    return recordedAdditionalFunctions;\n  }\n\n  _createAdditionalEffects(effects: Effects): AdditionalFunctionEffects {\n    return {\n      effects,\n      transforms: [],\n    };\n  }\n\n  checkReactRootComponents(statistics: ReactStatistics, react: ReactSerializerState): void {\n    let recordedReactRootComponents = this.__generateAdditionalFunctions(\"__reactComponentRoots\");\n\n    // Get write effects of the components\n    for (let [componentType] of recordedReactRootComponents) {\n      let simpleClassComponents = new Set();\n      let reconciler = new Reconciler(this.realm, this.moduleTracer, statistics, react, simpleClassComponents);\n      invariant(\n        componentType instanceof ECMAScriptSourceFunctionValue,\n        \"only ECMAScriptSourceFunctionValue function values are supported as React root components\"\n      );\n      let effects = reconciler.render(componentType, this.moduleTracer.modules.logger);\n\n      if (this.realm.react.output === \"bytecode\") {\n        throw new FatalError(\"TODO: implement React bytecode output format\");\n      } else {\n        let additionalFunctionEffects = this._createAdditionalEffects(effects);\n        invariant(effects[0] instanceof Value);\n        if (simpleClassComponents.has(effects[0])) {\n          // if the root component was a class and is now simple, we can convert it from a class\n          // component to a functional component\n          convertSimpleClassComponentToFunctionalComponent(this.realm, componentType, additionalFunctionEffects);\n          normalizeFunctionalComponentParamaters(componentType);\n          this.writeEffects.set(componentType, additionalFunctionEffects);\n        } else if (valueIsClassComponent(this.realm, componentType)) {\n          let prototype = Get(this.realm, componentType, \"prototype\");\n          invariant(prototype instanceof ObjectValue);\n          let renderMethod = Get(this.realm, prototype, \"render\");\n          invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n          this.writeEffects.set(renderMethod, additionalFunctionEffects);\n        } else {\n          normalizeFunctionalComponentParamaters(componentType);\n          this.writeEffects.set(componentType, additionalFunctionEffects);\n        }\n      }\n    }\n  }\n\n  _generateAdditionalFunctionCallsFromDirective(): Array<[FunctionValue, BabelNodeCallExpression]> {\n    let recordedAdditionalFunctions = this.__generateAdditionalFunctions(\"__additionalFunctions\");\n\n    // The additional functions we registered at runtime are recorded at:\n    // global.__additionalFunctions.id\n    let calls = [];\n    for (let [funcValue, funcId] of recordedAdditionalFunctions) {\n      // TODO #987: Make Additional Functions work with arguments\n      calls.push([\n        funcValue,\n        t.callExpression(\n          t.memberExpression(\n            t.memberExpression(t.identifier(\"global\"), t.identifier(\"__additionalFunctions\")),\n            t.identifier(funcId)\n          ),\n          []\n        ),\n      ]);\n    }\n    return calls;\n  }\n\n  checkThatFunctionsAreIndependent() {\n    let calls = this._generateAdditionalFunctionCallsFromInput().concat(\n      this._generateAdditionalFunctionCallsFromDirective()\n    );\n\n    // Get write effects of the functions\n    for (let [funcValue, call] of calls) {\n      // This may throw a FatalError if there is an unrecoverable error in the called function\n      // When that happens we cannot prepack the bundle.\n      // There may also be warnings reported for errors that happen inside imported modules that can be postponed.\n\n      let effects = this.realm.evaluatePure(() =>\n        this.realm.evaluateNodeForEffectsInGlobalEnv(\n          call,\n          this.moduleTracer,\n          `additional function(${funcValue.getName()})`\n        )\n      );\n      let additionalFunctionEffects = this._createAdditionalEffects(effects);\n      this.writeEffects.set(funcValue, additionalFunctionEffects);\n    }\n\n    // check that functions are independent\n    let conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic> = new Map();\n    for (let [fun1, call1] of calls) {\n      // Also do argument validation here\n      let funcLength = fun1.getLength();\n      if (funcLength && funcLength > 0) {\n        // TODO #987: Make Additional Functions work with arguments\n        throw new FatalError(\"TODO: implement arguments to additional functions\");\n      }\n      let additionalFunctionEffects = this.writeEffects.get(fun1);\n      invariant(additionalFunctionEffects !== undefined);\n      let e1 = additionalFunctionEffects.effects;\n      invariant(e1 !== undefined);\n      let fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || \"unknown\";\n      if (e1[0] instanceof Completion) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fun1Name} may terminate abruptly`,\n          e1[0].location,\n          \"PP1002\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      for (let [, call2] of calls) {\n        if (call1 === call2) continue;\n        this.reportWriteConflicts(fun1Name, conflicts, e1[3], call1, call2);\n      }\n    }\n    if (conflicts.size > 0) {\n      for (let diagnostic of conflicts.values()) this.realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n  }\n\n  getAdditionalFunctionValuesToEffects(): Map<FunctionValue, AdditionalFunctionEffects> {\n    return this.writeEffects;\n  }\n\n  reportWriteConflicts(\n    fname: string,\n    conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic>,\n    pbs: PropertyBindings,\n    call1: BabelNodeCallExpression,\n    call2: BabelNodeCallExpression\n  ) {\n    let reportConflict = (location: BabelNodeSourceLocation) => {\n      let error = new CompilerDiagnostic(\n        `Property access conflicts with write in additional function ${fname}`,\n        location,\n        \"PP1003\",\n        \"FatalError\"\n      );\n      conflicts.set(location, error);\n    };\n    let writtenObjects: Set<ObjectValue | AbstractObjectValue> = new Set();\n    pbs.forEach((val, key, m) => {\n      writtenObjects.add(key.object);\n    });\n    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;\n    this.realm.reportObjectGetOwnProperties = (ob: ObjectValue) => {\n      let location = this.realm.currentLocation;\n      invariant(location);\n      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);\n    };\n    let oldReportPropertyAccess = this.realm.reportPropertyAccess;\n    this.realm.reportPropertyAccess = (pb: PropertyBinding) => {\n      let location = this.realm.currentLocation;\n      if (!location) return; // happens only when accessing an additional function property\n      if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);\n    };\n    try {\n      ignoreErrorsIn(this.realm, () => this.realm.evaluateNodeForEffectsInGlobalEnv(call2, this.moduleTracer));\n    } finally {\n      this.realm.reportPropertyAccess = oldReportPropertyAccess;\n      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;\n    }\n  }\n}\n"]}