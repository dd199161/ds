{"version":3,"sources":["../../src/serializer/ResidualHeapValueIdentifiers.js"],"names":["t","ResidualHeapValueIdentifiers","values","preludeGenerator","collectValToRefCountOnly","_valueNameGenerator","createNameGenerator","_populateIdentifierMap","valToRefCount","Map","refs","val","_setIdentifier","_createNewIdentifier","name","generate","__originalName","identifier","id","has","set","get","undefined","delete","incrementReferenceCount","refCount"],"mappings":";;;;;;;qjBAAA;;;;;;;;;AAWA;;AAEA;;;;AAEA;;IAAYA,C;;;;;;;;AAEZ;AACA;AACA;AACA;AACA;IACaC,4B,WAAAA,4B;AACX,wCAAYC,MAAZ,EAAqCC,gBAArC,EAAyE;AAAA;;AACvE,SAAKC,wBAAL,GAAgC,KAAhC;AACA,SAAKC,mBAAL,GAA2BF,iBAAiBG,mBAAjB,CAAqC,GAArC,CAA3B;AACA,SAAKC,sBAAL,CAA4BL,MAA5B;AACD;;;;gCAEW;AACV,WAAKE,wBAAL,GAAgC,IAAhC;AACA,WAAKI,aAAL,GAAqB,IAAIC,GAAJ,EAArB;AACD;;;gCAEW;AACV,WAAKL,wBAAL,GAAgC,KAAhC;AACD;;;2CAOsBF,M,EAAyB;AAC9C,WAAKQ,IAAL,GAAY,IAAID,GAAJ,EAAZ;AAD8C;AAAA;AAAA;;AAAA;AAE9C,6BAAkBP,MAAlB,8HAA0B;AAAA,cAAfS,GAAe;;AACxB,eAAKC,cAAL,CAAoBD,GAApB,EAAyB,KAAKE,oBAAL,CAA0BF,GAA1B,CAAzB;AACD;AAJ6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAK/C;;;yCAEoBA,G,EAAiC;AACpD,UAAMG,OAAO,KAAKT,mBAAL,CAAyBU,QAAzB,CAAkCJ,IAAIK,cAAJ,IAAsB,EAAxD,CAAb;AACA,aAAOhB,EAAEiB,UAAF,CAAaH,IAAb,CAAP;AACD;;;mCAEcH,G,EAAYO,E,EAAyB;AAClD,+BAAU,CAAC,KAAKR,IAAL,CAAUS,GAAV,CAAcR,GAAd,CAAX;AACA,WAAKD,IAAL,CAAUU,GAAV,CAAcT,GAAd,EAAmBO,EAAnB;AACD;;;kCAEaP,G,EAAiC;AAC7C,UAAIO,KAAK,KAAKR,IAAL,CAAUW,GAAV,CAAcV,GAAd,CAAT;AACA,+BAAUO,OAAOI,SAAjB;AACA,aAAOJ,EAAP;AACD;;;qCAEgBP,G,EAAY;AAC3B,+BAAU,KAAKD,IAAL,CAAUS,GAAV,CAAcR,GAAd,CAAV;AACA,WAAKD,IAAL,CAAUa,MAAV,CAAiBZ,GAAjB;AACD;;;4DAEuCA,G,EAAiC;AACvE,WAAKa,uBAAL,CAA6Bb,GAA7B;AACA,UAAIO,KAAK,KAAKR,IAAL,CAAUW,GAAV,CAAcV,GAAd,CAAT;AACA,+BAAUO,OAAOI,SAAjB,EAA4B,sCAA5B;AACA,aAAOJ,EAAP;AACD;;;4CAEuBP,G,EAAY;AAClC,UAAI,KAAKP,wBAAT,EAAmC;AACjC,YAAII,gBAAgB,KAAKA,aAAzB;AACA,iCAAUA,kBAAkBc,SAA5B;AACA,YAAIG,WAAWjB,cAAca,GAAd,CAAkBV,GAAlB,CAAf;AACA,YAAIc,QAAJ,EAAc;AACZA;AACD,SAFD,MAEO;AACLA,qBAAW,CAAX;AACD;AACDjB,sBAAcY,GAAd,CAAkBT,GAAlB,EAAuBc,QAAvB;AACD;AACF;;;oCAEed,G,EAAY;AAC1B,UAAI,KAAKP,wBAAL,IAAiC,KAAKI,aAAL,KAAuBc,SAA5D,EAAuE,OAAO,IAAP;AACvE,UAAIG,WAAW,KAAKjB,aAAL,CAAmBa,GAAnB,CAAuBV,GAAvB,CAAf;AACA,+BAAUc,aAAaH,SAAb,IAA0BG,WAAW,CAA/C;AACA,aAAOA,aAAa,CAApB;AACD","file":"ResidualHeapValueIdentifiers.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Value } from \"../values/index.js\";\nimport type { BabelNodeIdentifier } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type { NameGenerator, PreludeGenerator } from \"../utils/generator\";\nimport * as t from \"babel-types\";\n\n// This class maintains a map of values to babel identifiers.\n// This class can optionally track how often such value identifiers are referenced\n// when pass 1 is activated, which is usually followed by pass 2 in which\n// unneeded identifiers (those which were only ever referenced once) are\n// eliminated as the defining expression can be inlined.\nexport class ResidualHeapValueIdentifiers {\n  constructor(values: Iterator<Value>, preludeGenerator: PreludeGenerator) {\n    this.collectValToRefCountOnly = false;\n    this._valueNameGenerator = preludeGenerator.createNameGenerator(\"_\");\n    this._populateIdentifierMap(values);\n  }\n\n  initPass1() {\n    this.collectValToRefCountOnly = true;\n    this.valToRefCount = new Map();\n  }\n\n  initPass2() {\n    this.collectValToRefCountOnly = false;\n  }\n\n  collectValToRefCountOnly: boolean;\n  valToRefCount: void | Map<Value, number>;\n  refs: Map<Value, BabelNodeIdentifier>;\n  _valueNameGenerator: NameGenerator;\n\n  _populateIdentifierMap(values: Iterator<Value>) {\n    this.refs = new Map();\n    for (const val of values) {\n      this._setIdentifier(val, this._createNewIdentifier(val));\n    }\n  }\n\n  _createNewIdentifier(val: Value): BabelNodeIdentifier {\n    const name = this._valueNameGenerator.generate(val.__originalName || \"\");\n    return t.identifier(name);\n  }\n\n  _setIdentifier(val: Value, id: BabelNodeIdentifier) {\n    invariant(!this.refs.has(val));\n    this.refs.set(val, id);\n  }\n\n  getIdentifier(val: Value): BabelNodeIdentifier {\n    let id = this.refs.get(val);\n    invariant(id !== undefined);\n    return id;\n  }\n\n  deleteIdentifier(val: Value) {\n    invariant(this.refs.has(val));\n    this.refs.delete(val);\n  }\n\n  getIdentifierAndIncrementReferenceCount(val: Value): BabelNodeIdentifier {\n    this.incrementReferenceCount(val);\n    let id = this.refs.get(val);\n    invariant(id !== undefined, \"Value Id cannot be null or undefined\");\n    return id;\n  }\n\n  incrementReferenceCount(val: Value) {\n    if (this.collectValToRefCountOnly) {\n      let valToRefCount = this.valToRefCount;\n      invariant(valToRefCount !== undefined);\n      let refCount = valToRefCount.get(val);\n      if (refCount) {\n        refCount++;\n      } else {\n        refCount = 1;\n      }\n      valToRefCount.set(val, refCount);\n    }\n  }\n\n  needsIdentifier(val: Value) {\n    if (this.collectValToRefCountOnly || this.valToRefCount === undefined) return true;\n    let refCount = this.valToRefCount.get(val);\n    invariant(refCount !== undefined && refCount > 0);\n    return refCount !== 1;\n  }\n}\n"]}