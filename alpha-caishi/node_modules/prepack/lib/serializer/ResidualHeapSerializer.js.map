{"version":3,"sources":["../../src/serializer/ResidualHeapSerializer.js"],"names":["t","commentStatement","text","s","emptyStatement","leadingComments","type","value","ResidualHeapSerializer","realm","logger","modules","residualHeapValueIdentifiers","residualHeapInspector","residualValues","residualFunctionInstances","residualClassMethodInstances","residualFunctionInfos","options","referencedDeclaredValues","additionalFunctionValuesAndEffects","additionalFunctionValueInfos","declarativeEnvironmentRecordsBindings","statistics","react","realmGenerator","generator","realmPreludeGenerator","preludeGenerator","prelude","_descriptors","Map","needsEmptyVar","needsAuxiliaryConstructor","descriptorNameGenerator","createNameGenerator","factoryNameGenerator","intrinsicNameGenerator","functionNameGenerator","requireReturns","serializedValues","Set","_serializedValueWithIdentifiers","additionalFunctionValueNestedFunctions","residualReactElementSerializer","residualFunctions","getLocation","getSerializeObjectIdentifier","createLocation","initializeConditionNameGenerator","location","identifier","generate","currentFunctionBody","entries","push","variableDeclaration","variableDeclarator","emitter","mainBody","getBody","_options","activeGeneratorBodies","obj","properties","objectPrototypeAlreadyEstablished","cleanupDummyProperties","skipPrototype","symbol","propertyBinding","desc","descriptor","undefined","emitNowOrAfterWaitingForDependencies","_getDescriptorValues","concat","_emitProperty","symbols","key","pathNode","canIgnoreProperty","has","unknownProperty","val","_getNestedAbstractValues","_emitPropertiesWithComputedNames","_emitObjectPrototype","_emitConstructorPrototype","objects","objectProperties","size","kind","getKind","proto","$Prototype","serializedProto","serializeValue","uid","fetchedPrototype","isCompatibleWith","MOBILE_JSC_VERSION","memberExpression","callExpression","memoizeReference","condition","binaryExpression","throwblock","blockStatement","throwStatement","newExpression","stringLiteral","emit","ifStatement","intrinsics","expressionStatement","assignmentExpression","func","prototype","getPropertyValue","absVal","values","args","length","cond","P","V","W","consequent","alternate","earlier_props","serializedP","serializedV","serializedCond","oldBody","beginEmitting","parentBody","consequentBody","endEmitting","consequentStatement","alternateBody","alternateStatement","getIdentifierAndIncrementReferenceCount","deleteIfMightHaveBeenDeleted","locationFunction","serializedKey","getAsPropertyNameExpression","computed","isIdentifier","_deleteProperty","emitDefinePropertyBody","joinCondition","trueBody","falseBody","descriptor1","descriptor2","unaryExpression","_canEmbedProperty","descValue","getReasonToWaitForDependencies","mightHaveBeenDeleted","_getPropertyAssignment","body","descProps","boolKeys","valKeys","get","set","descriptorsKey","boolKey","b","objectProperty","booleanLiteral","toString","join","descriptorId","declar","objectExpression","descKey","sequenceExpression","residualFunctionBinding","serializedValue","declarativeEnvironmentRecord","referentialized","mightBeObject","incrementReferenceCount","scopes","functionValues","generators","scope","description","numAdditionalFunctionReferences","additionalFuncValuesAndEffects","filter","funcValue","delayInitializations","simpleClosures","usedOnlyByAdditionalFunctions","residualFunctionInitializers","registerValueOnlyReferencedByResidualFunctions","usedOnlyByResidualFunctions","commonAncestor","Array","from","reduce","x","y","parent","name","getName","id","getIdentifier","binding","record","environment","residualFunctionBindings","residualBinding","additionalFunction","referencedOnlyFromAdditionalFunctions","instance","referentializer","referentializeBinding","referenceOnly","bindingType","refuseSerialization","add","intrinsicName","_serializeAbstractValueHelper","classMethodInstance","methodType","error","$ECMAScriptCode","loc","handleError","isLeaf","res","_serializeValue","target","_getTarget","init","result","needsIdentifier","debugScopes","scopeList","map","comment","_getValueDebugName","assignment","valueIds","delayedValues","deleteIdentifier","valuesInlined","intrinsicNameGenerated","convertStringToMember","locationFn","valueFn","empty","deletion","array","indexPropertyLength","remainingProperties","elems","i","elem","elemVal","delayReason","getReasonToWaitForActiveValue","delete","numberOfIndexProperties","lenProperty","ToLength","_assignProperty","initProperties","_serializeArrayIndexProperties","_serializeArrayLengthIfNeeded","_emitObjectProperties","arrayExpression","$MapData","$WeakMapData","len","mapConstructorDoesntTakeArguments","entry","$Key","$Value","emitAfterWaiting","$SetData","$WeakSetData","setConstructorDoesntTakeArguments","buf","$ViewedArrayBuffer","outlinedArrayBuffer","$ArrayBufferByteLength","db","$ArrayBufferData","allzero","numericLiteral","arrayValue","consExpr","$BoundTargetFunction","$BoundThis","$BoundArguments","boundArg","residualBindings","inAdditionalFunction","containingAdditionalFunction","currentAdditionalFunction","delayed","undelay","insertionPoint","getBodyReference","boundName","referencedValues","serializeBindingFunc","_serializeGlobalBinding","_serializeDeclarativeEnvironmentRecordBinding","bindingValue","$FunctionKind","homeObject","$HomeObject","$IsClassPrototype","_serializeClass","classFunc","classPrototype","classProtoId","hasSerializedClassProtoId","propertiesToSerialize","serializeClassPrototypeId","classId","serializeClassMethod","propertyNameOrSymbol","methodFunc","_serializeClassMethod","methodId","serializeClassProperty","propertyValue","prop","propertyName","method","classMethodKeyNode","classSuperNode","classMethodComputed","_serializeValueFunction","writable","configurable","enumerable","source","$OriginalSource","flags","$OriginalFlags","RegExp","regExpLiteral","isClass","dummyProperties","props","propValue","classConstructor","constructor","originalConstructor","prototypeId","setFunctionPrototype","_serializeValueRegExpObject","numberData","$NumberData","throwIfNotConcreteNumber","stringData","$StringData","throwIfNotConcreteString","booleanData","$BooleanData","throwIfNotConcreteBoolean","dateValue","$DateValue","serializedDateValue","_serializeValueTypedArrayOrDataView","_serializeValueArrayBuffer","serializeReactElement","_serializeValueMap","_serializeValueSet","$ParameterMap","createViaAuxiliaryConstructor","ObjectPrototype","_findLastObjectPrototype","_classConstructor","_serializeValueObjectViaConstructor","serializeValueRawObject","$Description","serializedArg","globalReg","globalSymbolRegistry","find","e","$Symbol","$ProxyTarget","$ProxyHandler","serializedArgs","abstractArg","abstractIndex","findIndex","v","buildNode","derivedIds","hasBeenDeclared","hasIdentifier","_serializeAbstractValue","isIntrinsic","_serializeValueIntrinsic","valueToNode","serialize","_serializeValueArray","_serializeValueProxy","_serializeValueSymbol","serializeValueObject","getGlobalLetBinding","rval","equals","globalReference","callback","newBody","statements","unshift","context","bind","serializeBinding","serializeGenerator","_withGeneratorScope","statement","canOmit","declare","postGeneratorCallback","_getContext","oldCurBody","oldSerialiedValueWithIdentifiers","item","_shouldBeWrapped","rewrittenAdditionalFunctions","shouldEmitLog","collectValToRefCountOnly","processAdditionalFunctionValuesFn","additionalFVEffects","additionalFunctionValue","effects","transforms","modifiedBindings","modifiedProperties","createdObjects","nestedFunctions","object","applyEffects","forEach","serializePropertiesAndBindings","keys","additionalFunctionValueInfo","modifiedBinding","newVal","additionalValueSerialized","returnStatement","lazyHoistedReactNodes","serializeLazyHoistedNodes","apply","_serializeAdditionalFunction","transform","resolveInitializedModules","moduleIds","console","log","initializedModules","restoreBindings","restoreProperties","evaluateAndRevertInGlobalEnv","_declaredAbstractValues","postGeneratorSerialization","moduleId","moduleValue","processAdditionalFunctionValues","finalize","factorifyInitializers","spliceFunctions","unstrictFunctionBodies","strictFunctionBodies","requireStatistics","replaced","count","strictDirective","directive","directiveLiteral","globalDirectives","isStrict","funcLoop","node","isFunctionExpression","directives","functionExpression","ast_body","declaredGlobals","globalExpression","thisExpression","usesThis","program_directives","file","program"],"mappings":"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","file":"ResidualHeapSerializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\nimport { IsArray, Get } from \"../methods/index.js\";\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  SymbolValue,\n  NumberValue,\n  StringValue,\n  BooleanValue,\n  AbstractValue,\n  EmptyValue,\n  FunctionValue,\n  ECMAScriptSourceFunctionValue,\n  Value,\n  ObjectValue,\n  NativeFunctionValue,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeMemberExpression,\n  BabelVariableKind,\n  BabelNodeFile,\n  BabelNodeFunctionExpression,\n} from \"babel-types\";\nimport { Generator, PreludeGenerator, NameGenerator } from \"../utils/generator.js\";\nimport type { SerializationContext } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n  ReactSerializerState,\n  SerializedBody,\n  ClassMethodInstance,\n  AdditionalFunctionEffects,\n} from \"./types.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport { TimingStatistics, SerializerStatistics, BodyReference } from \"./types.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\nimport type { Scope } from \"./ResidualHeapVisitor.js\";\nimport { factorifyObjects } from \"./factorify.js\";\nimport { voidExpression, emptyExpression, constructorExpression, protoExpression } from \"../utils/internalizer.js\";\nimport { Emitter } from \"./Emitter.js\";\nimport { ResidualHeapValueIdentifiers } from \"./ResidualHeapValueIdentifiers.js\";\nimport {\n  commonAncestorOf,\n  getSuggestedArrayLiteralLength,\n  withDescriptorValue,\n  ClassPropertiesToIgnore,\n  canIgnoreClassLengthProperty,\n} from \"./utils.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { canHoistFunction } from \"../react/hoisting.js\";\nimport { To } from \"../singletons.js\";\nimport { ResidualReactElementSerializer } from \"./ResidualReactElementSerializer.js\";\nimport type { Binding } from \"../environment.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\n\nfunction commentStatement(text: string) {\n  let s = t.emptyStatement();\n  s.leadingComments = [({ type: \"BlockComment\", value: text }: any)];\n  return s;\n}\n\nexport class ResidualHeapSerializer {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    residualHeapValueIdentifiers: ResidualHeapValueIdentifiers,\n    residualHeapInspector: ResidualHeapInspector,\n    residualValues: Map<Value, Set<Scope>>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    options: SerializerOptions,\n    referencedDeclaredValues: Set<AbstractValue>,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>,\n    statistics: SerializerStatistics,\n    react: ReactSerializerState\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.residualHeapValueIdentifiers = residualHeapValueIdentifiers;\n    this.statistics = statistics;\n    this.react = react;\n\n    let realmGenerator = this.realm.generator;\n    invariant(realmGenerator);\n    this.generator = realmGenerator;\n    let realmPreludeGenerator = this.realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n\n    this.prelude = [];\n    this._descriptors = new Map();\n    this.needsEmptyVar = false;\n    this.needsAuxiliaryConstructor = false;\n    this.descriptorNameGenerator = this.preludeGenerator.createNameGenerator(\"$$\");\n    this.factoryNameGenerator = this.preludeGenerator.createNameGenerator(\"$_\");\n    this.intrinsicNameGenerator = this.preludeGenerator.createNameGenerator(\"$i_\");\n    this.functionNameGenerator = this.preludeGenerator.createNameGenerator(\"$f_\");\n    this.requireReturns = new Map();\n    this.serializedValues = new Set();\n    this._serializedValueWithIdentifiers = new Set();\n    this.additionalFunctionValueNestedFunctions = new Set();\n    this.residualReactElementSerializer = new ResidualReactElementSerializer(this.realm, this);\n    this.residualFunctions = new ResidualFunctions(\n      this.realm,\n      this.statistics,\n      options,\n      this.modules,\n      this.requireReturns,\n      {\n        getLocation: value => this.getSerializeObjectIdentifier(value),\n        createLocation: () => {\n          const initializeConditionNameGenerator = this.preludeGenerator.createNameGenerator(\"_initialized\");\n          let location = t.identifier(initializeConditionNameGenerator.generate());\n          this.currentFunctionBody.entries.push(t.variableDeclaration(\"var\", [t.variableDeclarator(location)]));\n          return location;\n        },\n      },\n      this.prelude,\n      this.preludeGenerator.createNameGenerator(\"__init_\"),\n      this.factoryNameGenerator,\n      this.preludeGenerator.createNameGenerator(\"__scope_\"),\n      this.preludeGenerator.createNameGenerator(\"$\"),\n      residualFunctionInfos,\n      residualFunctionInstances,\n      residualClassMethodInstances,\n      additionalFunctionValueInfos,\n      this.additionalFunctionValueNestedFunctions\n    );\n    this.emitter = new Emitter(this.residualFunctions);\n    this.mainBody = this.emitter.getBody();\n    this.currentFunctionBody = this.mainBody;\n    this.residualHeapInspector = residualHeapInspector;\n    this.residualValues = residualValues;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.residualFunctionInfos = residualFunctionInfos;\n    this._options = options;\n    this.referencedDeclaredValues = referencedDeclaredValues;\n    this.activeGeneratorBodies = new Map();\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.declarativeEnvironmentRecordsBindings = declarativeEnvironmentRecordsBindings;\n  }\n\n  emitter: Emitter;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  functionInstances: Array<FunctionInstance>;\n  prelude: Array<BabelNodeStatement>;\n  body: Array<BabelNodeStatement>;\n  mainBody: SerializedBody;\n  // if we're in an additional function we need to access both mainBody and the\n  // additional function's body which will be currentFunctionBody.\n  currentFunctionBody: SerializedBody;\n  realm: Realm;\n  preludeGenerator: PreludeGenerator;\n  generator: Generator;\n  _descriptors: Map<string, BabelNodeIdentifier>;\n  needsEmptyVar: boolean;\n  needsAuxiliaryConstructor: boolean;\n  descriptorNameGenerator: NameGenerator;\n  factoryNameGenerator: NameGenerator;\n  intrinsicNameGenerator: NameGenerator;\n  functionNameGenerator: NameGenerator;\n  logger: Logger;\n  modules: Modules;\n  residualHeapValueIdentifiers: ResidualHeapValueIdentifiers;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  statistics: SerializerStatistics;\n  timingStats: TimingStatistics;\n  residualHeapInspector: ResidualHeapInspector;\n  residualValues: Map<Value, Set<Scope>>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  serializedValues: Set<Value>;\n  _serializedValueWithIdentifiers: Set<Value>;\n  residualFunctions: ResidualFunctions;\n  _options: SerializerOptions;\n  referencedDeclaredValues: Set<AbstractValue>;\n  activeGeneratorBodies: Map<Generator, SerializedBody>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>;\n  react: ReactSerializerState;\n  residualReactElementSerializer: ResidualReactElementSerializer;\n\n  // function values nested in additional functions can't delay initializations\n  // TODO: revisit this and fix additional functions to be capable of delaying initializations\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  currentAdditionalFunction: void | FunctionValue;\n\n  // Configures all mutable aspects of an object, in particular:\n  // symbols, properties, prototype.\n  // For every created object that corresponds to a value,\n  // this function should be invoked once.\n  // Thus, as a side effect, we gather statistics here on all emitted objects.\n  _emitObjectProperties(\n    obj: ObjectValue,\n    properties: Map<string, PropertyBinding> = obj.properties,\n    objectPrototypeAlreadyEstablished: boolean = false,\n    cleanupDummyProperties: ?Set<string>,\n    skipPrototype: boolean = false\n  ) {\n    //inject symbols\n    for (let [symbol, propertyBinding] of obj.symbols) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat([symbol, obj]), () => {\n        invariant(desc !== undefined);\n        return this._emitProperty(obj, symbol, desc);\n      });\n    }\n\n    // inject properties\n    for (let [key, propertyBinding] of properties) {\n      invariant(propertyBinding);\n      if (propertyBinding.pathNode !== undefined) continue; // Property is assigned to inside loop\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      if (this.residualHeapInspector.canIgnoreProperty(obj, key)) continue;\n      invariant(desc !== undefined);\n      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat(obj), () => {\n        invariant(desc !== undefined);\n        return this._emitProperty(obj, key, desc, cleanupDummyProperties != null && cleanupDummyProperties.has(key));\n      });\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.emitter.emitNowOrAfterWaitingForDependencies(this._getNestedAbstractValues(val, [obj]), () => {\n          invariant(val instanceof AbstractValue);\n          this._emitPropertiesWithComputedNames(obj, val);\n        });\n      }\n    }\n\n    // prototype\n    if (!skipPrototype) {\n      this._emitObjectPrototype(obj, objectPrototypeAlreadyEstablished);\n      if (obj instanceof FunctionValue) this._emitConstructorPrototype(obj);\n    }\n\n    this.statistics.objects++;\n    this.statistics.objectProperties += obj.properties.size;\n  }\n\n  _emitObjectPrototype(obj: ObjectValue, objectPrototypeAlreadyEstablished: boolean) {\n    let kind = obj.getKind();\n    let proto = obj.$Prototype;\n    if (objectPrototypeAlreadyEstablished) {\n      // Emitting an assertion. This can be removed in the future, or put under a DEBUG flag.\n      this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {\n        invariant(proto);\n        let serializedProto = this.serializeValue(proto);\n        let uid = this.getSerializeObjectIdentifier(obj);\n        const fetchedPrototype =\n          this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) || this.realm.isCompatibleWith(\"mobile\")\n            ? t.memberExpression(uid, protoExpression)\n            : t.callExpression(this.preludeGenerator.memoizeReference(\"Object.getPrototypeOf\"), [uid]);\n        let condition = t.binaryExpression(\"!==\", fetchedPrototype, serializedProto);\n        let throwblock = t.blockStatement([\n          t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"unexpected prototype\")])),\n        ]);\n        this.emitter.emit(t.ifStatement(condition, throwblock));\n      });\n      return;\n    }\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {\n      invariant(proto);\n      let serializedProto = this.serializeValue(proto);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      if (!this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) && !this.realm.isCompatibleWith(\"mobile\"))\n        this.emitter.emit(\n          t.expressionStatement(\n            t.callExpression(this.preludeGenerator.memoizeReference(\"Object.setPrototypeOf\"), [uid, serializedProto])\n          )\n        );\n      else {\n        this.emitter.emit(\n          t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, protoExpression), serializedProto))\n        );\n      }\n    });\n  }\n\n  _emitConstructorPrototype(func: FunctionValue) {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    let prototype = ResidualHeapInspector.getPropertyValue(func, \"prototype\");\n    if (prototype instanceof ObjectValue && this.residualValues.has(prototype)) {\n      this.emitter.emitNowOrAfterWaitingForDependencies([func], () => {\n        invariant(prototype instanceof Value);\n        this.serializeValue(prototype);\n      });\n    }\n  }\n\n  _getNestedAbstractValues(absVal: AbstractValue, values: Array<Value>): Array<Value> {\n    if (absVal.kind === \"widened property\") return values;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      values.push(P);\n      let V = absVal.args[1];\n      values.push(V);\n      let W = absVal.args[2];\n      if (W instanceof AbstractValue) this._getNestedAbstractValues(W, values);\n      else values.push(W);\n    } else {\n      // conditional assignment\n      values.push(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      this._getNestedAbstractValues(consequent, values);\n      this._getNestedAbstractValues(alternate, values);\n    }\n    return values;\n  }\n\n  _emitPropertiesWithComputedNames(obj: ObjectValue, absVal: AbstractValue) {\n    if (absVal.kind === \"widened property\") return;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this._emitPropertiesWithComputedNames(obj, earlier_props);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      let serializedP = this.serializeValue(P);\n      let serializedV = this.serializeValue(V);\n      this.emitter.emit(\n        t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, serializedP, true), serializedV))\n      );\n    } else {\n      // conditional assignment\n      let serializedCond = this.serializeValue(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      let oldBody = this.emitter.beginEmitting(\n        \"consequent\",\n        {\n          type: \"ConditionalAssignmentBranch\",\n          parentBody: undefined,\n          entries: [],\n        },\n        /*isChild*/ true\n      );\n      this._emitPropertiesWithComputedNames(obj, consequent);\n      let consequentBody = this.emitter.endEmitting(\"consequent\", oldBody);\n      let consequentStatement = t.blockStatement(consequentBody.entries);\n      oldBody = this.emitter.beginEmitting(\n        \"alternate\",\n        {\n          type: \"ConditionalAssignmentBranch\",\n          parentBody: undefined,\n          entries: [],\n        },\n        /*isChild*/ true\n      );\n      this._emitPropertiesWithComputedNames(obj, alternate);\n      let alternateBody = this.emitter.endEmitting(\"alternate\", oldBody);\n      let alternateStatement = t.blockStatement(alternateBody.entries);\n      this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));\n    }\n  }\n\n  // Overridable.\n  getSerializeObjectIdentifier(val: Value) {\n    return this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val);\n  }\n\n  _emitProperty(\n    val: ObjectValue,\n    key: string | SymbolValue,\n    desc: Descriptor | void,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ): void {\n    // Location for the property to be assigned to\n    let locationFunction = () => {\n      let serializedKey =\n        key instanceof SymbolValue ? this.serializeValue(key) : this.generator.getAsPropertyNameExpression(key);\n      let computed = key instanceof SymbolValue || !t.isIdentifier(serializedKey);\n      return t.memberExpression(this.getSerializeObjectIdentifier(val), serializedKey, computed);\n    };\n    if (desc === undefined) {\n      this._deleteProperty(locationFunction());\n    } else {\n      this.emitter.emit(this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc));\n    }\n  }\n\n  emitDefinePropertyBody(\n    deleteIfMightHaveBeenDeleted: boolean,\n    locationFunction: void | (() => BabelNodeLVal),\n    val: ObjectValue,\n    key: string | SymbolValue,\n    desc: Descriptor\n  ): BabelNodeStatement {\n    if (desc.joinCondition) {\n      let cond = this.serializeValue(desc.joinCondition);\n      invariant(cond !== undefined);\n      let trueBody;\n      let falseBody;\n      if (desc.descriptor1)\n        trueBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor1\n        );\n      if (desc.descriptor2)\n        falseBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor2\n        );\n      if (trueBody && falseBody) return t.ifStatement(cond, trueBody, falseBody);\n      if (trueBody) return t.ifStatement(cond, trueBody);\n      if (falseBody) return t.ifStatement(t.unaryExpression(\"!\", cond), falseBody);\n      invariant(false);\n    }\n    if (locationFunction !== undefined && this._canEmbedProperty(val, key, desc)) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      invariant(!this.emitter.getReasonToWaitForDependencies([descValue, val]), \"precondition of _emitProperty\");\n      let mightHaveBeenDeleted = descValue.mightHaveBeenDeleted();\n      // The only case we do not need to remove the dummy property is array index property.\n      return this._getPropertyAssignment(\n        locationFunction,\n        () => {\n          invariant(descValue instanceof Value);\n          return this.serializeValue(descValue);\n        },\n        mightHaveBeenDeleted,\n        deleteIfMightHaveBeenDeleted\n      );\n    }\n    let body = [];\n    let descProps = [];\n    let boolKeys = [\"enumerable\", \"configurable\"];\n    let valKeys = [];\n\n    if (!desc.get && !desc.set) {\n      boolKeys.push(\"writable\");\n      valKeys.push(\"value\");\n    } else {\n      valKeys.push(\"set\", \"get\");\n    }\n\n    let descriptorsKey = [];\n    for (let boolKey of boolKeys) {\n      if (boolKey in desc) {\n        let b = desc[boolKey];\n        invariant(b !== undefined);\n        descProps.push(t.objectProperty(t.identifier(boolKey), t.booleanLiteral(b)));\n        descriptorsKey.push(`${boolKey}:${b.toString()}`);\n      }\n    }\n\n    descriptorsKey = descriptorsKey.join(\",\");\n    let descriptorId = this._descriptors.get(descriptorsKey);\n    if (descriptorId === undefined) {\n      descriptorId = t.identifier(this.descriptorNameGenerator.generate(descriptorsKey));\n      let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(descriptorId, t.objectExpression(descProps))]);\n      // The descriptors are used across all scopes, and thus must be declared in the prelude.\n      this.prelude.push(declar);\n      this._descriptors.set(descriptorsKey, descriptorId);\n    }\n    invariant(descriptorId !== undefined);\n\n    for (let descKey of valKeys) {\n      if (descKey in desc) {\n        let descValue = desc[descKey];\n        invariant(descValue instanceof Value);\n        if (descValue instanceof UndefinedValue) {\n          this.serializeValue(descValue);\n          continue;\n        }\n        invariant(!this.emitter.getReasonToWaitForDependencies([descValue]), \"precondition of _emitProperty\");\n        body.push(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(descriptorId, t.identifier(descKey)),\n            this.serializeValue(descValue)\n          )\n        );\n      }\n    }\n    let serializedKey =\n      key instanceof SymbolValue\n        ? this.serializeValue(key)\n        : this.generator.getAsPropertyNameExpression(key, /*canBeIdentifier*/ false);\n    invariant(!this.emitter.getReasonToWaitForDependencies([val]), \"precondition of _emitProperty\");\n    body.push(\n      t.callExpression(this.preludeGenerator.memoizeReference(\"Object.defineProperty\"), [\n        this.getSerializeObjectIdentifier(val),\n        serializedKey,\n        descriptorId,\n      ])\n    );\n    return t.expressionStatement(t.sequenceExpression(body));\n  }\n\n  _serializeDeclarativeEnvironmentRecordBinding(residualFunctionBinding: ResidualFunctionBinding) {\n    if (!residualFunctionBinding.serializedValue) {\n      let value = residualFunctionBinding.value;\n      invariant(value);\n      invariant(residualFunctionBinding.declarativeEnvironmentRecord);\n\n      // Set up binding identity before starting to serialize value. This is needed in case of recursive dependencies.\n      residualFunctionBinding.referentialized = false;\n      residualFunctionBinding.serializedValue = this.serializeValue(value);\n      if (value.mightBeObject()) {\n        // Increment ref count one more time to ensure that this object will be assigned a unique id.\n        // This ensures that only once instance is created across all possible residual function invocations.\n        this.residualHeapValueIdentifiers.incrementReferenceCount(value);\n      }\n    }\n  }\n\n  // Determine whether initialization code for a value should go into the main body, or a more specific initialization body.\n  _getTarget(\n    val: Value\n  ): {\n    body: SerializedBody,\n    usedOnlyByResidualFunctions?: true,\n    usedOnlyByAdditionalFunctions?: boolean,\n    commonAncestor?: Scope,\n    description?: string,\n  } {\n    let scopes = this.residualValues.get(val);\n    invariant(scopes !== undefined);\n\n    // All relevant values were visited in at least one scope.\n    invariant(scopes.size >= 1);\n\n    // First, let's figure out from which function and generator scopes this value is referenced.\n    let functionValues = [];\n    let generators = [];\n    for (let scope of scopes) {\n      if (scope instanceof FunctionValue) functionValues.push(scope);\n      else {\n        invariant(scope instanceof Generator);\n        if (scope === this.realm.generator) {\n          // This value is used from the main generator scope. This means that we need to emit the value and its\n          // initialization code into the main body, and cannot delay initialization.\n          return {\n            body: this.currentFunctionBody,\n            description: \"this.realm.generator\",\n          };\n        }\n        generators.push(scope);\n      }\n    }\n\n    if (generators.length === 0) {\n      // This value is only referenced from residual functions.\n      invariant(functionValues.length > 0);\n      let additionalFunctionValuesAndEffects = this.additionalFunctionValuesAndEffects;\n      let numAdditionalFunctionReferences = 0;\n      // Make sure we don't delay things referenced by additional functions or nested functions\n      if (additionalFunctionValuesAndEffects) {\n        // flow forces me to do this\n        let additionalFuncValuesAndEffects = additionalFunctionValuesAndEffects;\n        numAdditionalFunctionReferences = functionValues.filter(\n          funcValue =>\n            additionalFuncValuesAndEffects.has(funcValue) || this.additionalFunctionValueNestedFunctions.has(funcValue)\n        ).length;\n      }\n\n      if (numAdditionalFunctionReferences > 0 || !this._options.delayInitializations || this._options.simpleClosures) {\n        // We can just emit it into the current function body.\n        return {\n          body: this.currentFunctionBody,\n          usedOnlyByAdditionalFunctions: numAdditionalFunctionReferences === functionValues.length,\n          description: \"this.currentFunctionBody\",\n        };\n      } else {\n        // We can delay the initialization, and move it into a conditional code block in the residual functions!\n        let body = this.residualFunctions.residualFunctionInitializers.registerValueOnlyReferencedByResidualFunctions(\n          functionValues,\n          val\n        );\n        return { body, usedOnlyByResidualFunctions: true, description: \"delay_initializer\" };\n      }\n    }\n\n    // This value is referenced from more than one generator or function.\n    // We can emit the initialization of this value into the body associated with their common ancestor.\n    let commonAncestor = Array.from(scopes).reduce((x, y) => commonAncestorOf(x, y), generators[0]);\n    invariant(commonAncestor instanceof Generator); // every scope is either the root, or a descendant\n    let body;\n    while (true) {\n      if (commonAncestor === this.generator) {\n        body = this.currentFunctionBody;\n      } else {\n        body = this.activeGeneratorBodies.get(commonAncestor);\n      }\n      if (body !== undefined) break;\n      commonAncestor = commonAncestor.parent;\n      invariant(commonAncestor !== undefined);\n    }\n    invariant(body !== undefined);\n    return { body, commonAncestor };\n  }\n\n  _getValueDebugName(val: Value) {\n    let name;\n    if (val instanceof FunctionValue) {\n      name = val.getName();\n    } else {\n      const id = this.residualHeapValueIdentifiers.getIdentifier(val);\n      invariant(id);\n      name = id.name;\n    }\n    return name;\n  }\n\n  serializeBinding(binding: Binding): BabelNodeIdentifier | BabelNodeMemberExpression {\n    let record = binding.environment;\n    invariant(record instanceof DeclarativeEnvironmentRecord, \"only declarative environments has bindings\");\n\n    let residualFunctionBindings = this.declarativeEnvironmentRecordsBindings.get(record);\n    invariant(\n      residualFunctionBindings,\n      \"all bindings that create abstract values must have at least one call emitted to the generator so the function environment should have been visited\"\n    );\n    let residualBinding = residualFunctionBindings.get(binding.name);\n    invariant(residualBinding, \"any referenced residual binding should have been visited\");\n\n    if (!residualBinding.referentialized) {\n      let additionalFunction = residualBinding.referencedOnlyFromAdditionalFunctions;\n      invariant(additionalFunction, \"residual bindings like this are only caused by leaked bindings in pure functions\");\n      let instance = this.residualFunctionInstances.get(additionalFunction);\n      invariant(instance, \"any serialized function must exist in the scope\");\n      this.residualFunctions.referentializer.referentializeBinding(residualBinding, binding.name, instance);\n    }\n\n    invariant(residualBinding.serializedValue);\n    return ((residualBinding.serializedValue: any): BabelNodeIdentifier | BabelNodeMemberExpression);\n  }\n\n  serializeValue(val: Value, referenceOnly?: boolean, bindingType?: BabelVariableKind): BabelNodeExpression {\n    invariant(!val.refuseSerialization);\n    if (val instanceof AbstractValue) {\n      if (val.kind === \"widened\") {\n        this.serializedValues.add(val);\n        let name = val.intrinsicName;\n        invariant(name !== undefined);\n        return t.identifier(name);\n      } else if (val.kind === \"widened property\") {\n        this.serializedValues.add(val);\n        return this._serializeAbstractValueHelper(val);\n      }\n    }\n\n    // make sure we're not serializing a class method here\n    if (val instanceof ECMAScriptSourceFunctionValue && this.residualClassMethodInstances.has(val)) {\n      let classMethodInstance = this.residualClassMethodInstances.get(val);\n      invariant(classMethodInstance);\n      // anything other than a class constructor should never go through serializeValue()\n      // so we need to log a nice error message to the user\n      if (classMethodInstance.methodType !== \"constructor\") {\n        let error = new CompilerDiagnostic(\n          \"a class method incorrectly went through the serializeValue() code path\",\n          val.$ECMAScriptCode.loc,\n          \"PP0022\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n    }\n\n    if (this._serializedValueWithIdentifiers.has(val)) {\n      return this.getSerializeObjectIdentifier(val);\n    }\n\n    this.serializedValues.add(val);\n    if (!referenceOnly && ResidualHeapInspector.isLeaf(val)) {\n      let res = this._serializeValue(val);\n      invariant(res !== undefined);\n      return res;\n    }\n    this._serializedValueWithIdentifiers.add(val);\n\n    let target = this._getTarget(val);\n    let oldBody = this.emitter.beginEmitting(val, target.body);\n    let init = this._serializeValue(val);\n\n    let id = this.residualHeapValueIdentifiers.getIdentifier(val);\n    let result = id;\n    this.residualHeapValueIdentifiers.incrementReferenceCount(val);\n\n    if (this.residualHeapValueIdentifiers.needsIdentifier(val)) {\n      if (init) {\n        if (this._options.debugScopes) {\n          let scopes = this.residualValues.get(val);\n          invariant(scopes !== undefined);\n          const scopeList = Array.from(scopes).map(s => `\"${s.getName()}\"`).join(\",\");\n          let comment = `${this._getValueDebugName(val)} referenced from scopes [${scopeList}]`;\n          if (target.commonAncestor !== undefined)\n            comment = `${comment} with common ancestor: ${target.commonAncestor.getName()}`;\n          if (target.description !== undefined) comment = `${comment} => ${target.description} `;\n          this.emitter.emit(commentStatement(comment));\n        }\n        if (init !== id) {\n          if (target.usedOnlyByResidualFunctions) {\n            let declar = t.variableDeclaration(bindingType ? bindingType : \"var\", [t.variableDeclarator(id)]);\n            this.mainBody.entries.push(declar);\n            let assignment = t.expressionStatement(t.assignmentExpression(\"=\", id, init));\n            this.emitter.emit(assignment);\n          } else {\n            let declar = t.variableDeclaration(bindingType ? bindingType : \"var\", [t.variableDeclarator(id, init)]);\n            this.emitter.emit(declar);\n          }\n        }\n        this.statistics.valueIds++;\n        if (target.usedOnlyByResidualFunctions) this.statistics.delayedValues++;\n      }\n    } else {\n      if (init) {\n        this.residualHeapValueIdentifiers.deleteIdentifier(val);\n        result = init;\n        this.statistics.valuesInlined++;\n      }\n    }\n\n    this.emitter.endEmitting(val, oldBody);\n    return result;\n  }\n\n  _serializeValueIntrinsic(val: Value): BabelNodeExpression {\n    let intrinsicName = val.intrinsicName;\n    invariant(intrinsicName);\n    if (val instanceof ObjectValue && val.intrinsicNameGenerated) {\n      // The intrinsic was generated at a particular point in time.\n      return this.preludeGenerator.convertStringToMember(intrinsicName);\n    } else {\n      // The intrinsic conceptually exists ahead of time.\n      invariant(this.emitter.getBody() === this.currentFunctionBody);\n      return this.preludeGenerator.memoizeReference(intrinsicName);\n    }\n  }\n\n  _getDescriptorValues(desc: Descriptor): Array<Value> {\n    if (desc.joinCondition !== undefined) return [desc.joinCondition];\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) return [desc.value];\n    invariant(desc.get !== undefined);\n    invariant(desc.set !== undefined);\n    return [desc.get, desc.set];\n  }\n\n  _deleteProperty(location: BabelNodeLVal) {\n    invariant(location.type === \"MemberExpression\");\n    this.emitter.emit(\n      t.expressionStatement(t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true))\n    );\n  }\n\n  _assignProperty(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    this.emitter.emit(\n      this._getPropertyAssignment(locationFn, valueFn, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted)\n    );\n  }\n\n  _getPropertyAssignment(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    let location = locationFn();\n    let value = valueFn();\n    let assignment = t.expressionStatement(t.assignmentExpression(\"=\", location, value));\n    if (mightHaveBeenDeleted) {\n      let condition = t.binaryExpression(\"!==\", value, this.serializeValue(this.realm.intrinsics.empty));\n      let deletion = null;\n      if (deleteIfMightHaveBeenDeleted) {\n        invariant(location.type === \"MemberExpression\");\n        deletion = t.expressionStatement(\n          t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true)\n        );\n      }\n      return t.ifStatement(condition, assignment, deletion);\n    } else {\n      return assignment;\n    }\n  }\n\n  _serializeArrayIndexProperties(\n    array: ObjectValue,\n    indexPropertyLength: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ) {\n    let elems = [];\n    for (let i = 0; i < indexPropertyLength; i++) {\n      let key = i + \"\";\n      let propertyBinding = remainingProperties.get(key);\n      let elem = null;\n      // \"propertyBinding === undefined\" means array has a hole in the middle.\n      if (propertyBinding !== undefined) {\n        let descriptor = propertyBinding.descriptor;\n        // \"descriptor === undefined\" means this array item has been deleted.\n        if (\n          descriptor !== undefined &&\n          descriptor.value !== undefined &&\n          this._canEmbedProperty(array, key, descriptor)\n        ) {\n          let elemVal = descriptor.value;\n          invariant(elemVal instanceof Value);\n          let mightHaveBeenDeleted = elemVal.mightHaveBeenDeleted();\n          let delayReason =\n            this.emitter.getReasonToWaitForDependencies(elemVal) ||\n            this.emitter.getReasonToWaitForActiveValue(array, mightHaveBeenDeleted);\n          if (!delayReason) {\n            elem = this.serializeValue(elemVal);\n            remainingProperties.delete(key);\n          }\n        }\n      }\n      elems.push(elem);\n    }\n    return elems;\n  }\n\n  _serializeArrayLengthIfNeeded(\n    val: ObjectValue,\n    numberOfIndexProperties: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ): void {\n    const realm = this.realm;\n    let lenProperty = Get(realm, val, \"length\");\n    // Need to serialize length property if:\n    // 1. array length is abstract.\n    // 2. array length is concrete, but different from number of index properties\n    //  we put into initialization list.\n    if (lenProperty instanceof AbstractValue || To.ToLength(realm, lenProperty) !== numberOfIndexProperties) {\n      if (!(lenProperty instanceof AbstractValue) || lenProperty.kind !== \"widened property\") {\n        this.emitter.emitNowOrAfterWaitingForDependencies([val], () => {\n          this._assignProperty(\n            () => t.memberExpression(this.getSerializeObjectIdentifier(val), t.identifier(\"length\")),\n            () => {\n              return this.serializeValue(lenProperty);\n            },\n            false /*mightHaveBeenDeleted*/\n          );\n        });\n      }\n      remainingProperties.delete(\"length\");\n    }\n  }\n\n  _serializeValueArray(val: ObjectValue): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n\n    const indexPropertyLength = getSuggestedArrayLiteralLength(this.realm, val);\n    // Use the serialized index properties as array initialization list.\n    const initProperties = this._serializeArrayIndexProperties(val, indexPropertyLength, remainingProperties);\n    this._serializeArrayLengthIfNeeded(val, indexPropertyLength, remainingProperties);\n    this._emitObjectProperties(val, remainingProperties);\n    return t.arrayExpression(initProperties);\n  }\n\n  _serializeValueMap(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let mapConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      let mightHaveBeenDeleted = key.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(key) ||\n        this.emitter.getReasonToWaitForDependencies(value) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || mapConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(delayReason, [key, value, val], () => {\n          invariant(key !== undefined);\n          invariant(value !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(\n                  this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                  t.identifier(\"set\")\n                ),\n                [this.serializeValue(key), this.serializeValue(value)]\n              )\n            )\n          );\n        });\n      } else {\n        let serializedKey = this.serializeValue(key);\n        let serializedValue = this.serializeValue(value);\n        let elem = t.arrayExpression([serializedKey, serializedValue]);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueSet(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let setConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      let mightHaveBeenDeleted = entry.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(entry) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || setConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(delayReason, [entry, val], () => {\n          invariant(entry !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(\n                  this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                  t.identifier(\"add\")\n                ),\n                [this.serializeValue(entry)]\n              )\n            )\n          );\n        });\n      } else {\n        let elem = this.serializeValue(entry);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueTypedArrayOrDataView(val: ObjectValue): BabelNodeExpression {\n    let buf = val.$ViewedArrayBuffer;\n    invariant(buf !== undefined);\n    let outlinedArrayBuffer = this.serializeValue(buf, true);\n    this._emitObjectProperties(val);\n    return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [outlinedArrayBuffer]);\n  }\n\n  _serializeValueArrayBuffer(val: ObjectValue): BabelNodeExpression {\n    let elems = [];\n\n    let len = val.$ArrayBufferByteLength;\n    let db = val.$ArrayBufferData;\n    invariant(len !== undefined);\n    invariant(db);\n    let allzero = true;\n    for (let i = 0; i < len; i++) {\n      if (db[i] !== 0) {\n        allzero = false;\n      }\n      let elem = t.numericLiteral(db[i]);\n      elems.push(elem);\n    }\n\n    this._emitObjectProperties(val);\n    if (allzero) {\n      // if they're all zero, just emit the array buffer constructor\n      return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [t.numericLiteral(len)]);\n    } else {\n      // initialize from a byte array otherwise\n      let arrayValue = t.arrayExpression(elems);\n      let consExpr = t.newExpression(this.preludeGenerator.memoizeReference(\"Uint8Array\"), [arrayValue]);\n      // access the Uint8Array.buffer property to extract the created buffer\n      return t.memberExpression(consExpr, t.identifier(\"buffer\"));\n    }\n  }\n\n  _serializeValueFunction(val: FunctionValue): void | BabelNodeExpression {\n    if (val instanceof BoundFunctionValue) {\n      this._emitObjectProperties(val);\n      return t.callExpression(\n        t.memberExpression(this.serializeValue(val.$BoundTargetFunction), t.identifier(\"bind\")),\n        [].concat(\n          this.serializeValue(val.$BoundThis),\n          val.$BoundArguments.map((boundArg, i) => this.serializeValue(boundArg))\n        )\n      );\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n\n    let instance = this.residualFunctionInstances.get(val);\n    invariant(instance);\n    let residualBindings = instance.residualFunctionBindings;\n\n    let inAdditionalFunction = this.currentFunctionBody !== this.mainBody;\n    if (inAdditionalFunction) instance.containingAdditionalFunction = this.currentAdditionalFunction;\n    let delayed = 1;\n    let undelay = () => {\n      if (--delayed === 0) {\n        invariant(instance);\n        // hoist if we are in an additionalFunction\n        if (this.currentFunctionBody !== this.mainBody && canHoistFunction(this.realm, val, undefined, new Set())) {\n          instance.insertionPoint = new BodyReference(this.mainBody, this.mainBody.entries.length);\n          instance.containingAdditionalFunction = undefined;\n        } else {\n          instance.insertionPoint = this.emitter.getBodyReference();\n        }\n      }\n    };\n    for (let [boundName, residualBinding] of residualBindings) {\n      let referencedValues = [];\n      let serializeBindingFunc;\n      if (!residualBinding.declarativeEnvironmentRecord) {\n        serializeBindingFunc = () => this._serializeGlobalBinding(boundName, residualBinding);\n      } else {\n        serializeBindingFunc = () => {\n          return this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);\n        };\n        let bindingValue = residualBinding.value;\n        invariant(bindingValue !== undefined);\n        referencedValues.push(bindingValue);\n        if (inAdditionalFunction) {\n          let { usedOnlyByAdditionalFunctions } = this._getTarget(bindingValue);\n          if (usedOnlyByAdditionalFunctions)\n            residualBinding.referencedOnlyFromAdditionalFunctions = this.currentAdditionalFunction;\n        }\n      }\n      delayed++;\n      this.emitter.emitNowOrAfterWaitingForDependencies(referencedValues, () => {\n        serializeBindingFunc();\n        undelay();\n      });\n    }\n    if (val.$FunctionKind === \"classConstructor\") {\n      let homeObject = val.$HomeObject;\n      if (homeObject instanceof ObjectValue && homeObject.$IsClassPrototype) {\n        this._serializeClass(val, homeObject, undelay);\n        return;\n      }\n    }\n    undelay();\n    this._emitObjectProperties(val);\n  }\n\n  _serializeClass(classFunc: ECMAScriptSourceFunctionValue, classPrototype: ObjectValue, undelay: Function): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(classFunc);\n\n    invariant(classMethodInstance !== undefined);\n\n    let classProtoId;\n    let hasSerializedClassProtoId = false;\n    let propertiesToSerialize = new Map();\n\n    let serializeClassPrototypeId = () => {\n      if (!hasSerializedClassProtoId) {\n        let classId = this.getSerializeObjectIdentifier(classFunc);\n        classProtoId = t.identifier(this.intrinsicNameGenerator.generate());\n        hasSerializedClassProtoId = true;\n        this.emitter.emit(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(classProtoId, t.memberExpression(classId, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    let serializeClassMethod = (propertyNameOrSymbol, methodFunc) => {\n      invariant(methodFunc instanceof ECMAScriptSourceFunctionValue);\n      if (methodFunc !== classFunc) {\n        // if the method does not have a $HomeObject, it's not a class method\n        if (methodFunc.$HomeObject !== undefined) {\n          this.serializedValues.add(methodFunc);\n          this._serializeClassMethod(propertyNameOrSymbol, methodFunc);\n        } else {\n          // if the method is not part of the class, we have to assign it to the prototype\n          // we can't serialize via emitting the properties as that will emit all\n          // the prototype and we only want to mutate the prototype here\n          serializeClassPrototypeId();\n          let methodId = this.serializeValue(methodFunc);\n          let name;\n\n          if (typeof propertyNameOrSymbol === \"string\") {\n            name = t.identifier(propertyNameOrSymbol);\n          } else {\n            name = this.serializeValue(propertyNameOrSymbol);\n          }\n          invariant(classProtoId !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(classProtoId, name), methodId))\n          );\n        }\n      }\n    };\n\n    let serializeClassProperty = (propertyNameOrSymbol, propertyValue) => {\n      // we handle the prototype via class syntax\n      if (propertyNameOrSymbol === \"prototype\") {\n        this.serializedValues.add(propertyValue);\n      } else if (propertyValue instanceof ECMAScriptSourceFunctionValue && propertyValue.$HomeObject === classFunc) {\n        serializeClassMethod(propertyNameOrSymbol, propertyValue);\n      } else {\n        let prop = classFunc.properties.get(propertyNameOrSymbol);\n        invariant(prop);\n        propertiesToSerialize.set(propertyNameOrSymbol, prop);\n      }\n    };\n\n    // find the all the properties on the class that we need to serialize\n    for (let [propertyName, method] of classFunc.properties) {\n      if (\n        !this.residualHeapInspector.canIgnoreProperty(classFunc, propertyName) &&\n        !ClassPropertiesToIgnore.has(propertyName) &&\n        method.descriptor !== undefined &&\n        !(propertyName === \"length\" && canIgnoreClassLengthProperty(classFunc, method.descriptor, this.logger))\n      ) {\n        withDescriptorValue(propertyName, method.descriptor, serializeClassProperty);\n      }\n    }\n    // pass in the properties and set it so we don't serialize the prototype\n    undelay();\n    this._emitObjectProperties(classFunc, propertiesToSerialize, undefined, undefined, true);\n\n    // handle non-symbol properties\n    for (let [propertyName, method] of classPrototype.properties) {\n      withDescriptorValue(propertyName, method.descriptor, serializeClassMethod);\n    }\n    // handle symbol properties\n    for (let [symbol, method] of classPrototype.symbols) {\n      withDescriptorValue(symbol, method.descriptor, serializeClassMethod);\n    }\n    // assign the AST method key node for the \"constructor\"\n    classMethodInstance.classMethodKeyNode = t.identifier(\"constructor\");\n\n    // handle class inheritance\n    if (!(classFunc.$Prototype instanceof NativeFunctionValue)) {\n      let proto = classFunc.$Prototype;\n      classMethodInstance.classSuperNode = this.serializeValue(classFunc.$Prototype);\n      if (proto.$HomeObject instanceof ObjectValue) {\n        this.serializedValues.add(proto.$HomeObject);\n      }\n    }\n  }\n\n  _serializeClassMethod(key: string | SymbolValue, methodFunc: ECMAScriptSourceFunctionValue): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(methodFunc);\n\n    invariant(classMethodInstance !== undefined);\n    if (typeof key === \"string\") {\n      classMethodInstance.classMethodKeyNode = t.identifier(key);\n      // as we know the method name is a string again, we can remove the computed status\n      classMethodInstance.classMethodComputed = false;\n    } else if (key instanceof SymbolValue) {\n      classMethodInstance.classMethodKeyNode = this.serializeValue(key);\n    } else {\n      invariant(false, \"Unknown method key type\");\n    }\n    this._serializeValueFunction(methodFunc);\n  }\n\n  // Checks whether a property can be defined via simple assignment, or using object literal syntax.\n  _canEmbedProperty(obj: ObjectValue, key: string | SymbolValue, prop: Descriptor): boolean {\n    if (prop.joinCondition !== undefined) return false;\n    if ((obj instanceof FunctionValue && key === \"prototype\") || (obj.getKind() === \"RegExp\" && key === \"lastIndex\"))\n      return !!prop.writable && !prop.configurable && !prop.enumerable && !prop.set && !prop.get;\n    else if (!!prop.writable && !!prop.configurable && !!prop.enumerable && !prop.set && !prop.get) {\n      return !(prop.value instanceof AbstractValue && prop.value.kind === \"widened property\");\n    } else {\n      return false;\n    }\n  }\n\n  _findLastObjectPrototype(obj: ObjectValue): ObjectValue {\n    while (obj.$Prototype instanceof ObjectValue) obj = obj.$Prototype;\n    return obj;\n  }\n\n  _serializeValueRegExpObject(val: ObjectValue): BabelNodeExpression {\n    let source = val.$OriginalSource;\n    let flags = val.$OriginalFlags;\n    invariant(typeof source === \"string\");\n    invariant(typeof flags === \"string\");\n    this._emitObjectProperties(val);\n    source = new RegExp(source).source; // add escapes as per 21.2.3.2.4\n    return t.regExpLiteral(source, flags);\n  }\n\n  // Overridable.\n  serializeValueRawObject(val: ObjectValue, isClass: boolean): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n    const dummyProperties = new Set();\n    let props = [];\n    for (let [key, propertyBinding] of val.properties) {\n      if (propertyBinding.pathNode !== undefined) continue; // written to inside loop\n      let descriptor = propertyBinding.descriptor;\n      if (descriptor === undefined || descriptor.value === undefined) continue; // deleted\n      if (this._canEmbedProperty(val, key, descriptor)) {\n        let propValue = descriptor.value;\n        invariant(propValue instanceof Value);\n        if (this.residualHeapInspector.canIgnoreProperty(val, key)) continue;\n        let mightHaveBeenDeleted = propValue.mightHaveBeenDeleted();\n        let serializedKey = this.generator.getAsPropertyNameExpression(key);\n        let delayReason =\n          this.emitter.getReasonToWaitForDependencies(propValue) ||\n          this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted);\n        // Although the property needs to be delayed, we still want to emit dummy \"undefined\"\n        // value as part of the object literal to ensure a consistent property ordering.\n        let serializedValue = voidExpression;\n        if (delayReason) {\n          // May need to be cleaned up later.\n          dummyProperties.add(key);\n        } else {\n          remainingProperties.delete(key);\n          serializedValue = this.serializeValue(propValue);\n        }\n        props.push(t.objectProperty(serializedKey, serializedValue));\n      } else if (descriptor.value instanceof Value && descriptor.value.mightHaveBeenDeleted()) {\n        dummyProperties.add(key);\n        let serializedKey = this.generator.getAsPropertyNameExpression(key);\n        props.push(t.objectProperty(serializedKey, voidExpression));\n      }\n    }\n    this._emitObjectProperties(\n      val,\n      remainingProperties,\n      /*objectPrototypeAlreadyEstablished*/ false,\n      dummyProperties,\n      isClass\n    );\n    return t.objectExpression(props);\n  }\n\n  _serializeValueObjectViaConstructor(\n    val: ObjectValue,\n    isClass: boolean,\n    classConstructor?: ECMAScriptSourceFunctionValue\n  ) {\n    let proto = val.$Prototype;\n    this._emitObjectProperties(val, val.properties, /*objectPrototypeAlreadyEstablished*/ true, undefined, isClass);\n    this.needsAuxiliaryConstructor = true;\n    let serializedProto = this.serializeValue(classConstructor ? classConstructor : proto);\n    return t.sequenceExpression([\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(constructorExpression, t.identifier(\"prototype\")),\n        serializedProto\n      ),\n      t.newExpression(constructorExpression, []),\n    ]);\n  }\n\n  serializeValueObject(val: ObjectValue): BabelNodeExpression | void {\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      let prototypeId = this.residualHeapValueIdentifiers.getIdentifier(val);\n      this.emitter.emitNowOrAfterWaitingForDependencies([constructor], () => {\n        invariant(constructor !== undefined);\n        invariant(prototypeId !== undefined);\n        this.serializeValue(constructor);\n        this._emitObjectProperties(val);\n        invariant(prototypeId.type === \"Identifier\");\n        this.residualFunctions.setFunctionPrototype(constructor, prototypeId);\n      });\n      return prototypeId;\n    }\n\n    let kind = val.getKind();\n    switch (kind) {\n      case \"RegExp\":\n        return this._serializeValueRegExpObject(val);\n      case \"Number\":\n        let numberData = val.$NumberData;\n        invariant(numberData !== undefined);\n        numberData.throwIfNotConcreteNumber();\n        invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Number\"), [t.numericLiteral(numberData.value)]);\n      case \"String\":\n        let stringData = val.$StringData;\n        invariant(stringData !== undefined);\n        stringData.throwIfNotConcreteString();\n        invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"String\"), [t.stringLiteral(stringData.value)]);\n      case \"Boolean\":\n        let booleanData = val.$BooleanData;\n        invariant(booleanData !== undefined);\n        booleanData.throwIfNotConcreteBoolean();\n        invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Boolean\"), [\n          t.booleanLiteral(booleanData.value),\n        ]);\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        let serializedDateValue = this.serializeValue(dateValue);\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Date\"), [serializedDateValue]);\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        return this._serializeValueTypedArrayOrDataView(val);\n      case \"ArrayBuffer\":\n        return this._serializeValueArrayBuffer(val);\n      case \"ReactElement\":\n        this.residualReactElementSerializer.serializeReactElement(val);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        return this._serializeValueMap(val);\n      case \"Set\":\n      case \"WeakSet\":\n        return this._serializeValueSet(val);\n      default:\n        invariant(kind === \"Object\", \"invariant established by visitor\");\n        invariant(this.$ParameterMap === undefined, \"invariant established by visitor\");\n\n        let proto = val.$Prototype;\n        let createViaAuxiliaryConstructor =\n          proto !== this.realm.intrinsics.ObjectPrototype &&\n          this._findLastObjectPrototype(val) === this.realm.intrinsics.ObjectPrototype &&\n          proto instanceof ObjectValue;\n        let isClass = false;\n        let classConstructor;\n\n        if (val.$IsClassPrototype) {\n          isClass = true;\n        }\n        if (proto.$IsClassPrototype) {\n          invariant(proto instanceof ObjectValue);\n          // we now need to check if the prototpe has a constructor\n          // if it does, we can serialize back the original class syntax\n          // by using the original class function\n          if (proto.properties.has(\"constructor\")) {\n            let _classConstructor = proto.properties.get(\"constructor\");\n            invariant(_classConstructor !== undefined);\n            // if the contructor has been deleted then we have no way\n            // to serialize the original class AST as it won't have been\n            // evluated and thus visited\n            if (_classConstructor.descriptor === undefined) {\n              throw new FatalError(\n                \"TODO #1024: implement object prototype serialization with deleted class constructor\"\n              );\n            }\n            let classFunc = Get(this.realm, proto, \"constructor\");\n            _classConstructor = classFunc;\n            invariant(_classConstructor instanceof ECMAScriptSourceFunctionValue);\n            isClass = true;\n          }\n        }\n\n        return createViaAuxiliaryConstructor\n          ? this._serializeValueObjectViaConstructor(val, isClass, classConstructor)\n          : this.serializeValueRawObject(val, isClass);\n    }\n  }\n\n  _serializeValueSymbol(val: SymbolValue): BabelNodeExpression {\n    let args = [];\n    if (val.$Description instanceof Value) {\n      let serializedArg = this.serializeValue(val.$Description);\n      invariant(serializedArg);\n      args.push(serializedArg);\n    }\n    // check if symbol value exists in the global symbol map, in that case we emit an invocation of System.for\n    // to look it up\n    let globalReg = this.realm.globalSymbolRegistry.find(e => e.$Symbol === val) !== undefined;\n    if (globalReg) {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol.for\"), args);\n    } else {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol\"), args);\n    }\n  }\n\n  _serializeValueProxy(val: ProxyValue): BabelNodeExpression {\n    return t.newExpression(this.preludeGenerator.memoizeReference(\"Proxy\"), [\n      this.serializeValue(val.$ProxyTarget),\n      this.serializeValue(val.$ProxyHandler),\n    ]);\n  }\n\n  _serializeAbstractValueHelper(val: AbstractValue): BabelNodeExpression {\n    let serializedArgs = val.args.map((abstractArg, i) => this.serializeValue(abstractArg));\n    if (val.kind === \"abstractConcreteUnion\") {\n      let abstractIndex = val.args.findIndex(v => v instanceof AbstractValue);\n      invariant(abstractIndex >= 0 && abstractIndex < val.args.length);\n      return serializedArgs[abstractIndex];\n    }\n    let serializedValue = val.buildNode(serializedArgs);\n    if (serializedValue.type === \"Identifier\") {\n      let id = ((serializedValue: any): BabelNodeIdentifier);\n      invariant(!this.preludeGenerator.derivedIds.has(id.name) || this.emitter.hasBeenDeclared(val));\n    }\n    return serializedValue;\n  }\n\n  _serializeAbstractValue(val: AbstractValue): void | BabelNodeExpression {\n    invariant(\n      val.kind !== \"sentinel member expression\" && val.kind !== \"sentinel ToObject\",\n      \"invariant established by visitor\"\n    );\n    if (val.hasIdentifier()) {\n      return this._serializeAbstractValueHelper(val);\n    } else {\n      // This abstract value's dependencies should all be declared\n      // but still need to check them again in case their serialized bodies are in different generator scope.\n      this.emitter.emitNowOrAfterWaitingForDependencies(val.args, () => {\n        const serializedValue = this._serializeAbstractValueHelper(val);\n        let uid = this.getSerializeObjectIdentifier(val);\n        let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(uid, serializedValue)]);\n        this.emitter.emit(declar);\n      });\n    }\n  }\n\n  _serializeValue(val: Value): void | BabelNodeExpression {\n    if (val instanceof AbstractValue) {\n      return this._serializeAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      return this._serializeValueIntrinsic(val);\n    } else if (val instanceof EmptyValue) {\n      this.needsEmptyVar = true;\n      return emptyExpression;\n    } else if (val instanceof UndefinedValue) {\n      return voidExpression;\n    } else if (ResidualHeapInspector.isLeaf(val)) {\n      return t.valueToNode(val.serialize());\n    } else if (IsArray(this.realm, val)) {\n      invariant(val instanceof ObjectValue);\n      return this._serializeValueArray(val);\n    } else if (val instanceof ProxyValue) {\n      return this._serializeValueProxy(val);\n    } else if (val instanceof FunctionValue) {\n      return this._serializeValueFunction(val);\n    } else if (val instanceof SymbolValue) {\n      return this._serializeValueSymbol(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n      return this.serializeValueObject(val);\n    }\n  }\n\n  _serializeGlobalBinding(boundName: string, residualFunctionBinding: ResidualFunctionBinding) {\n    invariant(!residualFunctionBinding.declarativeEnvironmentRecord);\n    if (!residualFunctionBinding.serializedValue) {\n      residualFunctionBinding.referentialized = true;\n      if (boundName === \"undefined\") {\n        residualFunctionBinding.serializedValue = voidExpression;\n      } else {\n        let value = this.realm.getGlobalLetBinding(boundName);\n        // Check for let binding vs global property\n        if (value) {\n          let rval = residualFunctionBinding.value;\n          invariant(rval !== undefined && value.equals(rval));\n          let id = this.serializeValue(rval, true, \"let\");\n          // increment ref count one more time as the value has been\n          // referentialized (stored in a variable) by serializeValue\n          this.residualHeapValueIdentifiers.incrementReferenceCount(rval);\n          residualFunctionBinding.serializedValue = id;\n        } else {\n          residualFunctionBinding.serializedValue = this.preludeGenerator.globalReference(boundName);\n        }\n      }\n    }\n  }\n\n  _withGeneratorScope(generator: Generator, callback: SerializedBody => void): Array<BabelNodeStatement> {\n    let newBody = { type: \"Generator\", parentBody: undefined, entries: [] };\n    let oldBody = this.emitter.beginEmitting(generator, newBody, /*isChild*/ true);\n    this.activeGeneratorBodies.set(generator, newBody);\n    callback(newBody);\n    this.activeGeneratorBodies.delete(generator);\n    const statements = this.emitter.endEmitting(generator, oldBody).entries;\n    if (this._options.debugScopes) {\n      let comment = `generator \"${generator.getName()}\"`;\n      if (generator.parent !== undefined) {\n        comment = `${comment} with parent \"${generator.parent.getName()}\"`;\n      }\n      statements.unshift(commentStatement(\"begin \" + comment));\n      statements.push(commentStatement(\"end \" + comment));\n    }\n    return statements;\n  }\n\n  _getContext(): SerializationContext {\n    // TODO #482: Values serialized by nested generators would currently only get defined\n    // along the code of the nested generator; their definitions need to get hoisted\n    // or repeated so that they are accessible and defined from all using scopes\n    let context = {\n      serializeValue: this.serializeValue.bind(this),\n      serializeBinding: this.serializeBinding.bind(this),\n      serializeGenerator: (generator: Generator): Array<BabelNodeStatement> =>\n        this._withGeneratorScope(generator, () => generator.serialize(context)),\n      emit: (statement: BabelNodeStatement) => {\n        this.emitter.emit(statement);\n      },\n      emitDefinePropertyBody: this.emitDefinePropertyBody.bind(this, false, undefined),\n      canOmit: (value: AbstractValue) => {\n        return !this.referencedDeclaredValues.has(value);\n      },\n      declare: (value: AbstractValue) => {\n        this.emitter.declare(value);\n      },\n    };\n    return context;\n  }\n\n  _serializeAdditionalFunction(generator: Generator, postGeneratorCallback: () => void) {\n    let context = this._getContext();\n    return this._withGeneratorScope(generator, newBody => {\n      let oldCurBody = this.currentFunctionBody;\n      let oldSerialiedValueWithIdentifiers = this._serializedValueWithIdentifiers;\n      this.currentFunctionBody = newBody;\n      this._serializedValueWithIdentifiers = new Set(Array.from(this._serializedValueWithIdentifiers));\n      generator.serialize(context);\n      if (postGeneratorCallback) postGeneratorCallback();\n      this.currentFunctionBody = oldCurBody;\n      this._serializedValueWithIdentifiers = oldSerialiedValueWithIdentifiers;\n    });\n  }\n\n  _shouldBeWrapped(body: Array<any>) {\n    for (let i = 0; i < body.length; i++) {\n      let item = body[i];\n      if (item.type === \"ExpressionStatement\") {\n        continue;\n      } else if (item.type === \"VariableDeclaration\" || item.type === \"FunctionDeclaration\") {\n        return true;\n      } else if (item.type === \"BlockStatement\") {\n        if (this._shouldBeWrapped(item.body)) {\n          return true;\n        }\n      } else if (item.type === \"IfStatement\") {\n        if (item.alternate) {\n          if (this._shouldBeWrapped(item.alternate.body)) {\n            return true;\n          }\n        }\n        if (item.consequent) {\n          if (this._shouldBeWrapped(item.consequent.body)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  processAdditionalFunctionValues(): Map<FunctionValue, Array<BabelNodeStatement>> {\n    let rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>> = new Map();\n    let shouldEmitLog = !this.residualHeapValueIdentifiers.collectValToRefCountOnly;\n    let processAdditionalFunctionValuesFn = () => {\n      let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n      if (additionalFVEffects) {\n        for (let [additionalFunctionValue, { effects, transforms }] of additionalFVEffects.entries()) {\n          let [\n            result,\n            generator,\n            modifiedBindings,\n            modifiedProperties: Map<PropertyBinding, void | Descriptor>,\n            createdObjects,\n          ] = effects;\n          let nestedFunctions = new Set([...createdObjects].filter(object => object instanceof FunctionValue));\n          // result -- ignore TODO: return the result from the function somehow\n          // Generator -- visit all entries\n          // Bindings -- only need to serialize bindings if they're captured by some nested function?\n          //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n          //          -- we don't overwrite anything they capture\n          //          -- TODO: deal with these properly\n          // PropertyBindings -- visit any property bindings that aren't to createdobjects\n          // CreatedObjects -- should take care of itself\n          this.realm.applyEffects([\n            result,\n            new Generator(this.realm),\n            modifiedBindings,\n            modifiedProperties,\n            createdObjects,\n          ]);\n          // Allows us to emit function declarations etc. inside of this additional\n          // function instead of adding them at global scope\n          // TODO: make sure this generator isn't getting mutated oddly\n          ((nestedFunctions: any): Set<FunctionValue>).forEach(val =>\n            this.additionalFunctionValueNestedFunctions.add(val)\n          );\n          let serializePropertiesAndBindings = () => {\n            for (let propertyBinding of modifiedProperties.keys()) {\n              let binding: PropertyBinding = ((propertyBinding: any): PropertyBinding);\n              let object = binding.object;\n              if (object instanceof ObjectValue && createdObjects.has(object)) continue;\n              if (object.refuseSerialization) continue;\n              if (object.isIntrinsic()) continue;\n              invariant(object instanceof ObjectValue);\n              this._emitProperty(object, binding.key, binding.descriptor, true);\n            }\n            invariant(result instanceof Value);\n            // Handle ModifiedBindings\n            let additionalFunctionValueInfo = this.additionalFunctionValueInfos.get(additionalFunctionValue);\n            invariant(additionalFunctionValueInfo);\n            for (let [modifiedBinding, residualBinding] of additionalFunctionValueInfo.modifiedBindings) {\n              let newVal = modifiedBinding.value;\n              invariant(newVal);\n              residualBinding.additionalValueSerialized = this.serializeValue(newVal);\n            }\n            if (!(result instanceof UndefinedValue)) this.emitter.emit(t.returnStatement(this.serializeValue(result)));\n\n            const lazyHoistedReactNodes = this.residualReactElementSerializer.serializeLazyHoistedNodes();\n            Array.prototype.push.apply(this.mainBody.entries, lazyHoistedReactNodes);\n          };\n          this.currentAdditionalFunction = additionalFunctionValue;\n          let body = this._serializeAdditionalFunction(generator, serializePropertiesAndBindings);\n          invariant(additionalFunctionValue instanceof ECMAScriptSourceFunctionValue);\n          for (let transform of transforms) {\n            transform(body);\n          }\n          rewrittenAdditionalFunctions.set(additionalFunctionValue, body);\n          // re-resolve initialized modules to include things from additional functions\n          this.modules.resolveInitializedModules();\n          if (shouldEmitLog && this.modules.moduleIds.size > 0)\n            console.log(\n              `=== ${this.modules.initializedModules.size} of ${this.modules.moduleIds\n                .size} modules initialized after additional function ${additionalFunctionValue.intrinsicName\n                ? additionalFunctionValue.intrinsicName\n                : \"\"}`\n            );\n          // These don't restore themselves properly otherwise.\n          this.realm.restoreBindings(modifiedBindings);\n          this.realm.restoreProperties(modifiedProperties);\n        }\n      }\n      return this.realm.intrinsics.undefined;\n    };\n    this.realm.evaluateAndRevertInGlobalEnv(processAdditionalFunctionValuesFn);\n    return rewrittenAdditionalFunctions;\n  }\n\n  // Hook point for any serialization needs to be done after generator serialization is complete.\n  postGeneratorSerialization(): void {\n    // For overriding only.\n  }\n\n  serialize(): BabelNodeFile {\n    this.generator.serialize(this._getContext());\n    invariant(this.emitter._declaredAbstractValues.size <= this.preludeGenerator.derivedIds.size);\n\n    this.postGeneratorSerialization();\n    Array.prototype.push.apply(this.prelude, this.preludeGenerator.prelude);\n\n    // TODO #20: add timers\n\n    // TODO #21: add event listeners\n\n    for (let [moduleId, moduleValue] of this.modules.initializedModules)\n      this.requireReturns.set(moduleId, this.serializeValue(moduleValue));\n\n    // Make sure additional functions get serialized.\n    let rewrittenAdditionalFunctions = this.processAdditionalFunctionValues();\n\n    this.modules.resolveInitializedModules();\n\n    this.emitter.finalize();\n\n    this.residualFunctions.residualFunctionInitializers.factorifyInitializers(this.factoryNameGenerator);\n    let { unstrictFunctionBodies, strictFunctionBodies, requireStatistics } = this.residualFunctions.spliceFunctions(\n      rewrittenAdditionalFunctions\n    );\n    if (this.modules.moduleIds.size > 0 && !this.residualHeapValueIdentifiers.collectValToRefCountOnly) {\n      console.log(\n        `=== ${this.modules.initializedModules.size} of ${this.modules.moduleIds\n          .size} modules initialized, ${requireStatistics.replaced} of ${requireStatistics.count} require calls inlined.`\n      );\n    }\n\n    // add strict modes\n    let strictDirective = t.directive(t.directiveLiteral(\"use strict\"));\n    let globalDirectives = [];\n    if (!this.realm.isStrict && !unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // no unstrict functions, only strict ones\n      globalDirectives.push(strictDirective);\n    } else if (unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // strict and unstrict functions\n      funcLoop: for (let node of strictFunctionBodies) {\n        if (t.isFunctionExpression(node)) {\n          let func = ((node: any): BabelNodeFunctionExpression);\n          if (func.body.directives) {\n            for (let directive of func.body.directives) {\n              if (directive.value.value === \"use strict\") {\n                // already have a use strict directive\n                continue funcLoop;\n              }\n            }\n          } else func.body.directives = [];\n\n          func.body.directives.unshift(strictDirective);\n        }\n      }\n    }\n\n    // build ast\n    if (this.needsEmptyVar) {\n      this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(emptyExpression, t.objectExpression([]))]));\n    }\n    if (this.needsAuxiliaryConstructor) {\n      this.prelude.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(constructorExpression, t.functionExpression(null, [], t.blockStatement([]))),\n        ])\n      );\n    }\n\n    let body = this.prelude.concat(this.emitter.getBody().entries);\n    factorifyObjects(body, this.factoryNameGenerator);\n\n    let ast_body = [];\n    if (this.preludeGenerator.declaredGlobals.size > 0)\n      ast_body.push(\n        t.variableDeclaration(\n          \"var\",\n          Array.from(this.preludeGenerator.declaredGlobals).map(key => t.variableDeclarator(t.identifier(key)))\n        )\n      );\n    if (body.length) {\n      if (this.realm.isCompatibleWith(\"node-source-maps\")) {\n        ast_body.push(\n          t.expressionStatement(\n            t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"require\"), [t.stringLiteral(\"source-map-support\")]),\n                t.identifier(\"install\")\n              ),\n              []\n            )\n          )\n        );\n      }\n\n      if (this._shouldBeWrapped(body)) {\n        let globalExpression = this.realm.isCompatibleWith(\"node-cli\") ? t.identifier(\"global\") : t.thisExpression();\n\n        let functionExpression = t.functionExpression(null, [], t.blockStatement(body, globalDirectives));\n        let callExpression = this.preludeGenerator.usesThis\n          ? t.callExpression(t.memberExpression(functionExpression, t.identifier(\"call\")), [globalExpression])\n          : t.callExpression(functionExpression, []);\n        ast_body.push(t.expressionStatement(callExpression));\n      } else {\n        ast_body = body;\n      }\n    }\n\n    // Make sure that the visitor visited as many values as the serializer\n    invariant(\n      this.serializedValues.size === this.residualValues.size,\n      \"serialized \" + this.serializedValues.size + \" of \" + this.residualValues.size\n    );\n\n    // TODO: find better way to do this?\n    // revert changes to functionInstances in case we do multiple serialization passes\n    for (let instance of this.residualFunctionInstances.values()) {\n      for (let binding of ((instance: any): FunctionInstance).residualFunctionBindings.values()) {\n        let b = ((binding: any): ResidualFunctionBinding);\n        delete b.serializedValue;\n        delete b.referentialized;\n      }\n    }\n\n    let program_directives = [];\n    if (this.realm.isStrict) program_directives.push(strictDirective);\n    return t.file(t.program(ast_body, program_directives));\n  }\n}\n"]}