{"version":3,"sources":["../../src/serializer/Emitter.js"],"names":["Emitter","residualFunctions","mainBody","type","parentBody","undefined","entries","_waitingForValues","Map","_waitingForBodies","_body","_declaredAbstractValues","_residualFunctions","_activeStack","_activeValues","Set","_activeGeneratorStack","_finalized","dependency","targetBody","isChild","push","has","add","includes","oldBody","statement","_processCurrentBody","lastDependency","pop","delete","_processValue","_isEmittingActiveGenerator","lastBody","length","size","body","a","get","shift","dependencies","func","emitNowOrAfterWaitingForDependencies","value","currentBody","_isGeneratorBody","_emitAfterWaitingForGeneratorBody","bodyStack","activeBody","slice","reverse","find","Array","isArray","values","delayReason","getReasonToWaitForDependencies","val","$BoundTargetFunction","$BoundThis","$BoundArguments","arg","addFunctionUsage","getBodyReference","hasIdentifier","valSerializeBodyStack","valActiveAncestorBody","_getFirstAncestorGeneratorWithActiveBody","indexOf","args","$ProxyTarget","$ProxyHandler","$Description","kind","getKind","proto","$Prototype","$DateValue","condition","_shouldEmitWithoutWaiting","beginEmitting","endEmitting","_emitAfterWaitingForValue","reason","set","b","emitAfterWaiting","_cloneGeneratorStack"],"mappings":"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","file":"Emitter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  AbstractValue,\n  FunctionValue,\n  Value,\n  ObjectValue,\n  SymbolValue,\n} from \"../values/index.js\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport type { SerializedBody } from \"./types.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport { BodyReference } from \"./types.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\n\n// The emitter keeps track of a stack of what's currently being emitted.\n// There are two kinds of interesting dependencies the emitter is dealing with:\n// 1. Value dependencies:\n//    If an emission task depends on the result of another emission task which\n//    is still currently being emitted, then the emission task must be performed later,\n//    once the dependency is available.\n//    To this end, the emitter maintains the `_activeValues` and `_waitingForValues` datastructures.\n// 2. Generator dependencies:\n//    For each generator, there's a corresponding \"body\", i.e. a stream of babel statements\n//    that the emitter is appending to.\n//    There's always a \"current\" body that is currently being emitted to.\n//    There's also a distinguished `mainBody` to which all statements get directly or indirectly appended.\n//    If there are multiple generators/bodies involved, then they form a stack.\n//    Nested bodies are usually composed into an instruction emitted to the outer body.\n//    For example, two nested generators may yield the then and else-branch of an `if` statement.\n//    When an emission is supposed to target a body that is the current body, i.e. when it sits\n//    lower on the stack, then the emission task gets delayed until the next emission task on\n//    the lower body entry is finished.\n//    To this end, the emitter maintains the `_activeGeneratorStack` and `_waitingForBodies` datastructures.\nexport class Emitter {\n  constructor(residualFunctions: ResidualFunctions) {\n    let mainBody = { type: \"MainGenerator\", parentBody: undefined, entries: [] };\n    this._waitingForValues = new Map();\n    this._waitingForBodies = new Map();\n    this._body = mainBody;\n    this._declaredAbstractValues = new Map();\n    this._residualFunctions = residualFunctions;\n    this._activeStack = [];\n    this._activeValues = new Set();\n    this._activeGeneratorStack = [mainBody];\n    this._finalized = false;\n  }\n\n  _finalized: boolean;\n  _activeStack: Array<string | Generator | Value>;\n  _activeValues: Set<Value>;\n  _activeGeneratorStack: Array<SerializedBody>; // Contains all the active generator bodies in stack order.\n  _residualFunctions: ResidualFunctions;\n  _waitingForValues: Map<Value, Array<{ body: SerializedBody, dependencies: Array<Value>, func: () => void }>>;\n  _waitingForBodies: Map<SerializedBody, Array<{ dependencies: Array<Value>, func: () => void }>>;\n  _declaredAbstractValues: Map<AbstractValue, Array<SerializedBody>>;\n  _body: SerializedBody;\n\n  beginEmitting(dependency: string | Generator | Value, targetBody: SerializedBody, isChild: boolean = false) {\n    invariant(!this._finalized);\n    this._activeStack.push(dependency);\n    if (dependency instanceof Value) {\n      invariant(!this._activeValues.has(dependency));\n      this._activeValues.add(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(!this._activeGeneratorStack.includes(targetBody));\n      this._activeGeneratorStack.push(targetBody);\n    }\n    if (isChild) {\n      targetBody.parentBody = this._body;\n    }\n    let oldBody = this._body;\n    this._body = targetBody;\n    return oldBody;\n  }\n  emit(statement: BabelNodeStatement) {\n    invariant(!this._finalized);\n    this._body.entries.push(statement);\n    this._processCurrentBody();\n  }\n  endEmitting(dependency: string | Generator | Value, oldBody: SerializedBody) {\n    invariant(!this._finalized);\n    let lastDependency = this._activeStack.pop();\n    invariant(dependency === lastDependency);\n    if (dependency instanceof Value) {\n      invariant(this._activeValues.has(dependency));\n      this._activeValues.delete(dependency);\n      this._processValue(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(this._isEmittingActiveGenerator());\n      this._activeGeneratorStack.pop();\n    }\n    let lastBody = this._body;\n    this._body = oldBody;\n    return lastBody;\n  }\n  finalize() {\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.length === 1);\n    invariant(this._activeGeneratorStack[0] === this._body);\n    this._processCurrentBody();\n    this._activeGeneratorStack.pop();\n    this._finalized = true;\n    invariant(this._waitingForBodies.size === 0);\n    invariant(this._waitingForValues.size === 0);\n    invariant(this._activeStack.length === 0);\n    invariant(this._activeValues.size === 0);\n    invariant(this._activeGeneratorStack.length === 0);\n  }\n  /**\n   * Emitter is emitting in two modes:\n   * 1. Emitting to entries in current active generator\n   * 2. Emitting to body of another scope(generator or residual function)\n   * This function checks the first condition above.\n   */\n  _isEmittingActiveGenerator(): boolean {\n    invariant(this._activeGeneratorStack.length > 0);\n    return this._activeGeneratorStack[this._activeGeneratorStack.length - 1] === this._body;\n  }\n  _isGeneratorBody(body: SerializedBody): boolean {\n    return body.type === \"MainGenerator\" || body.type === \"Generator\";\n  }\n  _processCurrentBody() {\n    if (!this._isEmittingActiveGenerator()) {\n      return;\n    }\n    let a = this._waitingForBodies.get(this._body);\n    if (a === undefined) return;\n    while (a.length > 0) {\n      let { dependencies, func } = a.shift();\n      this.emitNowOrAfterWaitingForDependencies(dependencies, func);\n    }\n    this._waitingForBodies.delete(this._body);\n  }\n  _processValue(value: Value) {\n    let a = this._waitingForValues.get(value);\n    if (a === undefined) return;\n    let currentBody = this._body;\n    while (a.length > 0) {\n      let { body, dependencies, func } = a.shift();\n      // If body is not generator body no need to wait for it.\n      if (this._isGeneratorBody(body) && body !== currentBody) {\n        this._emitAfterWaitingForGeneratorBody(body, dependencies, func);\n      } else {\n        this.emitNowOrAfterWaitingForDependencies(dependencies, func, body);\n      }\n    }\n    this._waitingForValues.delete(value);\n  }\n\n  // Find the first ancestor in input generator body stack that is in current active stack.\n  // It can always find one because the bottom one in the stack is the main generator.\n  _getFirstAncestorGeneratorWithActiveBody(bodyStack: Array<SerializedBody>): SerializedBody {\n    const activeBody = bodyStack.slice().reverse().find(body => this._activeGeneratorStack.includes(body));\n    invariant(activeBody);\n    return activeBody;\n  }\n\n  // Serialization of a statement related to a value MUST be delayed if\n  // the creation of the value's identity requires the availability of either:\n  // 1. a time-dependent value that is declared by some generator entry\n  //    that has not yet been processed\n  //    (tracked by `_declaredAbstractValues`), or\n  // 2. a value that is also currently being serialized\n  //    (tracked by `_activeValues`).\n  // 3. a generator body that is higher(near top) in generator body stack.\n  //    (tracked by `_activeGeneratorStack`)\n  getReasonToWaitForDependencies(dependencies: Value | Array<Value>): void | Value | SerializedBody {\n    invariant(!this._finalized);\n    if (Array.isArray(dependencies)) {\n      let values = ((dependencies: any): Array<Value>);\n      for (let value of values) {\n        let delayReason = this.getReasonToWaitForDependencies(value);\n        if (delayReason) return delayReason;\n      }\n      return undefined;\n    }\n\n    let val = ((dependencies: any): Value);\n    if (this._activeValues.has(val)) return val;\n\n    let delayReason;\n    if (val instanceof BoundFunctionValue) {\n      delayReason = this.getReasonToWaitForDependencies(val.$BoundTargetFunction);\n      if (delayReason) return delayReason;\n      delayReason = this.getReasonToWaitForDependencies(val.$BoundThis);\n      if (delayReason) return delayReason;\n      for (let arg of val.$BoundArguments) {\n        delayReason = this.getReasonToWaitForDependencies(arg);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof FunctionValue) {\n      this._residualFunctions.addFunctionUsage(val, this.getBodyReference());\n      return undefined;\n    } else if (val instanceof AbstractValue) {\n      if (val.hasIdentifier()) {\n        const valSerializeBodyStack = this._declaredAbstractValues.get(val);\n        if (!valSerializeBodyStack) {\n          // Hasn't been serialized yet.\n          return val;\n        } else {\n          // The dependency has already been serialized(declared). But we may still have to wait for\n          // current generator body to be available, under following conditions:\n          // 1. Currently emitting in generator body. -- and\n          // 2. Not emitting in current active generator.(otherwise no need to wait) -- and\n          // 3. Dependency's active ancestor generator body is higher(near top) in generator stack than current body.\n          const valActiveAncestorBody = this._getFirstAncestorGeneratorWithActiveBody(valSerializeBodyStack);\n          invariant(this._activeGeneratorStack.includes(valActiveAncestorBody));\n\n          if (this._isGeneratorBody(this._body)) {\n            invariant(this._activeGeneratorStack.includes(this._body));\n            if (\n              !this._isEmittingActiveGenerator() &&\n              this._activeGeneratorStack.indexOf(valActiveAncestorBody) > this._activeGeneratorStack.indexOf(this._body)\n            ) {\n              return this._body;\n            }\n          }\n        }\n      }\n      for (let arg of val.args) {\n        delayReason = this.getReasonToWaitForDependencies(arg);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof ProxyValue) {\n      delayReason = this.getReasonToWaitForDependencies(val.$ProxyTarget);\n      if (delayReason) return delayReason;\n      delayReason = this.getReasonToWaitForDependencies(val.$ProxyHandler);\n      if (delayReason) return delayReason;\n    } else if (val instanceof SymbolValue) {\n      if (val.$Description instanceof Value) {\n        delayReason = this.getReasonToWaitForDependencies(val.$Description);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof ObjectValue) {\n      let kind = val.getKind();\n      switch (kind) {\n        case \"Object\":\n          let proto = val.$Prototype;\n          if (proto instanceof ObjectValue) {\n            delayReason = this.getReasonToWaitForDependencies(val.$Prototype);\n            if (delayReason) return delayReason;\n          }\n          break;\n        case \"Date\":\n          invariant(val.$DateValue !== undefined);\n          delayReason = this.getReasonToWaitForDependencies(val.$DateValue);\n          if (delayReason) return delayReason;\n          break;\n        default:\n          break;\n      }\n    }\n\n    return undefined;\n  }\n  // Wait for a known-to-be active value if a condition is met.\n  getReasonToWaitForActiveValue(value: Value, condition: boolean): void | Value {\n    invariant(!this._finalized);\n    invariant(this._activeValues.has(value));\n    return condition ? value : undefined;\n  }\n  _shouldEmitWithoutWaiting(delayReason: void | Value | SerializedBody, targetBody?: SerializedBody): boolean {\n    /**\n     * We can directly emit without waiting if:\n     * 1. No delayReason\n     * 2. delayReason is a generator body while the target body we are not emitting into is not a generator body.\n     */\n    return (\n      !delayReason ||\n      (!(delayReason instanceof Value) &&\n        this._isGeneratorBody(delayReason) &&\n        targetBody !== undefined &&\n        !this._isGeneratorBody(targetBody))\n    );\n  }\n  emitAfterWaiting(\n    delayReason: void | Value | SerializedBody,\n    dependencies: Array<Value>,\n    func: () => void,\n    targetBody?: SerializedBody\n  ) {\n    if (this._shouldEmitWithoutWaiting(delayReason, targetBody)) {\n      if (targetBody === undefined || targetBody === this._body) {\n        // Emit into current body.\n        func();\n      } else {\n        invariant(!this._isGeneratorBody(targetBody));\n        const oldBody = this.beginEmitting(targetBody.type, targetBody);\n        func();\n        this.endEmitting(targetBody.type, oldBody);\n      }\n    } else {\n      invariant(delayReason !== undefined);\n      if (delayReason instanceof Value) {\n        this._emitAfterWaitingForValue(\n          delayReason,\n          dependencies,\n          targetBody === undefined ? this._body : targetBody,\n          func\n        );\n      } else if (this._isGeneratorBody(delayReason)) {\n        // delayReason is a generator body.\n        this._emitAfterWaitingForGeneratorBody(delayReason, dependencies, func);\n      } else {\n        // Unknown delay reason.\n        invariant(false);\n      }\n    }\n  }\n  _emitAfterWaitingForValue(reason: Value, dependencies: Array<Value>, targetBody: SerializedBody, func: () => void) {\n    invariant(!this._finalized);\n    invariant(\n      !(reason instanceof AbstractValue && this._declaredAbstractValues.has(reason)) || this._activeValues.has(reason)\n    );\n    let a = this._waitingForValues.get(reason);\n    if (a === undefined) this._waitingForValues.set(reason, (a = []));\n    a.push({ body: targetBody, dependencies, func });\n  }\n  _emitAfterWaitingForGeneratorBody(reason: SerializedBody, dependencies: Array<Value>, func: () => void) {\n    invariant(this._isGeneratorBody(reason));\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.includes(reason));\n    let b = this._waitingForBodies.get(reason);\n    if (b === undefined) this._waitingForBodies.set(reason, (b = []));\n    b.push({ dependencies, func });\n  }\n  emitNowOrAfterWaitingForDependencies(dependencies: Array<Value>, func: () => void, targetBody?: SerializedBody) {\n    invariant(!this._finalized);\n    this.emitAfterWaiting(this.getReasonToWaitForDependencies(dependencies), dependencies, func, targetBody);\n  }\n  _cloneGeneratorStack() {\n    return this._activeGeneratorStack.slice();\n  }\n  declare(value: AbstractValue) {\n    invariant(!this._finalized);\n    invariant(!this._activeValues.has(value));\n    invariant(value.hasIdentifier());\n    invariant(this._isEmittingActiveGenerator());\n    this._declaredAbstractValues.set(value, this._cloneGeneratorStack());\n    this._processValue(value);\n  }\n  hasBeenDeclared(value: AbstractValue) {\n    invariant(!this._finalized);\n    return this._declaredAbstractValues.has(value);\n  }\n  getBody(): SerializedBody {\n    return this._body;\n  }\n  isCurrentBodyOffspringOf(targetBody: SerializedBody): boolean {\n    let currentBody = this._body;\n    while (currentBody !== undefined) {\n      if (currentBody === targetBody) {\n        return true;\n      }\n      currentBody = currentBody.parentBody;\n    }\n    return false;\n  }\n  getBodyReference() {\n    invariant(!this._finalized);\n    return new BodyReference(this._body, this._body.entries.length);\n  }\n}\n"]}