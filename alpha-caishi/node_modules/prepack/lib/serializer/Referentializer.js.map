{"version":3,"sources":["../../src/serializer/Referentializer.js"],"names":["t","Referentializer","options","scopeNameGenerator","referentializedNameGenerator","statistics","_options","referentializationState","Map","_referentializedNameGenerator","capturedScopeInstanceIdx","capturedScopesArray","identifier","generate","capturedScopeAccessFunctionId","serializedScopes","referentializationScope","_createReferentializationState","bind","body","selectorParam","captured","_getReferentializationState","selectorExpression","memberExpression","cases","values","scopeBinding","scopeObjectExpression","arrayExpression","initializationValues","push","switchCase","numericLiteral","id","expressionStatement","assignmentExpression","breakStatement","throwStatement","newExpression","stringLiteral","variableDeclaration","variableDeclarator","ifStatement","unaryExpression","blockStatement","switchStatement","returnStatement","factoryFunction","functionExpression","accessFunctionId","residualBinding","declarativeEnvironmentRecord","referencedOnlyFromAdditionalFunctions","scope","get","refState","name","containingAdditionalFunction","set","capturedScope","funcName","callExpression","instance","simpleClosures","serializedBindingId","serializedValue","declar","initializationStatements","_getSerializedBindingScopeInstance","variableIndexInScope","length","referentialized","unbound","instances","shouldReferentializeInstanceFn","residualBindings","residualFunctionBindings","undefined","modified","referentializeBinding","scopeInstances"],"mappings":"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","file":"Referentializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement, BabelNodeIdentifier } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type { ResidualFunctionBinding, ScopeBinding, FunctionInstance } from \"./types.js\";\nimport { SerializerStatistics } from \"./types.js\";\nimport { getOrDefault } from \"./utils.js\";\n\n// Each of these will correspond to a different preludeGenerator and thus will\n// have different values available for initialization. FunctionValues should\n// only be additional functions.\nexport type ReferentializationScope = FunctionValue | \"GLOBAL\";\n\ntype ReferentializationState = {|\n  capturedScopeInstanceIdx: number,\n  capturedScopesArray: BabelNodeIdentifier,\n  capturedScopeAccessFunctionId: BabelNodeIdentifier,\n  serializedScopes: Map<DeclarativeEnvironmentRecord, ScopeBinding>,\n|};\n\n/*\n * This class helps fixup names in residual functions for variables that these\n * functions capture from parent scopes.\n * For each ReferentializationScope it creates a _get_scope_binding function\n * that contains the initialization for all of that scope's FunctionInstances\n * which will contain a switch statement with all the initializations.\n */\nexport class Referentializer {\n  constructor(\n    options: SerializerOptions,\n    scopeNameGenerator: NameGenerator,\n    referentializedNameGenerator: NameGenerator,\n    statistics: SerializerStatistics\n  ) {\n    this._options = options;\n    this.scopeNameGenerator = scopeNameGenerator;\n    this.statistics = statistics;\n\n    this.referentializationState = new Map();\n    this._referentializedNameGenerator = referentializedNameGenerator;\n  }\n\n  _options: SerializerOptions;\n  scopeNameGenerator: NameGenerator;\n  statistics: SerializerStatistics;\n\n  _newCapturedScopeInstanceIdx: number;\n  referentializationState: Map<ReferentializationScope, ReferentializationState>;\n  _referentializedNameGenerator: NameGenerator;\n\n  _createReferentializationState(): ReferentializationState {\n    return {\n      capturedScopeInstanceIdx: 0,\n      capturedScopesArray: t.identifier(this.scopeNameGenerator.generate(\"main\")),\n      capturedScopeAccessFunctionId: t.identifier(this.scopeNameGenerator.generate(\"get_scope_binding\")),\n      serializedScopes: new Map(),\n    };\n  }\n\n  _getReferentializationState(referentializationScope: ReferentializationScope): ReferentializationState {\n    return getOrDefault(\n      this.referentializationState,\n      referentializationScope,\n      this._createReferentializationState.bind(this)\n    );\n  }\n\n  // Generate a shared function for accessing captured scope bindings.\n  // TODO: skip generating this function if the captured scope is not shared by multiple residual functions.\n  createCaptureScopeAccessFunction(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    const body = [];\n    const selectorParam = t.identifier(\"selector\");\n    const captured = t.identifier(\"__captured\");\n    const capturedScopesArray = this._getReferentializationState(referentializationScope).capturedScopesArray;\n    const selectorExpression = t.memberExpression(capturedScopesArray, selectorParam, /*Indexer syntax*/ true);\n\n    // One switch case for one scope.\n    const cases = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    for (const scopeBinding of serializedScopes.values()) {\n      const scopeObjectExpression = t.arrayExpression((scopeBinding.initializationValues: any));\n      cases.push(\n        t.switchCase(t.numericLiteral(scopeBinding.id), [\n          t.expressionStatement(t.assignmentExpression(\"=\", selectorExpression, scopeObjectExpression)),\n          t.breakStatement(),\n        ])\n      );\n    }\n    // Default case.\n    cases.push(\n      t.switchCase(null, [\n        t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"Unknown scope selector\")])),\n      ])\n    );\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(captured, selectorExpression)]));\n    body.push(\n      t.ifStatement(\n        t.unaryExpression(\"!\", captured),\n        t.blockStatement([\n          t.switchStatement(selectorParam, cases),\n          t.expressionStatement(t.assignmentExpression(\"=\", captured, selectorExpression)),\n        ])\n      )\n    );\n    body.push(t.returnStatement(captured));\n    const factoryFunction = t.functionExpression(null, [selectorParam], t.blockStatement(body));\n    const accessFunctionId = this._getReferentializationState(referentializationScope).capturedScopeAccessFunctionId;\n    return t.variableDeclaration(\"var\", [t.variableDeclarator(accessFunctionId, factoryFunction)]);\n  }\n\n  _getSerializedBindingScopeInstance(residualBinding: ResidualFunctionBinding): ScopeBinding {\n    let declarativeEnvironmentRecord = residualBinding.declarativeEnvironmentRecord;\n    let referentializationScope = residualBinding.referencedOnlyFromAdditionalFunctions || \"GLOBAL\";\n    invariant(declarativeEnvironmentRecord);\n\n    // figure out if this is accessed only from additional functions\n    let serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    let scope = serializedScopes.get(declarativeEnvironmentRecord);\n    if (!scope) {\n      let refState: ReferentializationState = this._getReferentializationState(referentializationScope);\n      scope = {\n        name: this.scopeNameGenerator.generate(),\n        id: refState.capturedScopeInstanceIdx++,\n        initializationValues: [],\n        containingAdditionalFunction: residualBinding.referencedOnlyFromAdditionalFunctions,\n      };\n      serializedScopes.set(declarativeEnvironmentRecord, scope);\n    }\n\n    residualBinding.scope = scope;\n    return scope;\n  }\n\n  getReferentializedScopeInitialization(scope: ScopeBinding) {\n    let capturedScope = scope.capturedScope;\n    invariant(capturedScope);\n    const funcName = this._getReferentializationState(scope.containingAdditionalFunction || \"GLOBAL\")\n      .capturedScopeAccessFunctionId;\n    return [\n      t.variableDeclaration(\"var\", [\n        t.variableDeclarator(t.identifier(capturedScope), t.callExpression(funcName, [t.identifier(scope.name)])),\n      ]),\n    ];\n  }\n\n  referentializeBinding(residualBinding: ResidualFunctionBinding, name: string, instance: FunctionInstance): void {\n    if (this._options.simpleClosures) {\n      // When simpleClosures is enabled, then space for captured mutable bindings is allocated upfront.\n      let serializedBindingId = t.identifier(this._referentializedNameGenerator.generate(name));\n      let serializedValue = residualBinding.serializedValue;\n      invariant(serializedValue);\n      let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(serializedBindingId, serializedValue)]);\n      instance.initializationStatements.push(declar);\n      residualBinding.serializedValue = serializedBindingId;\n    } else {\n      // When simpleClosures is not enabled, then space for captured mutable bindings is allocated lazily.\n      let scope = this._getSerializedBindingScopeInstance(residualBinding);\n      let capturedScope = \"__captured\" + scope.name;\n      // Save the serialized value for initialization at the top of\n      // the factory.\n      // This can serialize more variables than are necessary to execute\n      // the function because every function serializes every\n      // modified variable of its parent scope. In some cases it could be\n      // an improvement to split these variables into multiple\n      // scopes.\n      const variableIndexInScope = scope.initializationValues.length;\n      invariant(residualBinding.serializedValue);\n      scope.initializationValues.push(residualBinding.serializedValue);\n      scope.capturedScope = capturedScope;\n\n      // Replace binding usage with scope references\n      residualBinding.serializedValue = t.memberExpression(\n        t.identifier(capturedScope),\n        t.numericLiteral(variableIndexInScope),\n        true // Array style access.\n      );\n    }\n\n    residualBinding.referentialized = true;\n    this.statistics.referentialized++;\n  }\n\n  referentialize(\n    unbound: Set<string>,\n    instances: Array<FunctionInstance>,\n    shouldReferentializeInstanceFn: FunctionInstance => boolean\n  ): void {\n    for (let instance of instances) {\n      let residualBindings = instance.residualFunctionBindings;\n\n      for (let name of unbound) {\n        let residualBinding = residualBindings.get(name);\n        invariant(residualBinding !== undefined);\n        if (residualBinding.modified) {\n          // Initialize captured scope at function call instead of globally\n          if (!residualBinding.referentialized) {\n            if (!shouldReferentializeInstanceFn(instance)) {\n              // TODO #989: Fix additional functions and referentialization\n              throw new FatalError(\"TODO: implement referentialization for prepacked functions\");\n            }\n            this.referentializeBinding(residualBinding, name, instance);\n          }\n\n          invariant(residualBinding.referentialized);\n          if (residualBinding.declarativeEnvironmentRecord && residualBinding.scope) {\n            instance.scopeInstances.set(residualBinding.scope.name, residualBinding.scope);\n          }\n        }\n      }\n    }\n  }\n\n  createCapturedScopesArrayInitialization(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    return t.variableDeclaration(\"var\", [\n      t.variableDeclarator(\n        this._getReferentializationState(referentializationScope).capturedScopesArray,\n        t.callExpression(t.identifier(\"Array\"), [\n          t.numericLiteral(this._getReferentializationState(referentializationScope).capturedScopeInstanceIdx),\n        ])\n      ),\n    ]);\n  }\n}\n"]}