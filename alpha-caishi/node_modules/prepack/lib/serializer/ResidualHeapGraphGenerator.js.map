{"version":3,"sources":["../../src/serializer/ResidualHeapGraphGenerator.js"],"names":["ResidualHeapGraphGenerator","realm","logger","modules","additionalFunctionValuesAndEffects","valueIdentifiers","valueToEdgeRecord","_valueToEdgeRecord","_valueIdentifiers","_visitedValues","Set","_valueIds","Map","_idSeed","_path","_edges","val","_shouldIgnore","_updateEdge","has","add","length","pop","id","get","set","isIntrinsic","isLeaf","parent","push","fromId","_getValueId","toId","serializedId","getIdentifier","__originalName","name","nodes","edges","content","nodeId","_getValueShape","_getValueLabel","edge","nodesData","edgesData","node","nodeData","label","shape","color","_getValueColor","entries","index","edgeData","from","to","arrows","graphData","JSON","stringify","heapGraphFormat","_generateDotGraphData","_generateVisJSGraphData"],"mappings":"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","file":"ResidualHeapGraphGenerator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Logger } from \"../utils/logger.js\";\nimport type { Modules } from \"../utils/modules.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ObjectRefCount, AdditionalFunctionEffects } from \"./types.js\";\nimport type { ResidualHeapValueIdentifiers } from \"./ResidualHeapValueIdentifiers\";\n\nimport invariant from \"../invariant.js\";\nimport {\n  Value,\n  EmptyValue,\n  FunctionValue,\n  AbstractValue,\n  SymbolValue,\n  ProxyValue,\n  ObjectValue,\n} from \"../values/index.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { ResidualHeapVisitor } from \"./ResidualHeapVisitor.js\";\n\ntype Edge = {\n  fromId: number,\n  toId: number,\n};\n\n/**\n * Generate a visualizable objects graph for Prepack heap.\n */\nexport class ResidualHeapGraphGenerator extends ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    valueIdentifiers: ResidualHeapValueIdentifiers,\n    valueToEdgeRecord: Map<Value, ObjectRefCount>\n  ) {\n    super(realm, logger, modules, additionalFunctionValuesAndEffects);\n    this._valueToEdgeRecord = valueToEdgeRecord;\n    this._valueIdentifiers = valueIdentifiers;\n    this._visitedValues = new Set();\n    this._valueIds = new Map();\n    this._idSeed = 0;\n    this._path = [];\n    this._edges = [];\n  }\n\n  _valueIdentifiers: ResidualHeapValueIdentifiers;\n  _valueToEdgeRecord: Map<Value, ObjectRefCount>;\n  _valueIds: Map<Value, number>;\n  _idSeed: number;\n  _visitedValues: Set<Value>;\n  _path: Array<Value>; // Contains the path of nodes from root to current visiting node.\n  _edges: Array<Edge>;\n\n  // Override.\n  preProcessValue(val: Value): boolean {\n    if (this._shouldIgnore(val)) {\n      return true;\n    }\n    this._updateEdge(val);\n\n    if (this._visitedValues.has(val)) {\n      return false; // Already visited.\n    }\n    this._visitedValues.add(val);\n    return true;\n  }\n\n  // Override.\n  postProcessValue(val: Value): void {\n    if (this._shouldIgnore(val)) {\n      return;\n    }\n    invariant(this._path.length > 0);\n    this._path.pop();\n  }\n\n  _getValueId(val: Value): number {\n    let id = this._valueIds.get(val);\n    if (!id) {\n      this._valueIds.set(val, ++this._idSeed);\n      id = this._idSeed;\n    }\n    return id;\n  }\n\n  _shouldIgnore(val: Value): boolean {\n    return val instanceof EmptyValue || val.isIntrinsic() || ResidualHeapInspector.isLeaf(val);\n  }\n\n  _updateEdge(val: Value) {\n    if (this._path.length > 0) {\n      const parent = this._path[this._path.length - 1];\n      this._edges.push({ fromId: this._getValueId(parent), toId: this._getValueId(val) });\n    }\n    this._path.push(val);\n  }\n\n  _getValueLabel(val: Value): string {\n    // TODO: does not use ref count yet, figure out how to best visualize it later.\n    const serializedId = this._valueIdentifiers.getIdentifier(val);\n    invariant(serializedId);\n    return val.__originalName ? `${serializedId.name}(${val.__originalName})` : serializedId.name;\n  }\n\n  _generateDotGraphData(nodes: Set<Value>, edges: Array<Edge>): string {\n    let content = \"digraph{\\n\";\n    for (const val of nodes) {\n      const nodeId = this._getValueId(val);\n      content += `  node${nodeId} [shape=${this._getValueShape(val)} label=${this._getValueLabel(val)}];\\n`;\n    }\n    for (const edge of edges) {\n      content += `  node${edge.fromId} -> node${edge.toId};\\n`;\n    }\n    content += \"}\";\n    return content;\n  }\n\n  _generateVisJSGraphData(nodes: Set<Value>, edges: Array<Edge>): string {\n    let nodesData = [];\n    let edgesData = [];\n\n    for (let node of nodes) {\n      const nodeId = this._getValueId(node);\n      let nodeData = {\n        id: `${nodeId}`,\n        label: this._getValueLabel(node),\n        shape: this._getValueShape(node),\n        color: this._getValueColor(node),\n      };\n      nodesData.push(nodeData);\n    }\n\n    for (let [index, edge] of edges.entries()) {\n      let edgeData = {\n        id: index,\n        from: `${edge.fromId}`,\n        to: `${edge.toId}`,\n        arrows: \"to\",\n      };\n      edgesData.push(edgeData);\n    }\n\n    let graphData = {\n      nodes: nodesData,\n      edges: edgesData,\n    };\n    return JSON.stringify(graphData);\n  }\n\n  // TODO: find a way to comment the meaning of shape => value mapping in final graph language.\n  _getValueShape(val: Value): string {\n    let shape = null;\n    if (val instanceof FunctionValue) {\n      shape = \"circle\";\n    } else if (val instanceof AbstractValue) {\n      shape = \"diamond\";\n    } else if (val instanceof ProxyValue) {\n      shape = \"triangle\";\n    } else if (val instanceof SymbolValue) {\n      shape = \"star\";\n    } else if (val instanceof ObjectValue) {\n      shape = \"box\";\n    } else {\n      shape = \"ellipse\";\n    }\n    return shape;\n  }\n\n  // TODO: find a way to comment the meaning of shape => value mapping in final graph language.\n  _getValueColor(val: Value): string {\n    let shape = null;\n    if (val instanceof FunctionValue) {\n      shape = \"red\";\n    } else if (val instanceof AbstractValue) {\n      shape = \"green\";\n    } else if (val instanceof ProxyValue) {\n      shape = \"orange\";\n    } else if (val instanceof SymbolValue) {\n      shape = \"yellow\";\n    } else if (val instanceof ObjectValue) {\n      shape = \"#3BB9FF\"; // light blue\n    } else {\n      shape = \"grey\";\n    }\n    return shape;\n  }\n\n  generateResult(heapGraphFormat: \"DotLanguage\" | \"VISJS\"): string {\n    return heapGraphFormat === \"DotLanguage\"\n      ? this._generateDotGraphData(this._visitedValues, this._edges)\n      : this._generateVisJSGraphData(this._visitedValues, this._edges);\n  }\n}\n"]}