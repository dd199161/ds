"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTypeNameOrTemplate = parseTypeNameOrTemplate;
exports.createAbstract = createAbstract;

var _index = require("../../values/index.js");

var _builder = require("../../utils/builder.js");

var _builder2 = _interopRequireDefault(_builder);

var _index2 = require("../../domains/index.js");

var _Error = require("../ecma262/Error.js");

var _singletons = require("../../singletons.js");

var _AbstractObjectValue = require("../../values/AbstractObjectValue");

var _AbstractObjectValue2 = _interopRequireDefault(_AbstractObjectValue);

var _errors = require("../../errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

var throwTemplateSrc = "(function(){throw new global.Error('abstract value defined at ' + A);})()";
var throwTemplate = (0, _builder2.default)(throwTemplateSrc);

function parseTypeNameOrTemplate(realm, typeNameOrTemplate) {
  if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof _index.UndefinedValue) {
    return { type: _index.Value, template: undefined };
  } else if (typeof typeNameOrTemplate === "string") {
    var _type = _index.Value.getTypeFromName(typeNameOrTemplate);
    if (_type === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown typeNameOrTemplate");
    }
    return { type: _type, template: undefined };
  } else if (typeNameOrTemplate instanceof _index.StringValue) {
    var typeNameString = _singletons.To.ToStringPartial(realm, typeNameOrTemplate);
    var _type2 = _index.Value.getTypeFromName(typeNameString);
    if (_type2 === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown typeNameOrTemplate");
    }
    return { type: _type2, template: undefined };
  } else if (typeNameOrTemplate instanceof _index.FunctionValue) {
    return { type: _index.FunctionValue, template: typeNameOrTemplate };
  } else if (typeNameOrTemplate instanceof _index.ObjectValue) {
    return { type: _index.ObjectValue, template: typeNameOrTemplate };
  } else {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "typeNameOrTemplate has unsupported type");
  }
}

function createAbstract(realm, typeNameOrTemplate, name) {
  if (!realm.useAbstractInterpretation) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
  }

  var _parseTypeNameOrTempl = parseTypeNameOrTemplate(realm, typeNameOrTemplate),
      type = _parseTypeNameOrTempl.type,
      template = _parseTypeNameOrTempl.template;

  var result = void 0;
  var locString = void 0,
      loc = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = realm.contextStack.slice().reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var executionContext = _step.value;

      var caller = executionContext.caller;
      loc = executionContext.loc;
      locString = (0, _Error.describeLocation)(realm, caller ? caller.function : undefined, caller ? caller.lexicalEnvironment : undefined, loc);
      if (locString !== undefined) break;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (!name) {
    var locVal = new _index.StringValue(realm, locString || "(unknown location)");
    var kind = "__abstract_" + realm.objectCount++; // need not be an object, but must be unique
    result = _index.AbstractValue.createFromTemplate(realm, throwTemplate, type, [locVal], kind);
  } else {
    var _kind = "__abstract_" + name;
    if (!realm.isNameStringUnique(name)) {
      var error = new _errors.CompilerDiagnostic("An abstract value with the same name exists", loc, "PP0019", "FatalError");
      realm.handleError(error);
      throw new _errors.FatalError();
    } else {
      realm.saveNameString(name);
    }
    result = _index.AbstractValue.createFromTemplate(realm, (0, _builder2.default)(name), type, [], _kind);
    result.intrinsicName = name;
  }

  if (template) result.values = new _index2.ValuesDomain(new Set([template]));
  if (template && !(template instanceof _index.FunctionValue)) {
    // why exclude functions?
    template.makePartial();
    if (name) realm.rebuildNestedProperties(result, name);
  }

  for (var _len = arguments.length, additionalValues = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    additionalValues[_key - 3] = arguments[_key];
  }

  if (additionalValues.length > 0) result = _index.AbstractValue.createAbstractConcreteUnion.apply(_index.AbstractValue, [realm, result].concat(additionalValues));
  return result;
}
//# sourceMappingURL=utils.js.map