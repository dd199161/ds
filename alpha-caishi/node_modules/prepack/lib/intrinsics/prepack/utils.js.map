{"version":3,"sources":["../../../src/intrinsics/prepack/utils.js"],"names":["parseTypeNameOrTemplate","createAbstract","throwTemplateSrc","throwTemplate","realm","typeNameOrTemplate","undefined","type","template","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","typeNameString","ToStringPartial","name","useAbstractInterpretation","result","locString","loc","contextStack","slice","reverse","executionContext","caller","function","lexicalEnvironment","locVal","kind","objectCount","createFromTemplate","isNameStringUnique","error","handleError","saveNameString","intrinsicName","values","Set","makePartial","rebuildNestedProperties","additionalValues","length","createAbstractConcreteUnion"],"mappings":"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","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  Value,\n  AbstractValue,\n  ConcreteValue,\n  FunctionValue,\n  StringValue,\n  ObjectValue,\n  UndefinedValue,\n} from \"../../values/index.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\nimport { ValuesDomain } from \"../../domains/index.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\nimport { To } from \"../../singletons.js\";\nimport AbstractObjectValue from \"../../values/AbstractObjectValue\";\nimport { CompilerDiagnostic, FatalError } from \"../../errors.js\";\n\nconst throwTemplateSrc = \"(function(){throw new global.Error('abstract value defined at ' + A);})()\";\nconst throwTemplate = buildExpressionTemplate(throwTemplateSrc);\n\nexport function parseTypeNameOrTemplate(\n  realm: Realm,\n  typeNameOrTemplate: void | Value | string\n): { type: typeof Value, template: void | ObjectValue } {\n  if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n    return { type: Value, template: undefined };\n  } else if (typeof typeNameOrTemplate === \"string\") {\n    let type = Value.getTypeFromName(typeNameOrTemplate);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof StringValue) {\n    let typeNameString = To.ToStringPartial(realm, typeNameOrTemplate);\n    let type = Value.getTypeFromName(typeNameString);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof FunctionValue) {\n    return { type: FunctionValue, template: typeNameOrTemplate };\n  } else if (typeNameOrTemplate instanceof ObjectValue) {\n    return { type: ObjectValue, template: typeNameOrTemplate };\n  } else {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n  }\n}\n\nexport function createAbstract(\n  realm: Realm,\n  typeNameOrTemplate?: Value | string,\n  name?: string,\n  ...additionalValues: Array<ConcreteValue>\n): AbstractValue | AbstractObjectValue {\n  if (!realm.useAbstractInterpretation) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n  }\n\n  let { type, template } = parseTypeNameOrTemplate(realm, typeNameOrTemplate);\n\n  let result;\n  let locString,\n    loc = null;\n  for (let executionContext of realm.contextStack.slice().reverse()) {\n    let caller = executionContext.caller;\n    loc = executionContext.loc;\n    locString = describeLocation(\n      realm,\n      caller ? caller.function : undefined,\n      caller ? caller.lexicalEnvironment : undefined,\n      loc\n    );\n    if (locString !== undefined) break;\n  }\n  if (!name) {\n    let locVal = new StringValue(realm, locString || \"(unknown location)\");\n    let kind = \"__abstract_\" + realm.objectCount++; // need not be an object, but must be unique\n    result = AbstractValue.createFromTemplate(realm, throwTemplate, type, [locVal], kind);\n  } else {\n    let kind = \"__abstract_\" + name;\n    if (!realm.isNameStringUnique(name)) {\n      let error = new CompilerDiagnostic(\"An abstract value with the same name exists\", loc, \"PP0019\", \"FatalError\");\n      realm.handleError(error);\n      throw new FatalError();\n    } else {\n      realm.saveNameString(name);\n    }\n    result = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), type, [], kind);\n    result.intrinsicName = name;\n  }\n\n  if (template) result.values = new ValuesDomain(new Set([template]));\n  if (template && !(template instanceof FunctionValue)) {\n    // why exclude functions?\n    template.makePartial();\n    if (name) realm.rebuildNestedProperties(result, name);\n  }\n\n  if (additionalValues.length > 0)\n    result = AbstractValue.createAbstractConcreteUnion(realm, result, ...additionalValues);\n  return result;\n}\n"]}