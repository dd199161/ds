{"version":3,"sources":["../../../src/intrinsics/fb-www/react-mocks.js"],"names":["createMockReact","reactCode","reactAst","plugins","realm","reactRequireName","reactFactory","GetValue","$GlobalEnv","evaluate","currentOwner","react","intrinsics","ObjectPrototype","factory","$Call","undefined","reactValue","intrinsicName","reactComponentValue","reactPureComponentValue","$FunctionKind","reactComponentPrototypeValue","reactPureComponentPrototypeValue","reactCloneElementValue","reactCreateElementValue","reactIsValidElementValue","reactChildrenValue"],"mappings":";;;;;QAiSgBA,e,GAAAA,e;;AArRhB;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA;AACA,IAAIC,utOAAJ,C,CApBA;;;;;;;;;AA+RA,IAAIC,WAAW,8BAAgBD,SAAhB,EAA2B,EAAEE,SAAS,CAAC,MAAD,CAAX,EAA3B,CAAf;;AAEO,SAASH,eAAT,CAAyBI,KAAzB,EAAuCC,gBAAvC,EAA8E;AACnF,MAAIC,eAAe,wBAAYC,QAAZ,CAAqBH,KAArB,EAA4BA,MAAMI,UAAN,CAAiBC,QAAjB,CAA0BP,QAA1B,EAAoC,KAApC,CAA5B,CAAnB;AACA,2BAAUI,4DAAV;;AAEA,MAAII,eAAgBN,MAAMO,KAAN,CAAYD,YAAZ,GAA2B,uBAC7CN,KAD6C,EAE7CA,MAAMQ,UAAN,CAAiBC,eAF4B,EAG7C,cAH6C,CAA/C;AAKA;AACA,MAAIC,UAAUR,aAAaS,KAA3B;AACA,2BAAUD,YAAYE,SAAtB;AACA,MAAIC,aAAaH,QAAQV,MAAMQ,UAAN,CAAiBI,SAAzB,EAAoC,CACnD,2BAAe,eAAf,EAAgCZ,KAAhC,CADmD,EAEnD,2BAAe,cAAf,EAA+BA,KAA/B,CAFmD,EAGnDM,YAHmD,CAApC,CAAjB;AAKAO,aAAWC,aAAX,kBAAuCb,gBAAvC;AACA,2BAAUY,wCAAV;;AAEA,MAAIE,sBAAsB,iBAAIf,KAAJ,EAAWa,UAAX,EAAuB,WAAvB,CAA1B;AACAE,sBAAoBD,aAApB,kBAAgDb,gBAAhD;AACA,2BAAUc,6DAAV;AACA,MAAIC,0BAA0B,iBAAIhB,KAAJ,EAAWa,UAAX,EAAuB,eAAvB,CAA9B;AACAG,0BAAwBF,aAAxB,kBAAoDb,gBAApD;AACA,2BAAUe,iEAAV;AACAD,sBAAoBE,aAApB,GAAoC,QAApC;AACA,2BAAUF,iDAAV;;AAEA,MAAIG,+BAA+B,iBAAIlB,KAAJ,EAAWe,mBAAX,EAAgC,WAAhC,CAAnC;AACAG,+BAA6BJ,aAA7B,kBAAyDb,gBAAzD;;AAEA,MAAIkB,mCAAmC,iBAAInB,KAAJ,EAAWgB,uBAAX,EAAoC,WAApC,CAAvC;AACAG,mCAAiCL,aAAjC,kBAA6Db,gBAA7D;;AAEA,MAAImB,yBAAyB,iBAAIpB,KAAJ,EAAWa,UAAX,EAAuB,cAAvB,CAA7B;AACAO,yBAAuBN,aAAvB,kBAAmDb,gBAAnD;;AAEA,MAAIoB,0BAA0B,iBAAIrB,KAAJ,EAAWa,UAAX,EAAuB,eAAvB,CAA9B;AACAQ,0BAAwBP,aAAxB,kBAAoDb,gBAApD;;AAEA,MAAIqB,2BAA2B,iBAAItB,KAAJ,EAAWa,UAAX,EAAuB,gBAAvB,CAA/B;AACAS,2BAAyBR,aAAzB,kBAAqDb,gBAArD;;AAEA,MAAIsB,qBAAqB,iBAAIvB,KAAJ,EAAWa,UAAX,EAAuB,UAAvB,CAAzB;AACAU,qBAAmBT,aAAnB,kBAA+Cb,gBAA/C;;AAEA,SAAOY,UAAP;AACD","file":"react-mocks.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { parseExpression } from \"babylon\";\nimport { ObjectValue, ECMAScriptFunctionValue, ECMAScriptSourceFunctionValue } from \"../../values/index.js\";\nimport { Get } from \"../../methods/index.js\";\nimport { Environment } from \"../../singletons.js\";\nimport { getReactSymbol } from \"../../react/utils.js\";\nimport invariant from \"../../invariant\";\n\n// most of the code here was taken from https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js\nlet reactCode = `\n  function createReact(REACT_ELEMENT_TYPE, REACT_SYMBOL_TYPE, ReactCurrentOwner) {\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true,\n    };\n\n    var ReactElement = function(type, key, ref, self, source, owner, props) {\n      return {\n        // This tag allow us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n    \n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n    \n        // Record the component responsible for creating this element.\n        _owner: owner,\n      };\n    };\n\n    function hasValidRef(config) {\n      return config.ref !== undefined;\n    }\n    \n    function hasValidKey(config) {\n      return config.key !== undefined;\n    }\n\n    class Component {\n      constructor(props, context) {\n        this.props = props;\n        this.context = context;\n        this.refs = {};\n      }\n      getChildContext() {}\n    }\n\n    Component.prototype.isReactComponent = {};\n\n    class PureComponent {\n      constructor(props, context) {\n        this.props = props;\n        this.context = context;\n        this.refs = {};\n      }\n    }\n\n    PureComponent.prototype.isReactComponent = {};\n    PureComponent.prototype.isPureReactComponent = true;\n\n    function forEachChildren() {\n      throw new Error(\"TODO: React.Children.forEach is not yet supported\");\n    }\n\n    function mapChildren() {\n      throw new Error(\"TODO: React.Children.map is not yet supported\");\n    }\n\n    function countChildren() {\n      throw new Error(\"TODO: React.Children.count is not yet supported\");\n    }\n\n    function onlyChild() {\n      throw new Error(\"TODO: React.Children.only is not yet supported\");\n    }\n\n    function toArray() {\n      throw new Error(\"TODO: React.Children.toArray is not yet supported\");\n    }\n\n    function createElement(type, config, children) {\n      var propName;\n\n      // Reserved names are extracted\n      var props = {};\n\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n        }\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n    \n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source;\n        // Remaining properties are added to a new props object\n        for (propName in config) {\n          if (\n            hasOwnProperty.call(config, propName) &&\n            !RESERVED_PROPS.hasOwnProperty(propName)\n          ) {\n            props[propName] = config[propName];\n          }\n        }\n      }\n\n      // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n    \n      // Resolve default props\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n    \n      return ReactElement(\n        type,\n        key,\n        ref,\n        self,\n        source,\n        ReactCurrentOwner.current,\n        props,\n      );\n    }\n\n    function cloneElement(element, config, children) {\n      var propName;\n      \n      // Original props are copied\n      var props = Object.assign({}, element.props);\n    \n      // Reserved names are extracted\n      var key = element.key;\n      var ref = element.ref;\n      // Self is preserved since the owner is preserved.\n      var self = element._self;\n      // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n      var source = element._source;\n    \n      // Owner will be preserved, unless ref is overridden\n      var owner = element._owner;\n    \n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n    \n        // Remaining properties override existing props\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (\n            hasOwnProperty.call(config, propName) &&\n            !RESERVED_PROPS.hasOwnProperty(propName)\n          ) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      }\n    \n      // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n    \n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n\n    function isValidElement(object) {\n      return (\n        typeof object === 'object' &&\n        object !== null &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n\n    function shim() {\n\n    }\n    shim.isRequired = shim;\n\n    function getShim() {\n      return shim;\n    };\n\n    var ReactPropTypes = {\n      array: shim,\n      bool: shim,\n      func: shim,\n      number: shim,\n      object: shim,\n      string: shim,\n      symbol: shim,\n  \n      any: shim,\n      arrayOf: getShim,\n      element: shim,\n      instanceOf: getShim,\n      node: shim,\n      objectOf: getShim,\n      oneOf: getShim,\n      oneOfType: getShim,\n      shape: getShim,\n      exact: getShim\n    };\n\n    ReactPropTypes.checkPropTypes = shim;\n    ReactPropTypes.PropTypes = ReactPropTypes;\n\n    return {\n      Children: {\n        forEach: forEachChildren,\n        map: mapChildren,\n        count: countChildren,\n        only: onlyChild,\n        toArray,\n      },\n      Component,\n      PureComponent,\n      Fragment: REACT_SYMBOL_TYPE,\n      createElement,\n      cloneElement,\n      isValidElement,\n      version: \"16.2.0\",\n      PropTypes: ReactPropTypes,\n    };\n  }\n`;\nlet reactAst = parseExpression(reactCode, { plugins: [\"flow\"] });\n\nexport function createMockReact(realm: Realm, reactRequireName: string): ObjectValue {\n  let reactFactory = Environment.GetValue(realm, realm.$GlobalEnv.evaluate(reactAst, false));\n  invariant(reactFactory instanceof ECMAScriptSourceFunctionValue);\n\n  let currentOwner = (realm.react.currentOwner = new ObjectValue(\n    realm,\n    realm.intrinsics.ObjectPrototype,\n    \"currentOwner\"\n  ));\n  // this is to get around Flow getting confused\n  let factory = reactFactory.$Call;\n  invariant(factory !== undefined);\n  let reactValue = factory(realm.intrinsics.undefined, [\n    getReactSymbol(\"react.element\", realm),\n    getReactSymbol(\"react.symbol\", realm),\n    currentOwner,\n  ]);\n  reactValue.intrinsicName = `require(\"${reactRequireName}\")`;\n  invariant(reactValue instanceof ObjectValue);\n\n  let reactComponentValue = Get(realm, reactValue, \"Component\");\n  reactComponentValue.intrinsicName = `require(\"${reactRequireName}\").Component`;\n  invariant(reactComponentValue instanceof ECMAScriptFunctionValue);\n  let reactPureComponentValue = Get(realm, reactValue, \"PureComponent\");\n  reactPureComponentValue.intrinsicName = `require(\"${reactRequireName}\").PureComponent`;\n  invariant(reactPureComponentValue instanceof ECMAScriptFunctionValue);\n  reactComponentValue.$FunctionKind = \"normal\";\n  invariant(reactComponentValue instanceof ObjectValue);\n\n  let reactComponentPrototypeValue = Get(realm, reactComponentValue, \"prototype\");\n  reactComponentPrototypeValue.intrinsicName = `require(\"${reactRequireName}\").Component.prototype`;\n\n  let reactPureComponentPrototypeValue = Get(realm, reactPureComponentValue, \"prototype\");\n  reactPureComponentPrototypeValue.intrinsicName = `require(\"${reactRequireName}\").PureComponent.prototype`;\n\n  let reactCloneElementValue = Get(realm, reactValue, \"cloneElement\");\n  reactCloneElementValue.intrinsicName = `require(\"${reactRequireName}\").cloneElement`;\n\n  let reactCreateElementValue = Get(realm, reactValue, \"createElement\");\n  reactCreateElementValue.intrinsicName = `require(\"${reactRequireName}\").createElement`;\n\n  let reactIsValidElementValue = Get(realm, reactValue, \"isValidElement\");\n  reactIsValidElementValue.intrinsicName = `require(\"${reactRequireName}\").isValidElement`;\n\n  let reactChildrenValue = Get(realm, reactValue, \"Children\");\n  reactChildrenValue.intrinsicName = `require(\"${reactRequireName}\").Children`;\n\n  return reactValue;\n}\n"]}