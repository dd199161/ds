{"version":3,"sources":["../../src/utils/leak.js"],"names":["t","visitName","path","state","name","read","write","scope","hasBinding","unboundReads","add","unboundWrites","ignorePath","parent","isLabeledStatement","isBreakStatement","isContinueStatement","LeakedClosureRefVisitor","ReferencedIdentifier","innerName","node","doesRead","operator","getBindingIdentifiers","getLeakedFunctionInfo","value","constructor","functionInfo","Set","formalParameters","$FormalParameters","code","$ECMAScriptCode","file","program","expressionStatement","functionExpression","ObjectValueLeakingVisitor","objectsTrackedForLeaks","visitedValues","val","has","binding","desc","descriptor","undefined","visitDescriptor","obj","kind","symbols","propertyBindingValue","visitObjectProperty","properties","unknownProperty","visitObjectPropertiesWithComputedNames","visitObjectPrototype","isLeakedObject","leak","proto","$Prototype","visitValue","absVal","args","length","cond","P","V","earlier_props","consequent","alternate","get","set","record","remainingLeakedBindings","bindings","Object","keys","bindingName","isRead","delete","isWritten","getKind","entries","$MapData","$WeakMapData","len","i","entry","key","$Key","$Value","$SetData","$WeakSetData","visitObjectProperties","$BoundTargetFunction","$BoundThis","$BoundArguments","boundArg","environment","$Environment","environmentRecord","object","visitDeclarativeEnvironmentRecordBinding","fn","$FunctionObject","dateValue","$DateValue","buf","$ViewedArrayBuffer","visitValueMap","visitValueSet","$ParameterMap","$ProxyTarget","$ProxyHandler","n","mustVisit","visitAbstractValue","isIntrinsic","visitValueProxy","visitValueFunction","originalConstructor","visitValueObject","ensureFrozenValue","realm","loc","diag","currentLocation","handleError","LeakImplementation","createdObjectsTrackedForLeaks","visitor"],"mappings":"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","file":"leak.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, ObjectKind } from \"../types.js\";\nimport {\n  leakBinding,\n  DeclarativeEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  ObjectEnvironmentRecord,\n  GlobalEnvironmentRecord,\n} from \"../environment.js\";\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  AbstractValue,\n  EmptyValue,\n  FunctionValue,\n  PrimitiveValue,\n  Value,\n  ObjectValue,\n  NativeFunctionValue,\n  ECMAScriptSourceFunctionValue,\n} from \"../values/index.js\";\nimport { TestIntegrityLevel } from \"../methods/index.js\";\nimport * as t from \"babel-types\";\nimport traverse from \"babel-traverse\";\nimport type { BabelTraversePath } from \"babel-traverse\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\ntype LeakedFunctionInfo = {\n  unboundReads: Set<string>,\n  unboundWrites: Set<string>,\n};\n\nfunction visitName(path, state, name, read, write) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  if (read) state.unboundReads.add(name);\n  if (write) state.unboundWrites.add(name);\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\nlet LeakedClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: LeakedFunctionInfo) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      return;\n    }\n    visitName(path, state, innerName, true, false);\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: LeakedFunctionInfo) {\n    let doesRead = path.node.operator !== \"=\";\n    for (let name in path.getBindingIdentifiers()) {\n      visitName(path, state, name, doesRead, true);\n    }\n  },\n};\n\nfunction getLeakedFunctionInfo(value: FunctionValue) {\n  // TODO: This should really be cached on a per AST basis in case we have\n  // many uses of the same closure. It should ideally share this cache\n  // and data with ResidualHeapVisitor.\n  invariant(value instanceof ECMAScriptSourceFunctionValue);\n  invariant(value.constructor === ECMAScriptSourceFunctionValue);\n  let functionInfo = {\n    unboundReads: new Set(),\n    unboundWrites: new Set(),\n  };\n  let formalParameters = value.$FormalParameters;\n  invariant(formalParameters != null);\n  let code = value.$ECMAScriptCode;\n  invariant(code != null);\n\n  traverse(\n    t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n    LeakedClosureRefVisitor,\n    null,\n    functionInfo\n  );\n  return functionInfo;\n}\n\nclass ObjectValueLeakingVisitor {\n  // ObjectValues to visit if they're reachable.\n  objectsTrackedForLeaks: Set<ObjectValue>;\n  // Values that has been visited.\n  visitedValues: Set<Value>;\n\n  constructor(objectsTrackedForLeaks: Set<ObjectValue>) {\n    this.objectsTrackedForLeaks = objectsTrackedForLeaks;\n    this.visitedValues = new Set();\n  }\n\n  mustVisit(val: Value): boolean {\n    if (val instanceof ObjectValue) {\n      // For Objects we only need to visit it if it is tracked\n      // as a newly created object that might still be mutated.\n      // Abstract values gets their arguments visited.\n      if (!this.objectsTrackedForLeaks.has(val)) return false;\n    }\n    if (this.visitedValues.has(val)) return false;\n    this.visitedValues.add(val);\n    return true;\n  }\n\n  visitObjectProperty(binding: PropertyBinding) {\n    let desc = binding.descriptor;\n    if (desc === undefined) return; //deleted\n    this.visitDescriptor(desc);\n  }\n\n  visitObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n    // visit symbol properties\n    for (let [, propertyBindingValue] of obj.symbols) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // visit string properties\n    for (let [, propertyBindingValue] of obj.properties) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.visitObjectPropertiesWithComputedNames(val);\n      }\n    }\n\n    // prototype\n    this.visitObjectPrototype(obj);\n\n    // if this object wasn't already leaked, we need mark it as leaked\n    // so that any mutation and property access get tracked after this.\n    if (!obj.isLeakedObject()) {\n      obj.leak();\n    }\n  }\n\n  visitObjectPrototype(obj: ObjectValue) {\n    let proto = obj.$Prototype;\n    this.visitValue(proto);\n  }\n\n  visitObjectPropertiesWithComputedNames(absVal: AbstractValue): void {\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);\n      this.visitValue(P);\n      this.visitValue(V);\n    } else {\n      // conditional assignment\n      this.visitValue(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      this.visitObjectPropertiesWithComputedNames(consequent);\n      this.visitObjectPropertiesWithComputedNames(alternate);\n    }\n  }\n\n  visitDescriptor(desc: Descriptor): void {\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) this.visitValue(desc.value);\n    if (desc.get !== undefined) this.visitValue(desc.get);\n    if (desc.set !== undefined) this.visitValue(desc.set);\n  }\n\n  visitDeclarativeEnvironmentRecordBinding(\n    record: DeclarativeEnvironmentRecord,\n    remainingLeakedBindings: LeakedFunctionInfo\n  ) {\n    let bindings = record.bindings;\n    for (let bindingName of Object.keys(bindings)) {\n      let binding = bindings[bindingName];\n      // Check if this binding is referenced, and if so delete it from the set.\n      let isRead = remainingLeakedBindings.unboundReads.delete(bindingName);\n      let isWritten = remainingLeakedBindings.unboundWrites.delete(bindingName);\n      if (isRead) {\n        // If this binding can be read from the closure, its value has now leaked.\n        let value = binding.value;\n        if (value) {\n          this.visitValue(value);\n        }\n      }\n      if (isWritten || isRead) {\n        // If this binding could have been mutated from the closure, then the\n        // binding itself has now leaked, but not necessarily the value in it.\n        // TODO: We could tag a leaked binding as read and/or write. That way\n        // we don't have to leak values written to this binding if only writes\n        // have leaked. We also don't have to leak reads from this binding\n        // if it is only read from.\n        leakBinding(binding);\n      }\n    }\n  }\n\n  visitValueMap(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      this.visitValue(key);\n      this.visitValue(value);\n    }\n  }\n\n  visitValueSet(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      this.visitValue(entry);\n    }\n  }\n\n  visitValueFunction(val: FunctionValue): void {\n    if (val.isLeakedObject()) {\n      return;\n    }\n    this.visitObjectProperties(val);\n\n    if (val instanceof BoundFunctionValue) {\n      this.visitValue(val.$BoundTargetFunction);\n      this.visitValue(val.$BoundThis);\n      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);\n      return;\n    }\n\n    invariant(\n      !(val instanceof NativeFunctionValue),\n      \"all native function values should have already been created outside this pure function\"\n    );\n\n    let remainingLeakedBindings = getLeakedFunctionInfo(val);\n\n    let environment = val.$Environment.parent;\n    while (environment) {\n      let record = environment.environmentRecord;\n      if (record instanceof ObjectEnvironmentRecord) {\n        this.visitValue(record.object);\n        continue;\n      }\n\n      invariant(\n        !(record instanceof GlobalEnvironmentRecord),\n        \"we should never reach the global scope because it is never newly created in a pure function.\"\n      );\n      invariant(record instanceof DeclarativeEnvironmentRecord);\n\n      this.visitDeclarativeEnvironmentRecordBinding(record, remainingLeakedBindings);\n\n      if (record instanceof FunctionEnvironmentRecord) {\n        // If this is a function environment, which is not tracked for leaks,\n        // we can bail out because its bindings should not be mutated in a\n        // pure function.\n        let fn = record.$FunctionObject;\n        if (!this.objectsTrackedForLeaks.has(fn)) {\n          break;\n        }\n      }\n      environment = environment.parent;\n    }\n  }\n\n  visitValueObject(val: ObjectValue): void {\n    if (val.isLeakedObject()) {\n      return;\n    }\n\n    let kind = val.getKind();\n    this.visitObjectProperties(val, kind);\n\n    switch (kind) {\n      case \"RegExp\":\n      case \"Number\":\n      case \"String\":\n      case \"Boolean\":\n      case \"ReactElement\":\n      case \"ArrayBuffer\":\n        return;\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        this.visitValue(dateValue);\n        return;\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        let buf = val.$ViewedArrayBuffer;\n        invariant(buf !== undefined);\n        this.visitValue(buf);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        this.visitValueMap(val);\n        return;\n      case \"Set\":\n      case \"WeakSet\":\n        this.visitValueSet(val);\n        return;\n      default:\n        invariant(kind === \"Object\", `Object of kind ${kind} is not supported in calls to abstract functions.`);\n        invariant(\n          this.$ParameterMap === undefined,\n          `Arguments object is not supported in calls to abstract functions.`\n        );\n        return;\n    }\n  }\n\n  visitValueProxy(val: ProxyValue): void {\n    this.visitValue(val.$ProxyTarget);\n    this.visitValue(val.$ProxyHandler);\n  }\n\n  visitAbstractValue(val: AbstractValue): void {\n    for (let i = 0, n = val.args.length; i < n; i++) {\n      this.visitValue(val.args[i]);\n    }\n  }\n\n  visitValue(val: Value): void {\n    if (val instanceof AbstractValue) {\n      if (this.mustVisit(val)) this.visitAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      // All intrinsic values exist from the beginning of time...\n      // ...except for a few that come into existance as templates for abstract objects (TODO #882).\n      this.mustVisit(val);\n    } else if (val instanceof EmptyValue) {\n      this.mustVisit(val);\n    } else if (val instanceof PrimitiveValue) {\n      this.mustVisit(val);\n    } else if (val instanceof ProxyValue) {\n      if (this.mustVisit(val)) this.visitValueProxy(val);\n    } else if (val instanceof FunctionValue) {\n      invariant(val instanceof FunctionValue);\n      if (this.mustVisit(val)) this.visitValueFunction(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n      if (val.originalConstructor !== undefined) {\n        invariant(val instanceof ObjectValue);\n        if (this.mustVisit(val)) this.visitValueObject(val);\n      } else {\n        if (this.mustVisit(val)) this.visitValueObject(val);\n      }\n    }\n  }\n}\n\nfunction ensureFrozenValue(realm, value, loc) {\n  // TODO: This should really check if it is recursively immutability.\n  if (value instanceof ObjectValue && !TestIntegrityLevel(realm, value, \"frozen\")) {\n    let diag = new CompilerDiagnostic(\n      \"Unfrozen object leaked before end of global code\",\n      loc || realm.currentLocation,\n      \"PP0017\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(diag) !== \"Recover\") throw new FatalError();\n  }\n}\n\n// Ensure that a value is immutable. If it is not, set all its properties to abstract values\n// and all reachable bindings to abstract values.\nexport class LeakImplementation {\n  leakValue(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation) {\n    let objectsTrackedForLeaks = realm.createdObjectsTrackedForLeaks;\n    if (objectsTrackedForLeaks === undefined) {\n      // We're not tracking a pure function. That means that we would track\n      // everything as leaked. We'll assume that any object argument\n      // is invalid unless it's frozen.\n      ensureFrozenValue(realm, value, loc);\n    } else {\n      // If we're tracking a pure function, we can assume that only newly\n      // created objects and bindings, within it, are mutable. Any other\n      // object can safely be assumed to be deeply immutable as far as this\n      // pure function is concerned. However, any mutable object needs to\n      // be tainted as possibly having changed to anything.\n      let visitor = new ObjectValueLeakingVisitor(objectsTrackedForLeaks);\n      visitor.visitValue(value);\n    }\n  }\n}\n"]}