{"version":3,"sources":["../../src/utils/generator.js"],"names":["base62","t","serializeBody","generator","context","statements","serializeGenerator","length","type","blockStatement","Generator","realm","name","useAbstractInterpretation","realmPreludeGenerator","preludeGenerator","parent","_entries","id","nextGeneratorId","_name","key","canBeIdentifier","index","Number","parseInt","toString","numericLiteral","keyIsAscii","test","isValidIdentifier","identifier","stringLiteral","values","_addEntry","args","value","declaredGlobals","add","emitGlobalAssignment","strictMode","buildNode","valueNode","expressionStatement","assignmentExpression","globalReference","unaryExpression","binding","serializeBinding","object","refuseSerialization","propName","getAsPropertyNameExpression","objectNode","memberExpression","isIdentifier","desc","isDescChanged","enumerable","configurable","writable","descValue","emitPropertyAssignment","Object","assign","$Realm","intrinsics","undefined","get","set","_","emitDefinePropertyBody","createCallee","callExpression","method","emitCall","map","v","body","testId","intrinsicName","block","doWhileStatement","dependencies","violationConditionFn","appendLastToInvariantFn","omitInvariants","nodes","throwString","last","pop","binaryExpression","condition","throwblock","throwStatement","newExpression","ifStatement","types","kind","derive","buildNode_","Function","o","lh","sourceObject","targetObject","boundName","obj","tgt","src","obj1","tgt1","src1","forInStatement","optionalArgs","nameGenerator","generate","derivedIds","options","Constructor","isTypeCompatibleWith","getType","res","isPure","declared","variableDeclaration","variableDeclarator","skipInvariant","typeofString","emitInvariant","logicalExpression","node","entry","canOmit","boundArg","i","serializeValue","emit","declare","callbacks","canSkip","recordDelayedEntry","recordDeclaration","visitValues","dependency","visitGenerator","visitEntry","push","other","leadingComment","empty","statement","leadingComments","generator1","generator2","statements1","statements2","concat","joinCondition","cond","block1","block2","replaceInvalidCharactersWithUnderscore","string","replace","NameGenerator","forbiddenNames","debugNames","uniqueSuffix","prefix","uidCounter","debugSuffix","encode","has","PreludeGenerator","prelude","Map","memoizedRefs","Set","usesThis","str","split","memoizeReference","thisExpression","reduce","prop","globalScope","keyNode","ref","init","includes","lastIndexOf","substr"],"mappings":"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","file":"generator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { Binding } from \"../environment.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport type { AbstractValueBuildNodeFunction } from \"../values/AbstractValue.js\";\nimport type { Descriptor } from \"../types.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as base62 from \"base62\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeIdentifier,\n  BabelNodeThisExpression,\n  BabelNodeStatement,\n  BabelNodeMemberExpression,\n  BabelNodeVariableDeclaration,\n  BabelNodeBlockStatement,\n} from \"babel-types\";\nimport { nullExpression } from \"./internalizer.js\";\n\nexport type SerializationContext = {\n  serializeValue: Value => BabelNodeExpression,\n  serializeBinding: Binding => BabelNodeIdentifier | BabelNodeMemberExpression,\n  serializeGenerator: Generator => Array<BabelNodeStatement>,\n  emitDefinePropertyBody: (ObjectValue, string | SymbolValue, Descriptor) => BabelNodeStatement,\n  emit: BabelNodeStatement => void,\n  canOmit: AbstractValue => boolean,\n  declare: AbstractValue => void,\n};\n\nexport type DerivedExpressionBuildNodeFunction = (\n  Array<BabelNodeExpression>,\n  SerializationContext\n) => BabelNodeExpression;\n\nexport type GeneratorBuildNodeFunction = (Array<BabelNodeExpression>, SerializationContext) => BabelNodeStatement;\n\nexport type GeneratorEntry = {\n  declared?: AbstractValue,\n  args: Array<Value>,\n  // If we're just trying to add roots for the serializer to notice, we don't need a buildNode.\n  buildNode?: GeneratorBuildNodeFunction,\n  dependencies?: Array<Generator>,\n  isPure?: boolean,\n};\n\nexport type VisitEntryCallbacks = {|\n  visitValues: (Array<Value>) => void,\n  visitGenerator: Generator => void,\n  canSkip: AbstractValue => boolean,\n  recordDeclaration: AbstractValue => void,\n  recordDelayedEntry: GeneratorEntry => void,\n|};\n\nfunction serializeBody(generator: Generator, context: SerializationContext): BabelNodeBlockStatement {\n  let statements = context.serializeGenerator(generator);\n  if (statements.length === 1 && statements[0].type === \"BlockStatement\") return (statements[0]: any);\n  return t.blockStatement(statements);\n}\n\nexport class Generator {\n  constructor(realm: Realm, name: void | string) {\n    invariant(realm.useAbstractInterpretation);\n    let realmPreludeGenerator = realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n    this.parent = realm.generator;\n    this.realm = realm;\n    this._entries = [];\n    this.id = realm.nextGeneratorId++;\n    this._name = name;\n  }\n\n  realm: Realm;\n  _entries: Array<GeneratorEntry>;\n  preludeGenerator: PreludeGenerator;\n  parent: void | Generator;\n  id: number;\n  _name: void | string;\n\n  getName(): string {\n    return this._name || `#${this.id}`;\n  }\n\n  getAsPropertyNameExpression(key: string, canBeIdentifier: boolean = true) {\n    // If key is a non-negative numeric string literal, parse it and set it as a numeric index instead.\n    let index = Number.parseInt(key, 10);\n    if (index >= 0 && index.toString() === key) {\n      return t.numericLiteral(index);\n    }\n\n    if (canBeIdentifier) {\n      // TODO #1020: revert this when Unicode identifiers are supported by all targetted JavaScript engines\n      let keyIsAscii = /^[\\u0000-\\u007f]*$/.test(key);\n      if (t.isValidIdentifier(key) && keyIsAscii) return t.identifier(key);\n    }\n\n    return t.stringLiteral(key);\n  }\n\n  getParent(): void | Generator {\n    return this.parent;\n  }\n\n  empty() {\n    return this._entries.length === 0;\n  }\n\n  // Will force the array of Values to be serialized but not emit anything for a buildNode\n  appendRoots(values: Array<Value>) {\n    this._addEntry({\n      args: values,\n    });\n  }\n\n  emitGlobalDeclaration(key: string, value: Value) {\n    this.preludeGenerator.declaredGlobals.add(key);\n    if (!(value instanceof UndefinedValue)) this.emitGlobalAssignment(key, value, true);\n  }\n\n  emitGlobalAssignment(key: string, value: Value, strictMode: boolean) {\n    this._addEntry({\n      args: [value],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, !strictMode), valueNode)\n        ),\n    });\n  }\n\n  emitGlobalDelete(key: string, strictMode: boolean) {\n    this._addEntry({\n      args: [],\n      buildNode: ([]) =>\n        t.expressionStatement(t.unaryExpression(\"delete\", this.preludeGenerator.globalReference(key, !strictMode))),\n    });\n  }\n\n  emitBindingAssignment(binding: Binding, value: Value) {\n    this._addEntry({\n      args: [value],\n      buildNode: ([valueNode], context) =>\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            (context.serializeBinding(binding): BabelNodeIdentifier | BabelNodeMemberExpression),\n            valueNode\n          )\n        ),\n    });\n  }\n\n  emitPropertyAssignment(object: ObjectValue, key: string, value: Value) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object, value],\n      buildNode: ([objectNode, valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)), valueNode)\n        ),\n    });\n  }\n\n  emitDefineProperty(object: ObjectValue, key: string, desc: Descriptor, isDescChanged: boolean = true) {\n    if (object.refuseSerialization) return;\n    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      this.emitPropertyAssignment(object, key, descValue);\n    } else {\n      desc = Object.assign({}, desc);\n      let descValue = desc.value || object.$Realm.intrinsics.undefined;\n      invariant(descValue instanceof Value);\n      this._addEntry({\n        args: [\n          object,\n          descValue,\n          desc.get || object.$Realm.intrinsics.undefined,\n          desc.set || object.$Realm.intrinsics.undefined,\n        ],\n        buildNode: (_, context: SerializationContext) => context.emitDefinePropertyBody(object, key, desc),\n      });\n    }\n  }\n\n  emitPropertyDelete(object: ObjectValue, key: string) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object],\n      buildNode: ([objectNode]) =>\n        t.expressionStatement(\n          t.unaryExpression(\"delete\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)))\n        ),\n    });\n  }\n\n  emitCall(createCallee: () => BabelNodeExpression, args: Array<Value>) {\n    this._addEntry({\n      args,\n      buildNode: values => t.expressionStatement(t.callExpression(createCallee(), [...values])),\n    });\n  }\n\n  emitConsoleLog(method: \"log\" | \"warn\" | \"error\", args: Array<string | ConcreteValue>) {\n    this.emitCall(\n      () => t.memberExpression(t.identifier(\"console\"), t.identifier(method)),\n      args.map(v => (typeof v === \"string\" ? new StringValue(this.realm, v) : v))\n    );\n  }\n\n  // test must be a temporal value, which means that it must have a defined intrinsicName\n  emitDoWhileStatement(test: AbstractValue, body: Generator) {\n    this._addEntry({\n      args: [],\n      buildNode: function([], context: SerializationContext) {\n        let testId = test.intrinsicName;\n        invariant(testId !== undefined);\n        let statements = context.serializeGenerator(body);\n        let block = t.blockStatement(statements);\n        return t.doWhileStatement(t.identifier(testId), block);\n      },\n      dependencies: [body],\n    });\n  }\n\n  emitInvariant(\n    args: Array<Value>,\n    violationConditionFn: (Array<BabelNodeExpression>) => BabelNodeExpression,\n    appendLastToInvariantFn?: BabelNodeExpression => BabelNodeExpression\n  ): void {\n    if (this.realm.omitInvariants) return;\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) => {\n        let throwString = t.stringLiteral(\"Prepack model invariant violation\");\n        if (appendLastToInvariantFn) {\n          let last = nodes.pop();\n          throwString = t.binaryExpression(\n            \"+\",\n            t.stringLiteral(\"Prepack model invariant violation: \"),\n            appendLastToInvariantFn(last)\n          );\n        }\n        let condition = violationConditionFn(nodes);\n        let throwblock = t.blockStatement([t.throwStatement(t.newExpression(t.identifier(\"Error\"), [throwString]))]);\n        return t.ifStatement(condition, throwblock);\n      },\n    });\n  }\n\n  emitCallAndCaptureResult(\n    types: TypesDomain,\n    values: ValuesDomain,\n    createCallee: () => BabelNodeExpression,\n    args: Array<Value>,\n    kind?: string\n  ): AbstractValue {\n    return this.derive(types, values, args, (nodes: any) => t.callExpression(createCallee(), nodes));\n  }\n\n  emitStatement(args: Array<Value>, buildNode_: (Array<BabelNodeExpression>) => BabelNodeStatement) {\n    this._addEntry({\n      args,\n      buildNode: buildNode_,\n    });\n  }\n\n  emitVoidExpression(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: AbstractValueBuildNodeFunction | BabelNodeExpression\n  ): UndefinedValue {\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) =>\n        t.expressionStatement(\n          (buildNode_: any) instanceof Function\n            ? ((buildNode_: any): AbstractValueBuildNodeFunction)(nodes)\n            : ((buildNode_: any): BabelNodeExpression)\n        ),\n    });\n    return this.realm.intrinsics.undefined;\n  }\n\n  emitForInStatement(\n    o: ObjectValue | AbstractObjectValue,\n    lh: BabelNodeVariableDeclaration,\n    sourceObject: ObjectValue,\n    targetObject: ObjectValue,\n    boundName: BabelNodeIdentifier\n  ) {\n    this._addEntry({\n      // duplicate args to ensure refcount > 1\n      args: [o, targetObject, sourceObject, targetObject, sourceObject],\n      buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {\n        return t.forInStatement(\n          lh,\n          obj,\n          t.blockStatement([\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                t.memberExpression(tgt, boundName, true),\n                t.memberExpression(src, boundName, true)\n              )\n            ),\n          ])\n        );\n      },\n    });\n  }\n\n  derive(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: DerivedExpressionBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| kind?: string, isPure?: boolean, skipInvariant?: boolean |}\n  ): AbstractValue {\n    invariant(buildNode_ instanceof Function || args.length === 0);\n    let id = t.identifier(this.preludeGenerator.nameGenerator.generate(\"derived\"));\n    this.preludeGenerator.derivedIds.set(id.name, args);\n    let options = {};\n    if (optionalArgs && optionalArgs.kind) options.kind = optionalArgs.kind;\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let res = new Constructor(this.realm, types, values, 0, [], id, options);\n    this._addEntry({\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: res,\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>, context: SerializationContext) => {\n        return t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            id,\n            (buildNode_: any) instanceof Function\n              ? ((buildNode_: any): DerivedExpressionBuildNodeFunction)(nodes, context)\n              : ((buildNode_: any): BabelNodeExpression)\n          ),\n        ]);\n      },\n    });\n    let type = types.getType();\n    res.intrinsicName = id.name;\n    if (optionalArgs && optionalArgs.skipInvariant) return res;\n    let typeofString;\n    if (type instanceof FunctionValue) typeofString = \"function\";\n    else if (type === UndefinedValue) invariant(false);\n    else if (type === NullValue) invariant(false);\n    else if (type === StringValue) typeofString = \"string\";\n    else if (type === BooleanValue) typeofString = \"boolean\";\n    else if (type === NumberValue) typeofString = \"number\";\n    else if (type === SymbolValue) typeofString = \"symbol\";\n    else if (type === ObjectValue) typeofString = \"object\";\n    if (typeofString !== undefined) {\n      // Verify that the types are as expected, a failure of this invariant\n      // should mean the model is wrong.\n      this.emitInvariant(\n        [res, res],\n        nodes => {\n          invariant(typeofString !== undefined);\n          let condition = t.binaryExpression(\n            \"!==\",\n            t.unaryExpression(\"typeof\", nodes[0]),\n            t.stringLiteral(typeofString)\n          );\n          if (typeofString === \"object\") {\n            condition = t.logicalExpression(\n              \"&&\",\n              condition,\n              t.binaryExpression(\"!==\", t.unaryExpression(\"typeof\", nodes[0]), t.stringLiteral(\"function\"))\n            );\n            condition = t.logicalExpression(\"||\", condition, t.binaryExpression(\"===\", nodes[0], nullExpression));\n          }\n          return condition;\n        },\n        node => node\n      );\n    }\n\n    return res;\n  }\n\n  serialize(context: SerializationContext) {\n    for (let entry of this._entries) {\n      if (!entry.isPure || !entry.declared || !context.canOmit(entry.declared)) {\n        let nodes = entry.args.map((boundArg, i) => context.serializeValue(boundArg));\n        if (entry.buildNode) {\n          let node = entry.buildNode(nodes, context);\n          if (node.type === \"BlockStatement\") {\n            let block: BabelNodeBlockStatement = (node: any);\n            let statements = block.body;\n            if (statements.length === 1) {\n              node = statements[0];\n            }\n          }\n          context.emit(node);\n        }\n        if (entry.declared !== undefined) context.declare(entry.declared);\n      }\n    }\n  }\n\n  visitEntry(entry: GeneratorEntry, callbacks: VisitEntryCallbacks) {\n    if (entry.isPure && entry.declared && callbacks.canSkip(entry.declared)) {\n      callbacks.recordDelayedEntry(entry);\n    } else {\n      if (entry.declared) callbacks.recordDeclaration(entry.declared);\n      callbacks.visitValues(entry.args);\n      if (entry.dependencies) for (let dependency of entry.dependencies) callbacks.visitGenerator(dependency);\n    }\n  }\n\n  visit(callbacks: VisitEntryCallbacks) {\n    for (let entry of this._entries) this.visitEntry(entry, callbacks);\n  }\n\n  _addEntry(entry: GeneratorEntry) {\n    this._entries.push(entry);\n  }\n\n  appendGenerator(other: Generator, leadingComment: string): void {\n    if (other.empty()) return;\n    this._addEntry({\n      args: [],\n      buildNode: function(args, context: SerializationContext) {\n        let statements = context.serializeGenerator(other);\n        if (statements.length === 1) {\n          let statement = statements[0];\n          if (leadingComment.length > 0)\n            statement.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n          return statement;\n        }\n        let block = t.blockStatement(statements);\n        if (leadingComment.length > 0) block.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n        return block;\n      },\n      dependencies: [other],\n    });\n  }\n\n  composeGenerators(generator1: Generator, generator2: Generator): void {\n    this._addEntry({\n      args: [],\n      buildNode: function([], context) {\n        let statements1 = generator1.empty() ? [] : context.serializeGenerator(generator1);\n        let statements2 = generator2.empty() ? [] : context.serializeGenerator(generator2);\n        let statements = statements1.concat(statements2);\n        if (statements.length === 1) return statements[0];\n        return t.blockStatement(statements);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n\n  joinGenerators(joinCondition: AbstractValue, generator1: Generator, generator2: Generator): void {\n    this._addEntry({\n      args: [joinCondition],\n      buildNode: function([cond], context) {\n        let block1 = generator1.empty() ? null : serializeBody(generator1, context);\n        let block2 = generator2.empty() ? null : serializeBody(generator2, context);\n        if (block1) return t.ifStatement(cond, block1, block2);\n        invariant(block2);\n        return t.ifStatement(t.unaryExpression(\"!\", cond), block2);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n}\n\n// some characters are invalid within a JavaScript identifier,\n// such as: . , : ( ) ' \" ` [ ] -\n// so we replace these character instacnes with an underscore\nfunction replaceInvalidCharactersWithUnderscore(string: string) {\n  return string.replace(/[.,:\\(\\)\\\"\\'\\`\\[\\]\\-]/g, \"_\");\n}\n\nexport class NameGenerator {\n  constructor(forbiddenNames: Set<string>, debugNames: boolean, uniqueSuffix: string, prefix: string) {\n    this.prefix = prefix;\n    this.uidCounter = 0;\n    this.debugNames = debugNames;\n    this.forbiddenNames = forbiddenNames;\n    this.uniqueSuffix = uniqueSuffix;\n  }\n  prefix: string;\n  uidCounter: number;\n  debugNames: boolean;\n  forbiddenNames: Set<string>;\n  uniqueSuffix: string;\n  generate(debugSuffix: ?string): string {\n    let id;\n    do {\n      id = this.prefix + base62.encode(this.uidCounter++);\n      if (this.uniqueSuffix.length > 0) id += this.uniqueSuffix;\n      if (this.debugNames) {\n        if (debugSuffix) id += \"_\" + replaceInvalidCharactersWithUnderscore(debugSuffix);\n        else id += \"_\";\n      }\n    } while (this.forbiddenNames.has(id));\n    return id;\n  }\n}\n\nexport class PreludeGenerator {\n  constructor(debugNames: ?boolean, uniqueSuffix: ?string) {\n    this.prelude = [];\n    this.derivedIds = new Map();\n    this.memoizedRefs = new Map();\n    this.nameGenerator = new NameGenerator(new Set(), !!debugNames, uniqueSuffix || \"\", \"_$\");\n    this.usesThis = false;\n    this.declaredGlobals = new Set();\n  }\n\n  prelude: Array<BabelNodeStatement>;\n  derivedIds: Map<string, Array<Value>>;\n  memoizedRefs: Map<string, BabelNodeIdentifier>;\n  nameGenerator: NameGenerator;\n  usesThis: boolean;\n  declaredGlobals: Set<string>;\n\n  createNameGenerator(prefix: string): NameGenerator {\n    return new NameGenerator(\n      this.nameGenerator.forbiddenNames,\n      this.nameGenerator.debugNames,\n      this.nameGenerator.uniqueSuffix,\n      prefix\n    );\n  }\n\n  convertStringToMember(str: string): BabelNodeIdentifier | BabelNodeThisExpression | BabelNodeMemberExpression {\n    return str\n      .split(\".\")\n      .map(name => {\n        if (name === \"global\") {\n          return this.memoizeReference(name);\n        } else if (name === \"this\") {\n          return t.thisExpression();\n        } else {\n          return t.identifier(name);\n        }\n      })\n      .reduce((obj, prop) => t.memberExpression(obj, prop));\n  }\n\n  globalReference(key: string, globalScope: boolean = false) {\n    if (globalScope && t.isValidIdentifier(key)) return t.identifier(key);\n    let keyNode = t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key);\n    return t.memberExpression(this.memoizeReference(\"global\"), keyNode, !t.isIdentifier(keyNode));\n  }\n\n  memoizeReference(key: string): BabelNodeIdentifier {\n    let ref = this.memoizedRefs.get(key);\n    if (ref) return ref;\n\n    let init;\n    if (key.includes(\"(\") || key.includes(\"[\")) {\n      // Horrible but effective hack:\n      // Some internal object have intrinsic names such as\n      //    ([][Symbol.iterator]().__proto__.__proto__)\n      // and\n      //    RegExp.prototype[Symbol.match]\n      // which get turned into a babel node here.\n      // TODO: We should properly parse such a string, and memoize all references in it separately.\n      // Instead, we just turn it into a funky identifier, which Babel seems to accept.\n      init = t.identifier(key);\n    } else if (key === \"global\") {\n      this.usesThis = true;\n      init = t.thisExpression();\n    } else {\n      let i = key.lastIndexOf(\".\");\n      if (i === -1) {\n        init = t.memberExpression(this.memoizeReference(\"global\"), t.identifier(key));\n      } else {\n        init = t.memberExpression(this.memoizeReference(key.substr(0, i)), t.identifier(key.substr(i + 1)));\n      }\n    }\n    ref = t.identifier(this.nameGenerator.generate(key));\n    this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, init)]));\n    this.memoizedRefs.set(key, ref);\n    return ref;\n  }\n}\n"]}