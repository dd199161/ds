{"version":3,"sources":["../../src/domains/ValuesDomain.js"],"names":["ValuesDomain","values","valueSet","Set","add","_elements","x","elems","xelems","undefined","size","e","has","contains","type","isTop","getElements","cval","mightBeFalse","mightNotBeFalse","y","union","forEach","v","intersection","elements","newSet","$Realm","intrinsics","realm","op","left","right","leftElements","rightElements","topVal","resultSet","savedHandler","errorHandler","savedIsReadOnly","isReadOnly","leftElem","rightElem","result","computeBinary","lval","rval","lprim","ToPrimitiveOrAbstract","rprim","createFromBinaryOp","lstr","ToString","rstr","lnum","ToNumber","rnum","r","false","value","true","ToUint32","ToInt32","base","exponent","Math","pow","ToNumberOrAbstract","lnumVal","rnumVal","isNaN","NaN","ToPropertyKey","computeLogical","lbool","ToBoolean","oldValue","isInstance","proto","Constructor","prototype","val","getType","operandValues","operandElements","operandElem","computeUnary","v1","v2","joinWith","meetWith"],"mappings":"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","file":"ValuesDomain.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelBinaryOperator, BabelNodeLogicalOperator, BabelUnaryOperator } from \"babel-types\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  AbstractEqualityComparison,\n  AbstractRelationalComparison,\n  Add,\n  HasProperty,\n  InstanceofOperator,\n  IsCallable,\n  StrictEqualityComparison,\n} from \"../methods/index.js\";\nimport type { Realm } from \"../realm.js\";\nimport { To } from \"../singletons.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  EmptyValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\n\n/* An abstract domain that collects together a set of concrete values\n   that might be the value of a variable at runtime.\n   Initially, every variable has the value undefined.\n   A property that has been weakly deleted will have more than\n   one value, one of which will by the EmptyValue.  */\n\nexport default class ValuesDomain {\n  constructor(values: void | Set<ConcreteValue> | ConcreteValue) {\n    if (values instanceof ConcreteValue) {\n      let valueSet = new Set();\n      valueSet.add(values);\n      values = valueSet;\n    }\n    this._elements = values;\n  }\n\n  static topVal = new ValuesDomain(undefined);\n\n  _elements: void | Set<ConcreteValue>;\n\n  contains(x: ValuesDomain): boolean {\n    let elems = this._elements;\n    let xelems = x._elements;\n    if (elems === xelems) return true;\n    if (elems === undefined) return true;\n    if (xelems === undefined) return false;\n    if (elems.size < xelems.size) return false;\n    for (let e of xelems) {\n      if (!elems.has(e)) return false;\n    }\n    return true;\n  }\n\n  containsValue(x: Value): boolean {\n    let elems = this._elements;\n    if (elems === undefined) return true; // Top contains everything\n    if (x instanceof AbstractValue) return this.contains(x.values);\n    invariant(x instanceof ConcreteValue);\n    return elems.has(x);\n  }\n\n  isTop() {\n    return this._elements === undefined;\n  }\n\n  getElements() {\n    invariant(this._elements !== undefined);\n    return this._elements;\n  }\n\n  // return a set of values that may be result of performing the given operation on each pair in the\n  // Cartesian product of the value sets of the operands.\n  static binaryOp(realm: Realm, op: BabelBinaryOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeBinary(realm, op, leftElem, rightElem);\n          invariant(result instanceof ConcreteValue);\n          resultSet.add(result);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeBinary(realm: Realm, op: BabelBinaryOperator, lval: ConcreteValue, rval: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.8.3 The Addition Operator\n      let lprim = To.ToPrimitiveOrAbstract(realm, lval);\n      let rprim = To.ToPrimitiveOrAbstract(realm, rval);\n\n      if (lprim instanceof AbstractValue || rprim instanceof AbstractValue) {\n        return AbstractValue.createFromBinaryOp(realm, op, lprim, rprim);\n      }\n\n      if (lprim instanceof StringValue || rprim instanceof StringValue) {\n        let lstr = To.ToString(realm, lprim);\n        let rstr = To.ToString(realm, rprim);\n        return new StringValue(realm, lstr + rstr);\n      }\n\n      let lnum = To.ToNumber(realm, lprim);\n      let rnum = To.ToNumber(realm, rprim);\n      return Add(realm, lnum, rnum);\n    } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n      // ECMA262 12.10.3\n      if (op === \"<\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \"<=\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else {\n          return realm.intrinsics.true;\n        }\n      } else if (op === \">\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \">=\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else {\n          return realm.intrinsics.true;\n        }\n      }\n    } else if (op === \">>>\") {\n      // ECMA262 12.9.5.1\n      let lnum = To.ToUint32(realm, lval);\n      let rnum = To.ToUint32(realm, rval);\n\n      return new NumberValue(realm, lnum >>> rnum);\n    } else if (op === \"<<\" || op === \">>\") {\n      let lnum = To.ToInt32(realm, lval);\n      let rnum = To.ToUint32(realm, rval);\n\n      if (op === \"<<\") {\n        // ECMA262 12.9.3.1\n        return new NumberValue(realm, lnum << rnum);\n      } else if (op === \">>\") {\n        // ECMA262 12.9.4.1\n        return new NumberValue(realm, lnum >> rnum);\n      }\n    } else if (op === \"**\") {\n      // ECMA262 12.6.3\n\n      // 5. Let base be ? ToNumber(leftValue).\n      let base = To.ToNumber(realm, lval);\n\n      // 6. Let exponent be ? ToNumber(rightValue).\n      let exponent = To.ToNumber(realm, rval);\n\n      // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.\n      return new NumberValue(realm, Math.pow(base, exponent));\n    } else if (op === \"%\" || op === \"/\" || op === \"*\" || op === \"-\") {\n      // ECMA262 12.7.3\n      let lnum = To.ToNumberOrAbstract(realm, lval);\n      let rnum = To.ToNumberOrAbstract(realm, rval);\n      if (lnum instanceof AbstractValue || rnum instanceof AbstractValue) {\n        const lnumVal = lnum instanceof AbstractValue ? lnum : new NumberValue(realm, lnum);\n        const rnumVal = rnum instanceof AbstractValue ? rnum : new NumberValue(realm, rnum);\n        return AbstractValue.createFromBinaryOp(realm, op, lnumVal, rnumVal);\n      }\n\n      if (isNaN(rnum)) return realm.intrinsics.NaN;\n      if (isNaN(lnum)) return realm.intrinsics.NaN;\n\n      if (op === \"-\") {\n        return Add(realm, lnum, rnum, true);\n      } else if (op === \"%\") {\n        // The sign of the result equals the sign of the dividend.\n        // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\n        // If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n        // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n        return new NumberValue(realm, lnum % rnum);\n      } else if (op === \"/\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Division of an infinity by an infinity results in NaN.\n        // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n        // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n        // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n        // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n        // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum / rnum);\n      } else if (op === \"*\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Multiplication of an infinity by a zero results in NaN.\n        // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n        // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum * rnum);\n      }\n    } else if (op === \"!==\") {\n      return new BooleanValue(realm, !StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"===\") {\n      return new BooleanValue(realm, StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"!=\") {\n      return new BooleanValue(realm, !AbstractEqualityComparison(realm, lval, rval));\n    } else if (op === \"==\") {\n      return new BooleanValue(realm, AbstractEqualityComparison(realm, lval, rval));\n    } else if (op === \"&\" || op === \"|\" || op === \"^\") {\n      // ECMA262 12.12.3\n\n      // 5. Let lnum be ? ToInt32(lval).\n      let lnum: number = To.ToInt32(realm, lval);\n\n      // 6. Let rnum be ? ToInt32(rval).\n      let rnum: number = To.ToInt32(realm, rval);\n\n      // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.\n      if (op === \"&\") {\n        return new NumberValue(realm, lnum & rnum);\n      } else if (op === \"|\") {\n        return new NumberValue(realm, lnum | rnum);\n      } else if (op === \"^\") {\n        return new NumberValue(realm, lnum ^ rnum);\n      }\n    } else if (op === \"in\") {\n      // ECMA262 12.10.3\n\n      // 5. If Type(rval) is not Object, throw a TypeError exception.\n      if (!(rval instanceof ObjectValue)) {\n        throw new FatalError();\n      }\n\n      // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).\n      return new BooleanValue(realm, HasProperty(realm, rval, To.ToPropertyKey(realm, lval)));\n    } else if (op === \"instanceof\") {\n      // ECMA262 12.10.3\n\n      // 5. Return ? InstanceofOperator(lval, rval).;\n      return new BooleanValue(realm, InstanceofOperator(realm, lval, rval));\n    }\n\n    invariant(false, \"unimplemented \" + op);\n  }\n\n  static logicalOp(realm: Realm, op: BabelNodeLogicalOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeLogical(realm, op, leftElem, rightElem);\n          invariant(result instanceof ConcreteValue);\n          resultSet.add(result);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeLogical(realm: Realm, op: BabelNodeLogicalOperator, lval: ConcreteValue, rval: ConcreteValue): Value {\n    let lbool = To.ToBoolean(realm, lval);\n\n    if (op === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else if (op === \"||\") {\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n    return rval;\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeUnary(realm: Realm, op: BabelUnaryOperator, value: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.5.6.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Return ? ToNumber(? GetValue(expr)).\n      return new NumberValue(realm, To.ToNumber(realm, value));\n    } else if (op === \"-\") {\n      // ECMA262 12.5.7.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n      let oldValue = To.ToNumber(realm, value);\n\n      // 3. If oldValue is NaN, return NaN.\n      if (isNaN(oldValue)) {\n        return realm.intrinsics.NaN;\n      }\n\n      // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n      return new NumberValue(realm, -oldValue);\n    } else if (op === \"~\") {\n      // ECMA262 12.5.8\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n      let oldValue = To.ToInt32(realm, value);\n\n      // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n      return new NumberValue(realm, ~oldValue);\n    } else if (op === \"!\") {\n      // ECMA262 12.6.9\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n      let oldValue = To.ToBoolean(realm, value);\n\n      // 3. If oldValue is true, return false.\n      if (oldValue === true) return realm.intrinsics.false;\n\n      // 4. Return true.\n      return realm.intrinsics.true;\n    } else if (op === \"void\") {\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Perform ? GetValue(expr).\n      // 3. Return undefined.\n      return realm.intrinsics.undefined;\n    } else if (op === \"typeof\") {\n      function isInstance(proto, Constructor): boolean {\n        return proto instanceof Constructor || proto === Constructor.prototype;\n      }\n      // ECMA262 12.6.5\n      // 1. Let val be the result of evaluating UnaryExpression.\n      // 2. If Type(val) is Reference, then\n      // 3. Let val be ? GetValue(val).\n      let val = value;\n      // 4. Return a String according to Table 35.\n      let proto = val.getType().prototype;\n      if (isInstance(proto, UndefinedValue)) {\n        return new StringValue(realm, \"undefined\");\n      } else if (isInstance(proto, NullValue)) {\n        return new StringValue(realm, \"object\");\n      } else if (isInstance(proto, StringValue)) {\n        return new StringValue(realm, \"string\");\n      } else if (isInstance(proto, BooleanValue)) {\n        return new StringValue(realm, \"boolean\");\n      } else if (isInstance(proto, NumberValue)) {\n        return new StringValue(realm, \"number\");\n      } else if (isInstance(proto, SymbolValue)) {\n        return new StringValue(realm, \"symbol\");\n      } else if (isInstance(proto, ObjectValue)) {\n        if (IsCallable(realm, val)) {\n          return new StringValue(realm, \"function\");\n        }\n        return new StringValue(realm, \"object\");\n      } else {\n        invariant(false);\n      }\n    } else {\n      invariant(op === \"delete\");\n      // ECMA262 12.5.3.2\n      // 1. Let ref be the result of evaluating UnaryExpression.\n      // 2. ReturnIfAbrupt(ref).\n      // 3. If Type(ref) is not Reference, return true.\n      return realm.intrinsics.true;\n    }\n  }\n\n  static unaryOp(realm: Realm, op: BabelUnaryOperator, operandValues: ValuesDomain): ValuesDomain {\n    let operandElements = operandValues._elements;\n    if (operandElements === undefined) return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let operandElem of operandElements) {\n        let result = ValuesDomain.computeUnary(realm, op, operandElem);\n        invariant(result instanceof ConcreteValue);\n        resultSet.add(result);\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  includesValueNotOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (!(cval instanceof type)) return true;\n    }\n    return false;\n  }\n\n  includesValueOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval instanceof type) return true;\n    }\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightBeFalse()) return true;\n    }\n    return false;\n  }\n\n  mightNotBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightNotBeFalse()) return true;\n    }\n    return false;\n  }\n\n  static joinValues(realm: Realm, v1: void | Value, v2: void | Value): ValuesDomain {\n    if (v1 === undefined) v1 = realm.intrinsics.undefined;\n    if (v2 === undefined) v2 = realm.intrinsics.undefined;\n    if (v1 instanceof AbstractValue) return v1.values.joinWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.joinWith(v1);\n    let union = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    union.add(v1);\n    invariant(v2 instanceof ConcreteValue);\n    union.add(v2);\n    return new ValuesDomain(union);\n  }\n\n  joinWith(y: Value): ValuesDomain {\n    if (this.isTop()) return this;\n    let union = new Set(this.getElements());\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return y.values;\n      y.values.getElements().forEach(v => union.add(v));\n    } else {\n      invariant(y instanceof ConcreteValue);\n      union.add(y);\n    }\n    return new ValuesDomain(union);\n  }\n\n  static meetValues(realm: Realm, v1: void | Value, v2: void | Value): ValuesDomain {\n    if (v1 === undefined) v1 = realm.intrinsics.undefined;\n    if (v2 === undefined) v2 = realm.intrinsics.undefined;\n    if (v1 instanceof AbstractValue) return v1.values.meetWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.meetWith(v1);\n    let intersection = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    invariant(v2 instanceof ConcreteValue);\n    if (v1 === v2) intersection.add(v1);\n    return new ValuesDomain(intersection);\n  }\n\n  meetWith(y: Value): ValuesDomain {\n    let intersection = new Set();\n    let elements = this._elements;\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return this;\n      y.values.getElements().forEach(v => {\n        if (elements === undefined || elements.has(v)) intersection.add(v);\n      });\n    } else {\n      invariant(y instanceof ConcreteValue);\n      if (elements === undefined || elements.has(y)) intersection.add(y);\n    }\n    return new ValuesDomain(intersection);\n  }\n\n  promoteEmptyToUndefined(): ValuesDomain {\n    if (this.isTop()) return this;\n    let newSet = new Set();\n    for (let cval of this.getElements()) {\n      if (cval instanceof EmptyValue) newSet.add(cval.$Realm.intrinsics.undefined);\n      else newSet.add(cval);\n    }\n    return new ValuesDomain(newSet);\n  }\n}\n"]}