"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (ast, strictCode, env, realm, labelSet) {
  var body = ast.body,
      test = ast.test;

  // 1. Let V be undefined.

  var V = realm.intrinsics.undefined;

  // 2. Repeat
  var resultOrDiagnostic = realm.evaluateWithUndoForDiagnostic(function () {
    while (true) {
      // a. Let stmt be the result of evaluating Statement.
      var stmt = env.evaluateCompletion(body, strictCode);
      //todo: check if stmt is a PossiblyNormalCompletion and defer to fixpoint computation below
      (0, _invariant2.default)(stmt instanceof _index.Value || stmt instanceof _completions.AbruptCompletion);

      // b. If LoopContinues(stmt, labelSet) is false, return Completion(UpdateEmpty(stmt, V)).
      if ((0, _ForOfStatement.LoopContinues)(realm, stmt, labelSet) === false) {
        (0, _invariant2.default)(stmt instanceof _completions.AbruptCompletion);
        // ECMA262 13.1.7
        if (stmt instanceof _completions.BreakCompletion) {
          if (!stmt.target) return (0, _index2.UpdateEmpty)(realm, stmt, V).value;
        }
        throw (0, _index2.UpdateEmpty)(realm, stmt, V);
      }

      // c. If stmt.[[Value]] is not empty, let V be stmt.[[Value]].
      var resultValue = (0, _ForOfStatement.InternalGetResultValue)(realm, stmt);
      if (!(resultValue instanceof _index.EmptyValue)) V = resultValue;

      // d. Let exprRef be the result of evaluating Expression.
      var exprRef = env.evaluate(test, strictCode);

      // e. Let exprValue be ? GetValue(exprRef).
      var exprValue = _singletons.Environment.GetConditionValue(realm, exprRef);

      // f. If ToBoolean(exprValue) is false, return NormalCompletion(V).
      if (_singletons.To.ToBooleanPartial(realm, exprValue) === false) return V;
    }
    (0, _invariant2.default)(false);
  });
  if (resultOrDiagnostic instanceof _index.Value) return resultOrDiagnostic;

  // If we get here then unrolling the loop did not work, possibly because the value of the loop condition is not known,
  // so instead try to compute a fixpoint for it
  var ftest = function ftest() {
    var exprRef = env.evaluate(test, strictCode);
    return _singletons.Environment.GetConditionValue(realm, exprRef);
  };
  var fbody = function fbody() {
    return env.evaluateCompletion(body, strictCode);
  };
  var effects = realm.evaluateForFixpointEffects(ftest, fbody);
  if (effects !== undefined) {
    var _effects = _slicedToArray(effects, 2),
        outsideEffects = _effects[0],
        insideEffects = _effects[1];

    var _outsideEffects = _slicedToArray(outsideEffects, 1),
        rval = _outsideEffects[0];

    var _insideEffects = _slicedToArray(insideEffects, 2),
        bodyGenerator = _insideEffects[1];

    realm.applyEffects(outsideEffects);
    var exprRef = env.evaluate(test, strictCode);
    var exprValue = _singletons.Environment.GetValue(realm, exprRef);
    (0, _invariant2.default)(exprValue instanceof _index.AbstractValue);
    var cond = bodyGenerator.derive(exprValue.types, exprValue.values, [exprValue], function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          n = _ref2[0];

      return n;
    }, {
      skipInvariant: true
    });
    var generator = realm.generator;
    (0, _invariant2.default)(generator !== undefined);
    generator.emitDoWhileStatement(cond, bodyGenerator);
    (0, _invariant2.default)(rval instanceof _index.Value, "todo: handle loops that throw exceptions or return");
    return rval;
  }

  // If we get here the fixpoint computation failed as well. Report the diagnostic from the unrolling and throw.
  realm.handleError(resultOrDiagnostic);
  throw new _errors.FatalError();
};

var _errors = require("../errors.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _ForOfStatement = require("./ForOfStatement.js");

var _completions = require("../completions.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=DoWhileStatement.js.map