{"version":3,"sources":["../../src/evaluators/UnaryExpression.js"],"names":["ast","strictCode","env","realm","reportError","error","argument","loc","handleError","expr","evaluate","operator","value","GetValue","IsToNumberPure","createFromUnaryOp","ToNumber","oldValue","isNaN","intrinsics","NaN","ToInt32","ToBoolean","false","true","undefined","val","IsUnresolvableReference","proto","getType","prototype","isInstance","ref","IsStrictReference","IsPropertyReference","IsSuperReference","createErrorThrowCompletion","ReferenceError","base","GetBase","baseObj","ToObject","deleteStatus","$Delete","GetReferencedName","TypeError","bindings","referencedName","DeleteBinding","Constructor"],"mappings":"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","file":"UnaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  AbstractObjectValue,\n  Value,\n  BooleanValue,\n  ConcreteValue,\n  NumberValue,\n  StringValue,\n  UndefinedValue,\n  NullValue,\n  SymbolValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { Reference, EnvironmentRecord } from \"../environment.js\";\nimport invariant from \"../invariant.js\";\nimport { IsCallable } from \"../methods/index.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport type { BabelNodeUnaryExpression } from \"babel-types\";\n\nfunction isInstance(proto, Constructor): boolean {\n  return proto instanceof Constructor || proto === Constructor.prototype;\n}\n\nexport default function(\n  ast: BabelNodeUnaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  function reportError() {\n    let error = new CompilerDiagnostic(\n      \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n      ast.argument.loc,\n      \"PP0008\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  if (ast.operator === \"+\") {\n    // ECMA262 12.5.6.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Return ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"+\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n\n    return new NumberValue(realm, To.ToNumber(realm, value));\n  } else if (ast.operator === \"-\") {\n    // ECMA262 12.5.7.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"-\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToNumber(realm, value);\n\n    // 3. If oldValue is NaN, return NaN.\n    if (isNaN(oldValue)) {\n      return realm.intrinsics.NaN;\n    }\n\n    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n    return new NumberValue(realm, -oldValue);\n  } else if (ast.operator === \"~\") {\n    // ECMA262 12.5.8\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"~\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToInt32(realm, value);\n\n    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n    return new NumberValue(realm, ~oldValue);\n  } else if (ast.operator === \"!\") {\n    // ECMA262 12.6.9\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) return AbstractValue.createFromUnaryOp(realm, \"!\", value);\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToBoolean(realm, value);\n\n    // 3. If oldValue is true, return false.\n    if (oldValue === true) return realm.intrinsics.false;\n\n    // 4. Return true.\n    return realm.intrinsics.true;\n  } else if (ast.operator === \"void\") {\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Perform ? GetValue(expr).\n    Environment.GetValue(realm, expr);\n\n    // 3. Return undefined.\n    return realm.intrinsics.undefined;\n  } else if (ast.operator === \"typeof\") {\n    // ECMA262 12.6.5\n\n    // 1. Let val be the result of evaluating UnaryExpression.\n    let val = expr;\n\n    // 2. If Type(val) is Reference, then\n    if (val instanceof Reference) {\n      // a. If IsUnresolvableReference(val) is true, return \"undefined\".\n      if (Environment.IsUnresolvableReference(realm, val)) {\n        return new StringValue(realm, \"undefined\");\n      }\n    }\n\n    // 3. Let val be ? GetValue(val).\n    val = Environment.GetValue(realm, val);\n\n    // 4. Return a String according to Table 35.\n    let proto = val.getType().prototype;\n    if (isInstance(proto, UndefinedValue)) {\n      return new StringValue(realm, \"undefined\");\n    } else if (isInstance(proto, NullValue)) {\n      return new StringValue(realm, \"object\");\n    } else if (isInstance(proto, StringValue)) {\n      return new StringValue(realm, \"string\");\n    } else if (isInstance(proto, BooleanValue)) {\n      return new StringValue(realm, \"boolean\");\n    } else if (isInstance(proto, NumberValue)) {\n      return new StringValue(realm, \"number\");\n    } else if (isInstance(proto, SymbolValue)) {\n      return new StringValue(realm, \"symbol\");\n    } else if (isInstance(proto, ObjectValue)) {\n      if (IsCallable(realm, val)) {\n        return new StringValue(realm, \"function\");\n      }\n      return new StringValue(realm, \"object\");\n    } else {\n      invariant(val instanceof AbstractValue);\n      return AbstractValue.createFromUnaryOp(realm, \"typeof\", val);\n    }\n  } else {\n    invariant(ast.operator === \"delete\");\n    // ECMA262 12.5.3.2\n\n    // 1. Let ref be the result of evaluating UnaryExpression.\n    let ref = expr;\n\n    // 2. ReturnIfAbrupt(ref).\n\n    // 3. If Type(ref) is not Reference, return true.\n    if (!(ref instanceof Reference)) return realm.intrinsics.true;\n\n    // 4. If IsUnresolvableReference(ref) is true, then\n    if (Environment.IsUnresolvableReference(realm, ref)) {\n      // a. Assert: IsStrictReference(ref) is false.\n      invariant(!Environment.IsStrictReference(realm, ref), \"did not expect a strict reference\");\n\n      // b. Return true.\n      return realm.intrinsics.true;\n    }\n\n    // 5. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.\n      if (Environment.IsSuperReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n\n      // b. Let baseObj be ! ToObject(GetBase(ref)).\n      let base = Environment.GetBase(realm, ref);\n      // Constructing the reference checks that base is coercible to an object hence\n      invariant(base instanceof ConcreteValue || base instanceof AbstractObjectValue);\n      let baseObj = base instanceof ConcreteValue ? To.ToObject(realm, base) : base;\n\n      // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).\n      let deleteStatus = baseObj.$Delete(Environment.GetReferencedName(realm, ref));\n\n      // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.\n      if (!deleteStatus && Environment.IsStrictReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // e. Return deleteStatus.\n      return new BooleanValue(realm, deleteStatus);\n    }\n\n    // 6. Else ref is a Reference to an Environment Record binding,\n    // a. Let bindings be GetBase(ref).\n    let bindings = Environment.GetBase(realm, ref);\n    invariant(bindings instanceof EnvironmentRecord);\n\n    // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).\n    let referencedName = Environment.GetReferencedName(realm, ref);\n    invariant(typeof referencedName === \"string\");\n    return new BooleanValue(realm, bindings.DeleteBinding(referencedName));\n  }\n}\n"]}