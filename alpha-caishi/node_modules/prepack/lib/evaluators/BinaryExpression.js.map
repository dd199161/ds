{"version":3,"sources":["../../src/evaluators/BinaryExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","GetValue","rref","right","rval","computeBinary","operator","loc","getPureBinaryOperationResultType","unknownValueOfOrToString","op","lloc","rloc","reportErrorIfNotPure","purityTest","typeIfPure","leftPure","rightPure","error","handleError","ltype","GetToPrimitivePureResultType","rtype","undefined","getType","IsToPrimitivePure","bind","IsToNumberPure","mightNotBeObject","isSimpleObject","useAbstractInterpretation","createFromBinaryOp","createErrorThrowCompletion","intrinsics","TypeError"],"mappings":"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","file":"BinaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { ValuesDomain } from \"../domains/index.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport type { BabelNodeBinaryExpression, BabelBinaryOperator, BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeBinaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // evaluate left\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = Environment.GetValue(realm, lref);\n\n  // evaluate right\n  let rref = env.evaluate(ast.right, strictCode);\n  let rval = Environment.GetValue(realm, rref);\n\n  return computeBinary(realm, ast.operator, lval, rval, ast.left.loc, ast.right.loc, ast.loc);\n}\n\nlet unknownValueOfOrToString = \"might be an object with an unknown valueOf or toString or Symbol.toPrimitive method\";\n\n// Returns result type if binary operation is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\nexport function getPureBinaryOperationResultType(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation\n): typeof Value {\n  function reportErrorIfNotPure(purityTest: (Realm, Value) => boolean, typeIfPure: typeof Value): typeof Value {\n    let leftPure = purityTest(realm, lval);\n    let rightPure = purityTest(realm, rval);\n    if (leftPure && rightPure) return typeIfPure;\n    let loc = !leftPure ? lloc : rloc;\n    let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that an unknown value is actually a primitive or otherwise a well behaved object.\n      return typeIfPure;\n    }\n    throw new FatalError();\n  }\n  if (op === \"+\") {\n    let ltype = To.GetToPrimitivePureResultType(realm, lval);\n    let rtype = To.GetToPrimitivePureResultType(realm, rval);\n    if (ltype === undefined || rtype === undefined) {\n      let loc = ltype === undefined ? lloc : rloc;\n      let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the unknown value is actually a primitive or otherwise a well behaved object.\n        ltype = lval.getType();\n        rtype = rval.getType();\n        if (ltype === StringValue || rtype === StringValue) return StringValue;\n        if (ltype === NumberValue && rtype === NumberValue) return NumberValue;\n        return Value;\n      }\n      throw new FatalError();\n    }\n    if (ltype === StringValue || rtype === StringValue) return StringValue;\n    return NumberValue;\n  } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n    return reportErrorIfNotPure(To.IsToPrimitivePure.bind(To), BooleanValue);\n  } else if (op === \"!=\" || op === \"==\") {\n    let ltype = lval.getType();\n    let rtype = rval.getType();\n    if (ltype === NullValue || ltype === UndefinedValue || rtype === NullValue || rtype === UndefinedValue)\n      return BooleanValue;\n    return reportErrorIfNotPure(To.IsToPrimitivePure.bind(To), BooleanValue);\n  } else if (op === \"===\" || op === \"!==\") {\n    return BooleanValue;\n  } else if (\n    op === \">>>\" ||\n    op === \"<<\" ||\n    op === \">>\" ||\n    op === \"&\" ||\n    op === \"|\" ||\n    op === \"^\" ||\n    op === \"**\" ||\n    op === \"%\" ||\n    op === \"/\" ||\n    op === \"*\" ||\n    op === \"-\"\n  ) {\n    return reportErrorIfNotPure(To.IsToNumberPure.bind(To), NumberValue);\n  } else if (op === \"in\" || op === \"instanceof\") {\n    if (rval.mightNotBeObject()) {\n      let error = new CompilerDiagnostic(\n        `might not be an object, hence the ${op} operator might throw a TypeError`,\n        rloc,\n        \"PP0003\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the object is actually a well behaved object.\n        return BooleanValue;\n      }\n      throw new FatalError();\n    }\n    if (!rval.mightNotBeObject()) {\n      // Simple object won't throw here, aren't proxy objects or typed arrays and do not have @@hasInstance properties.\n      if (rval.isSimpleObject()) return BooleanValue;\n    }\n    let error = new CompilerDiagnostic(\n      `might be an object that behaves badly for the ${op} operator`,\n      rloc,\n      \"PP0004\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that the object is actually a well behaved object.\n      return BooleanValue;\n    }\n    throw new FatalError();\n  }\n  invariant(false, \"unimplemented \" + op);\n}\n\nexport function computeBinary(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation,\n  loc?: ?BabelNodeSourceLocation\n): Value {\n  // partial evaluation shortcut for a particular pattern\n  if (realm.useAbstractInterpretation && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      ((lval instanceof NullValue || lval instanceof UndefinedValue) && !rval.mightNotBeObject())\n    ) {\n      return new BooleanValue(realm, op[0] !== \"=\");\n    }\n  }\n\n  if (lval instanceof AbstractValue || rval instanceof AbstractValue) {\n    // generate error if binary operation might throw or have side effects\n    getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc);\n    return AbstractValue.createFromBinaryOp(realm, op, lval, rval, loc);\n  }\n\n  // ECMA262 12.10.3\n\n  // 5. If Type(rval) is not Object, throw a TypeError exception.\n  if (op === \"in\" && !(rval instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n  invariant(lval instanceof ConcreteValue);\n  invariant(rval instanceof ConcreteValue);\n  return ValuesDomain.computeBinary(realm, op, lval, rval);\n}\n"]}