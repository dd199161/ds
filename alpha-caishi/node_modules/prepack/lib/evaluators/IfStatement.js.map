{"version":3,"sources":["../../src/evaluators/IfStatement.js"],"names":["evaluate","evaluateWithAbstractConditional","ast","strictCode","env","realm","exprRef","test","exprValue","GetConditionValue","stmtCompletion","ToBoolean","evaluateCompletion","consequent","alternate","intrinsics","undefined","mightNotBeTrue","mightNotBeFalse","condValue","withCondition","evaluateNodeForEffects","compl1","gen1","bindings1","properties1","createdObj1","withInverseCondition","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinEffects","completion","composeWithSavedCompletion","applyEffects"],"mappings":"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","file":"IfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport type { BabelNode, BabelNodeIfStatement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Environment, Join, Path, To } from \"../singletons.js\";\n\nexport function evaluate(ast: BabelNodeIfStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  // 1. Let exprRef be the result of evaluating Expression\n  let exprRef = env.evaluate(ast.test, strictCode);\n  // 2. Let exprValue be ToBoolean(? GetValue(exprRef))\n  let exprValue: Value = Environment.GetConditionValue(realm, exprRef);\n\n  if (exprValue instanceof ConcreteValue) {\n    let stmtCompletion;\n    if (To.ToBoolean(realm, exprValue)) {\n      // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n      stmtCompletion = env.evaluateCompletion(ast.consequent, strictCode);\n    } else {\n      if (ast.alternate)\n        // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n        stmtCompletion = env.evaluateCompletion(ast.alternate, strictCode);\n      else\n        // 3 (of the if only statement). Return NormalCompletion(undefined)\n        stmtCompletion = realm.intrinsics.undefined;\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    //if (stmtCompletion instanceof Reference) return stmtCompletion;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  if (!exprValue.mightNotBeTrue()) {\n    let stmtCompletion = env.evaluate(ast.consequent, strictCode);\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else if (!exprValue.mightNotBeFalse()) {\n    let stmtCompletion;\n    if (ast.alternate) stmtCompletion = env.evaluate(ast.alternate, strictCode);\n    else stmtCompletion = realm.intrinsics.undefined;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else {\n    invariant(exprValue instanceof AbstractValue);\n    return evaluateWithAbstractConditional(exprValue, ast.consequent, ast.alternate, strictCode, env, realm);\n  }\n}\n\nexport function evaluateWithAbstractConditional(\n  condValue: AbstractValue,\n  consequent: BabelNode,\n  alternate: ?BabelNode,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // Evaluate consequent and alternate in sandboxes and get their effects.\n  let [compl1, gen1, bindings1, properties1, createdObj1] = Path.withCondition(condValue, () => {\n    return realm.evaluateNodeForEffects(consequent, strictCode, env);\n  });\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = Path.withInverseCondition(condValue, () => {\n    return alternate ? realm.evaluateNodeForEffects(alternate, strictCode, env) : construct_empty_effects(realm);\n  });\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of condValue.\n  let joinedEffects = Join.joinEffects(\n    realm,\n    condValue,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let completion = joinedEffects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n"]}