{"version":3,"sources":["../../src/evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","callee","type","arguments","setNextExecutionContextLocation","loc","ref","evaluate","func","GetValue","EvaluateCall","t","callBothFunctionsAndJoinTheirEffects","args","cond","func1","func2","getType","isTypeCompatibleWith","evaluateForEffects","compl1","gen1","bindings1","properties1","createdObj1","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinEffects","completion","composeWithSavedCompletion","applyEffects","generateRuntimeCall","base","referencedName","thisArg","propName","undefined","push","concat","arg","leakValue","createTemporalFromBuildFunction","callFunc","argStart","memberExpression","nodes","identifier","isValidIdentifier","fun_args","slice","callExpression","property","isInPureScope","error","handleError","kind","evaluateWithPossibleThrowCompletion","topVal","IsPropertyReference","GetReferencedName","intrinsics","eval","argList","length","evalText","strictCaller","evalRealm","PerformEval","thisValue","refEnv","GetBase","WithBaseObject","thisCall","tailCall"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { EnvironmentRecord } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { Value } from \"../values/index.js\";\nimport { AbstractValue, BooleanValue, ConcreteValue, FunctionValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment, Functions, Join, Leak } from \"../singletons.js\";\nimport {\n  ArgumentListEvaluation,\n  EvaluateDirectCall,\n  GetThisValue,\n  IsInTailPosition,\n  SameValue,\n} from \"../methods/index.js\";\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeSpreadElement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport SuperCall from \"./SuperCall\";\n\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (ast.callee.type === \"Super\") {\n    return SuperCall(ast.arguments, strictCode, env, realm);\n  }\n\n  // ECMA262 12.3.4.1\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let ref = env.evaluate(ast.callee, strictCode);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  return EvaluateCall(ref, func, ast, strictCode, env, realm);\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  args: Array<Value>,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let [cond, func1, func2] = args;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  let [compl1, gen1, bindings1, properties1, createdObj1] = realm.evaluateForEffects(() =>\n    EvaluateCall(func1, func1, ast, strictCode, env, realm)\n  );\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = realm.evaluateForEffects(() =>\n    EvaluateCall(func2, func2, ast, strictCode, env, realm)\n  );\n\n  let joinedEffects = Join.joinEffects(\n    realm,\n    cond,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let completion = joinedEffects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  function generateRuntimeCall() {\n    let args = [func];\n    let [thisArg, propName] = ref instanceof Reference ? [ref.base, ref.referencedName] : [];\n    if (thisArg instanceof Value) args = [thisArg];\n    if (propName !== undefined && typeof propName !== \"string\") args.push(propName);\n    args = args.concat(ArgumentListEvaluation(realm, strictCode, env, ast.arguments));\n    for (let arg of args) {\n      if (arg !== func) {\n        Leak.leakValue(realm, arg, ast.loc);\n      }\n    }\n    return AbstractValue.createTemporalFromBuildFunction(realm, Value, args, nodes => {\n      let callFunc;\n      let argStart = 1;\n      if (thisArg instanceof Value) {\n        if (typeof propName === \"string\") {\n          callFunc = t.memberExpression(nodes[0], t.identifier(propName), !t.isValidIdentifier(propName));\n        } else {\n          callFunc = t.memberExpression(nodes[0], nodes[1], true);\n          argStart = 2;\n        }\n      } else {\n        callFunc = nodes[0];\n      }\n      let fun_args = ((nodes.slice(argStart): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n      return t.callExpression(callFunc, fun_args);\n    });\n  }\n\n  if (func instanceof AbstractValue) {\n    let loc = ast.callee.type === \"MemberExpression\" ? ast.callee.property.loc : ast.callee.loc;\n    if (!Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n      if (!realm.isInPureScope()) {\n        // If this is not a function, this call might throw which can change the state of the program.\n        // If this is called from a pure function we handle it using evaluateWithPossiblyAbruptCompletion.\n        let error = new CompilerDiagnostic(\"might not be a function\", loc, \"PP0005\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n      }\n    } else if (func.kind === \"conditional\") {\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, strictCode, env, realm);\n    } else {\n      // Assume that it is a safe function. TODO #705: really?\n    }\n    if (realm.isInPureScope()) {\n      // In pure functions we allow abstract functions to throw, which this might.\n      return realm.evaluateWithPossibleThrowCompletion(generateRuntimeCall, TypesDomain.topVal, ValuesDomain.topVal);\n    }\n    return generateRuntimeCall();\n  }\n  invariant(func instanceof ConcreteValue);\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n      let argList = ArgumentListEvaluation(realm, strictCode, env, ast.arguments);\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      if (evalText instanceof AbstractValue) {\n        let loc = ast.arguments[0].loc;\n        let error = new CompilerDiagnostic(\"eval argument must be a known value\", loc, \"PP0006\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n        // Assume that it is a safe eval with no visible heap changes or abrupt control flow.\n        return generateRuntimeCall();\n      }\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n  return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);\n}\n"]}