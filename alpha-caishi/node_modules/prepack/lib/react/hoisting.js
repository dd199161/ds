"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.canHoistFunction = canHoistFunction;
exports.canHoistReactElement = canHoistReactElement;

var _realm = require("../realm.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _utils = require("./utils.js");

var _ResidualHeapVisitor = require("../serializer/ResidualHeapVisitor.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// a nested object of a React Element should be hoisted where all its properties are known
// at evaluation time to be safe to hoist (because of the heuristics of a React render)
function canHoistObject(realm, object, residualHeapVisitor, visitedValues) {
  if ((0, _utils.isReactElement)(object)) {
    return canHoistReactElement(realm, object, residualHeapVisitor, visitedValues);
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = object.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref = _step.value;

      var _ref2 = _slicedToArray(_ref, 1);

      var propName = _ref2[0];

      var prop = (0, _index2.Get)(realm, object, propName);
      if (!canHoistValue(realm, prop, residualHeapVisitor, visitedValues)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = object.symbols[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ref3 = _step2.value;

      var _ref4 = _slicedToArray(_ref3, 1);

      var symbol = _ref4[0];

      var prop = (0, _index2.Get)(realm, object, symbol);
      if (!canHoistValue(realm, prop, residualHeapVisitor, visitedValues)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return true;
}

function canHoistArray(realm, array, residualHeapVisitor, visitedValues) {
  var lengthValue = (0, _index2.Get)(realm, array, "length");
  (0, _invariant2.default)(lengthValue instanceof _index.NumberValue);
  var length = lengthValue.value;
  for (var i = 0; i < length; i++) {
    var element = (0, _index2.Get)(realm, array, "" + i);

    if (!canHoistValue(realm, element, residualHeapVisitor, visitedValues)) {
      return false;
    }
  }
  return true;
}

function canHoistFunction(realm, func, residualHeapVisitor, visitedValues) {
  if (realm.react.hoistableFunctions.has(func)) {
    // cast because Flow thinks that we may have set a value to be something other than a boolean?
    return realm.react.hoistableFunctions.get(func);
  }
  if (residualHeapVisitor === undefined) {
    return false;
  }
  // get the function instance
  var functionInstance = residualHeapVisitor.functionInstances.get(func);
  // we can safely hoist the function if the residual bindings hoistable too
  if (functionInstance !== undefined) {
    (0, _invariant2.default)(functionInstance.residualFunctionBindings instanceof Map);
    var residualBindings = functionInstance.residualFunctionBindings;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = residualBindings[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _ref5 = _step3.value;

        var _ref6 = _slicedToArray(_ref5, 2);

        var _ref6$ = _ref6[1];
        var declarativeEnvironmentRecord = _ref6$.declarativeEnvironmentRecord;
        var value = _ref6$.value;

        // if declarativeEnvironmentRecord is null, it's likely a global binding
        // so we can assume that we can still hoist this function
        if (declarativeEnvironmentRecord !== null) {
          (0, _invariant2.default)(value instanceof _index.Value);
          if (!canHoistValue(realm, value, residualHeapVisitor, visitedValues)) {
            return false;
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    realm.react.hoistableFunctions.set(func, true);
    return true;
  }
  realm.react.hoistableFunctions.set(func, false);
  return false;
}

function canHoistAbstract(realm, abstract, residualHeapVisitor) {
  // get the scopes for this abstract value
  var scopes = residualHeapVisitor.values.get(abstract);
  // we can safely hoist abstracts that are created in the common scope
  if (scopes !== undefined) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = scopes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var scope = _step4.value;

        var currentAdditionalFunction = residualHeapVisitor.commonScope;
        (0, _invariant2.default)(currentAdditionalFunction instanceof _index.FunctionValue);
        if (scope === currentAdditionalFunction.parent) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  }
  return false;
}

function isPrimitive(realm, value) {
  return value instanceof _index.StringValue || value instanceof _index.NumberValue || value instanceof _index.SymbolValue || value instanceof _index.BooleanValue || value === realm.intrinsics.null || value === realm.intrinsics.undefined;
}

function canHoistValue(realm, value, residualHeapVisitor, visitedValues) {
  if (visitedValues.has(value)) {
    // If there is a cycle, bail out.
    // TODO: is there some way to *not* bail out in this case?
    // Currently if we don't, the output is broken.
    return false;
  }
  visitedValues.add(value);
  var canHoist = value instanceof _index.ArrayValue && canHoistArray(realm, value, residualHeapVisitor, visitedValues) || value instanceof _index.FunctionValue && canHoistFunction(realm, value, residualHeapVisitor, visitedValues) || value instanceof _index.ObjectValue && canHoistObject(realm, value, residualHeapVisitor, visitedValues) || value instanceof _index.AbstractValue && canHoistAbstract(realm, value, residualHeapVisitor) || isPrimitive(realm, value);
  visitedValues.delete(value);
  return canHoist;
}

function canHoistReactElement(realm, reactElement, residualHeapVisitor, visitedValues) {
  if (realm.react.hoistableReactElements.has(reactElement)) {
    // cast because Flow thinks that we may have set a value to be something other than a boolean?
    return realm.react.hoistableReactElements.get(reactElement);
  }
  if (residualHeapVisitor === undefined) {
    return false;
  }
  var type = (0, _index2.Get)(realm, reactElement, "type");
  var ref = (0, _index2.Get)(realm, reactElement, "ref");
  var key = (0, _index2.Get)(realm, reactElement, "key");
  var props = (0, _index2.Get)(realm, reactElement, "props");

  if (visitedValues === undefined) {
    visitedValues = new Set();
    visitedValues.add(reactElement);
  }
  if (canHoistValue(realm, type, residualHeapVisitor, visitedValues) &&
  // we can't hoist string "refs" or if they're abstract, as they might be abstract strings
  !(ref instanceof String || ref instanceof _index.AbstractValue) && canHoistValue(realm, ref, residualHeapVisitor, visitedValues) && canHoistValue(realm, key, residualHeapVisitor, visitedValues) && canHoistValue(realm, props, residualHeapVisitor, visitedValues)) {
    realm.react.hoistableReactElements.set(reactElement, true);
    return true;
  }
  realm.react.hoistableReactElements.set(reactElement, false);
  return false;
}
//# sourceMappingURL=hoisting.js.map