"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

// ExpectedBailOut is like an error, that gets thrown during the reconcilation phase
// allowing the reconcilation to continue on other branches of the tree, the message
// given to ExpectedBailOut will be assigned to the value.$BailOutReason property and serialized
// as a comment in the output source to give the user hints as to what they need to do
// to fix the bail-out case
var ExpectedBailOut = exports.ExpectedBailOut = function ExpectedBailOut(message) {
  _classCallCheck(this, ExpectedBailOut);

  this.message = message;
  var self = new Error(message);
  Object.setPrototypeOf(self, ExpectedBailOut.prototype);
  return self;
};

Object.setPrototypeOf(ExpectedBailOut, Error);
Object.setPrototypeOf(ExpectedBailOut.prototype, Error.prototype);

// SimpleClassBailOuts only occur when a simple class instance is created and used
// bailing out here will result in a complex class instance being created after
// and an alternative complex class component route being used

var SimpleClassBailOut = exports.SimpleClassBailOut = function SimpleClassBailOut(message) {
  _classCallCheck(this, SimpleClassBailOut);

  var self = new Error(message);
  Object.setPrototypeOf(self, SimpleClassBailOut.prototype);
  return self;
};

Object.setPrototypeOf(SimpleClassBailOut, Error);
Object.setPrototypeOf(SimpleClassBailOut.prototype, Error.prototype);
//# sourceMappingURL=errors.js.map