{"version":3,"sources":["../src/environment.js"],"names":["leakBinding","mightBecomeAnObject","t","sourceMap","require","deriveGetBinding","realm","binding","types","topVal","values","generator","undefined","derive","_","context","serializeBinding","environment","hasLeaked","recordModifiedBinding","EnvironmentRecord","isReadOnly","DeclarativeEnvironmentRecord","bindings","Object","create","frozen","N","envRec","D","isGlobal","initialized","mutable","deletable","name","intrinsics","S","strict","V","value","empty","createErrorThrowCompletion","ReferenceError","CreateMutableBinding","InitializeBinding","leakValue","emitBindingAssignment","TypeError","ObjectEnvironmentRecord","obj","object","foundBinding","withEnvironment","unscopables","SymbolUnscopables","blocked","ToBooleanPartial","throwIfNotConcrete","configValue","DefinePropertyOrThrow","writable","enumerable","configurable","SetMutableBinding","Set","$Delete","FunctionEnvironmentRecord","$ThisBindingStatus","$ThisValue","$HomeObject","home","$GetPrototypeOf","GlobalEnvironmentRecord","DclRec","$DeclarativeRecord","HasBinding","ObjRec","$ObjectRecord","CreateImmutableBinding","GetBindingValue","DeleteBinding","globalObject","existingProp","status","varNames","$VarNames","indexOf","splice","$GlobalThisValue","varDeclaredNames","$GetOwnProperty","ThrowIfMightHaveBeenDeleted","hasProperty","extensible","push","desc","uid","LexicalEnvironment","destroyed","_uid","environmentRecord","globalAst","rvalue","globalValue","evaluate","PutValue","ast","strictCode","metadata","partiallyEvaluateCompletion","result","partial_ast","partial_io","Reference","GetValue","partiallyEvaluate","err","Error","evaluateCompletion","containsBreakOrContinue","reportIntrospectionError","joinCondition","evaluateAbstract","constructor","sources","sourceType","asts","code","directives","source","node","fileContents","filePath","sourceMapContents","length","fixup_source_locations","fixup_filenames","concat","program","body","e","error","message","$Get","location","start","line","column","end","diagnostic","handleError","file","onParse","lexicalEnvironment","variableEnvironment","pushContext","res","concatenateAndParse","popContext","onDestroyScope","activeLexicalEnvironments","size","options","partialAST","partiallyEvaluateCompletionDeref","type","fileAst","prog","sourceMaps","filename","map","smc","SourceMapConsumer","loc","fixup","fixup_comments","leadingComments","innerComments","trailingComments","new_loc","new_pos","old_pos","originalPositionFor","comments","c","cloc","debuggerInstance","checkForActions","currentLocation","testTimeout","evaluator","evaluators","partialEvaluator","partialEvaluators","base","getType","refName","thisValue","referencedName","mightNotBeString","mightNotBeNumber"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNode,\n  BabelNodeComment,\n  BabelNodeFile,\n  BabelNodeLVal,\n  BabelNodePosition,\n  BabelNodeStatement,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { Realm } from \"./realm.js\";\nimport type { SourceFile, SourceMap, SourceType } from \"./types.js\";\n\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ThrowCompletion,\n} from \"./completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"./errors.js\";\nimport { defaultOptions } from \"./options\";\nimport type { PartialEvaluatorOptions } from \"./options\";\nimport { ExecutionContext } from \"./realm.js\";\nimport {\n  AbstractValue,\n  NullValue,\n  SymbolValue,\n  BooleanValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  AbstractObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"./values/index.js\";\nimport generate from \"babel-generator\";\nimport parse from \"./utils/parse.js\";\nimport invariant from \"./invariant.js\";\nimport traverseFast from \"./utils/traverse-fast.js\";\nimport { HasProperty, Get, IsExtensible, HasOwnProperty, IsDataDescriptor } from \"./methods/index.js\";\nimport { Environment, Leak, Properties, To } from \"./singletons.js\";\nimport * as t from \"babel-types\";\nimport { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport PrimitiveValue from \"./values/PrimitiveValue\";\n\nconst sourceMap = require(\"source-map\");\n\nfunction deriveGetBinding(realm: Realm, binding: Binding) {\n  let types = TypesDomain.topVal;\n  let values = ValuesDomain.topVal;\n  invariant(realm.generator !== undefined);\n  return realm.generator.derive(types, values, [], (_, context) => context.serializeBinding(binding));\n}\n\nexport function leakBinding(binding: Binding) {\n  let realm = binding.environment.realm;\n  if (!binding.hasLeaked) {\n    realm.recordModifiedBinding(binding).hasLeaked = true;\n  }\n}\n\n// ECMA262 8.1.1\nexport class EnvironmentRecord {\n  realm: Realm;\n  isReadOnly: boolean;\n  $NewTarget: void | ObjectValue;\n\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.isReadOnly = false;\n  }\n\n  +HasBinding: (N: string) => boolean;\n  +CreateMutableBinding: (N: string, D: boolean, isGlobal?: boolean) => Value;\n  +CreateImmutableBinding: (N: string, S: boolean, isGlobal?: boolean) => Value;\n  +InitializeBinding: (N: string, V: Value) => Value;\n  +SetMutableBinding: (N: string, V: Value, S: boolean) => Value;\n  +GetBindingValue: (N: string, S: boolean) => Value;\n  +DeleteBinding: (N: string) => boolean;\n  +HasThisBinding: () => boolean;\n  +GetThisBinding: () => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n  +HasSuperBinding: () => boolean;\n  +WithBaseObject: () => Value;\n  +BindThisValue: (\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ) => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n}\n\nexport type Binding = {\n  value?: Value,\n  initialized?: boolean,\n  mutable?: boolean,\n  deletable?: boolean,\n  // back-references to the environment containing the binding and the key\n  // used to access this binding\n  environment: EnvironmentRecord,\n  name: string,\n  isGlobal: boolean,\n  // bindings that are assigned to inside loops with abstract termination conditions need temporal locations\n  phiNode?: AbstractValue,\n  hasLeaked: boolean,\n};\n\n// ECMA262 8.1.1.1\nexport class DeclarativeEnvironmentRecord extends EnvironmentRecord {\n  constructor(realm: Realm) {\n    super(realm);\n    this.bindings = (Object.create(null): any);\n    this.frozen = false;\n  }\n\n  bindings: { [name: string]: Binding };\n  // Frozen Records cannot have bindings created or deleted but can have bindings updated\n  frozen: boolean;\n\n  // ECMA262 8.1.1.1.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings[N]) return true;\n\n    // 3. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.2\n  CreateMutableBinding(N: string, D: boolean, isGlobal: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      mutable: true,\n      deletable: D,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      hasLeaked: false,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.3\n  CreateImmutableBinding(N: string, S: boolean, isGlobal: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      strict: S,\n      deletable: false,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      hasLeaked: false,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    invariant(binding && !binding.initialized, `shouldn't have the binding ${N}`);\n\n    // 3. Set the bound value for N in envRec to V.\n    this.realm.recordModifiedBinding(binding).value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.initialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // We can mutate frozen bindings because of captured bindings.\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. If envRec does not have a binding for N, then\n    if (!binding) {\n      // a. If S is true, throw a ReferenceError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);\n      }\n\n      // b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(N, true);\n\n      // c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(N, V);\n\n      // d. Return NormalCompletion(empty).\n      return this.realm.intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, let S be true.\n    if (binding.strict) S = true;\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);\n    } else if (binding.mutable) {\n      // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n      if (binding.hasLeaked) {\n        Leak.leakValue(realm, V);\n        invariant(realm.generator);\n        realm.generator.emitBindingAssignment(binding, V);\n      } else {\n        realm.recordModifiedBinding(binding).value = V;\n      }\n    } else {\n      // 6. Else,\n      // a. Assert: This is an attempt to change the value of an immutable binding.\n\n      // b. If S is true, throw a TypeError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"attempt to change immutable binding\");\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec has a binding for N.\n    invariant(binding, \"expected binding\");\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    if (binding.hasLeaked) {\n      return deriveGetBinding(realm, binding);\n    }\n    invariant(binding.value);\n    return binding.value;\n  }\n\n  // ECMA262 8.1.1.1.7\n  DeleteBinding(N: string): boolean {\n    invariant(!this.frozen);\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    invariant(envRec.bindings[N], \"expected binding to exist\");\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!envRec.bindings[N].deletable) return false;\n\n    // 4. Remove the binding for N from envRec.\n    this.realm.recordModifiedBinding(envRec.bindings[N]).value = undefined;\n    delete envRec.bindings[N];\n\n    // 5. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.1.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.2\nexport class ObjectEnvironmentRecord extends EnvironmentRecord {\n  object: ObjectValue | AbstractObjectValue;\n  withEnvironment: boolean;\n\n  constructor(realm: Realm, obj: ObjectValue | AbstractObjectValue) {\n    super(realm);\n    this.object = obj;\n  }\n\n  // ECMA262 8.1.1.2.1\n  HasBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = this.object;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    let foundBinding = HasProperty(realm, bindings, N);\n\n    // 4. If foundBinding is false, return false.\n    if (!foundBinding) return false;\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) return true;\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    let unscopables = Get(realm, bindings, realm.intrinsics.SymbolUnscopables);\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables instanceof ObjectValue || unscopables instanceof AbstractObjectValue) {\n      // a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      let blocked = To.ToBooleanPartial(realm, Get(realm, unscopables, N));\n\n      // b. If blocked is true, return false.\n      if (blocked) return false;\n    }\n    unscopables.throwIfNotConcrete();\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.2.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. If D is true, let configValue be true; otherwise let configValue be false.\n    let configValue = D ? true : false;\n\n    // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).\n    return new BooleanValue(\n      realm,\n      Properties.DefinePropertyOrThrow(realm, bindings, N, {\n        value: realm.intrinsics.undefined,\n        writable: true,\n        enumerable: true,\n        configurable: configValue,\n      })\n    );\n  }\n\n  // ECMA262 8.1.1.2.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    invariant(false);\n  }\n\n  // ECMA262 8.1.1.2.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(N, V, false);\n  }\n\n  // ECMA262 8.1.1.2.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return new BooleanValue(realm, Properties.Set(realm, bindings, N, V, S));\n  }\n\n  // ECMA262 8.1.1.2.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    let value = HasProperty(realm, bindings, N);\n\n    // 4. If value is false, then\n    if (!value) {\n      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (!S) {\n        return realm.intrinsics.undefined;\n      } else {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return Get(realm, bindings, N);\n  }\n\n  // ECMA262 8.1.1.2.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings.$Delete(N);\n  }\n\n  // ECMA262 8.1.1.2.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.10\n  WithBaseObject(): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) return envRec.object;\n\n    // 3. Otherwise, return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.3\nexport class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  $ThisBindingStatus: \"lexical\" | \"initialized\" | \"uninitialized\";\n  $ThisValue: UndefinedValue | NullValue | ObjectValue | AbstractObjectValue;\n  $HomeObject: void | ObjectValue;\n  $FunctionObject: FunctionValue;\n\n  // ECMA262 8.1.1.3.1\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"initialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec.$ThisValue = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec.$ThisBindingStatus = \"initialized\";\n\n    // 6. Return V.\n    return V;\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    return envRec.$ThisBindingStatus === \"lexical\" ? false : true;\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec.$ThisBindingStatus === \"lexical\") return false;\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec.$HomeObject === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"uninitialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec.$ThisValue;\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): ObjectValue | NullValue | UndefinedValue {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let home be the value of envRec.[[HomeObject]].\n    let home = envRec.$HomeObject;\n\n    // 3. If home has the value undefined, return undefined.\n    if (home === undefined) return this.realm.intrinsics.undefined;\n\n    // 4. Assert: Type(home) is Object.\n    invariant(home instanceof ObjectValue, \"expected object value\");\n\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home.$GetPrototypeOf();\n  }\n}\n\n// ECMA262 8.1.1.4\nexport class GlobalEnvironmentRecord extends EnvironmentRecord {\n  $DeclarativeRecord: EnvironmentRecord;\n  $ObjectRecord: ObjectEnvironmentRecord;\n  $VarNames: Array<string>;\n  $GlobalThisValue: ObjectValue;\n\n  // ECMA262 8.1.1.4.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (DclRec.HasBinding(N)) return true;\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return ObjRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return DclRec.CreateMutableBinding(N, D, true);\n  }\n\n  // ECMA262 8.1.1.4.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return DclRec.CreateImmutableBinding(N, S, true);\n  }\n\n  // ECMA262 8.1.1.4.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.InitializeBinding(N, V).\n      return DclRec.InitializeBinding(N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return ObjRec.InitializeBinding(N, V);\n  }\n\n  // ECMA262 8.1.1.4.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.SetMutableBinding(N, V, S).\n      return DclRec.SetMutableBinding(N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return ObjRec.SetMutableBinding(N, V, S);\n  }\n\n  // ECMA262 8.1.1.4.6\n  GetBindingValue(N: string, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.GetBindingValue(N, S).\n      return DclRec.GetBindingValue(N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return ObjRec.GetBindingValue(N, S);\n  }\n\n  // ECMA262 8.1.1.4.7\n  DeleteBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.DeleteBinding(N).\n      return DclRec.DeleteBinding(N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    let existingProp = HasOwnProperty(realm, globalObject, N);\n\n    // 7. If existingProp is true, then\n    if (existingProp) {\n      // a. Let status be ? ObjRec.DeleteBinding(N).\n      let status = ObjRec.DeleteBinding(N);\n\n      // b. If status is true, then\n      if (status) {\n        // i. Let varNames be envRec.[[VarNames]].\n        let varNames = envRec.$VarNames;\n\n        // ii. If N is an element of varNames, remove that element from the varNames.\n        if (varNames.indexOf(N) >= 0) {\n          varNames.splice(varNames.indexOf(N), 1);\n        }\n      }\n\n      // c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.8\n  HasThisBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.9\n  HasSuperBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.4.11\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    invariant(envRec.$GlobalThisValue);\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec.$GlobalThisValue;\n  }\n\n  // ECMA262 8.1.1.4.12\n  HasVarDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 3. If varDeclaredNames contains the value of N, return true.\n    if (varDeclaredNames.indexOf(N) >= 0) return true;\n\n    // 4. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.13\n  HasLexicalDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. Return DclRec.HasBinding(N).\n    return DclRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.14\n  HasRestrictedGlobalProperty(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return false.\n    if (!existingProp) return false;\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp.configurable) return false;\n\n    // 7. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.15\n  CanDeclareGlobalVar(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty) return true;\n\n    // 6. Return ? IsExtensible(globalObject).\n    return IsExtensible(realm, globalObject);\n  }\n\n  // ECMA262 8.1.1.4.16\n  CanDeclareGlobalFunction(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (!existingProp) return IsExtensible(realm, globalObject);\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp.configurable) return true;\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.\n    if (IsDataDescriptor(realm, existingProp) && existingProp.writable && existingProp.enumerable) {\n      return true;\n    }\n\n    // 8. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.17\n  CreateGlobalVarBinding(N: string, D: boolean) {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    let extensible = IsExtensible(realm, globalObject);\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (!hasProperty && extensible) {\n      // a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      ObjRec.CreateMutableBinding(N, D);\n\n      // b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 8. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 9. Return NormalCompletion(empty).\n  }\n\n  // ECMA262 8.1.1.4.18\n  CreateGlobalFunctionBinding(N: string, V: Value, D: boolean) {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    let desc;\n    if (!existingProp || existingProp.configurable) {\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.\n      desc = { value: V, writable: true, enumerable: true, configurable: D };\n    } else {\n      // 6. Else,\n      Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V }.\n      desc = { value: V };\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    Properties.DefinePropertyOrThrow(this.realm, globalObject, N, desc);\n\n    // 8. Record that the binding for N in ObjRec has been initialized.\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    Properties.Set(this.realm, globalObject, N, V, false);\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 11. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 12. Return NormalCompletion(empty).\n  }\n}\n\n// ECMA262 8.1\nlet uid = 0;\nexport class LexicalEnvironment {\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.destroyed = false;\n    this._uid = uid++;\n  }\n\n  // For debugging it is convenient to have an ID for each of these.\n  _uid: number;\n  destroyed: boolean;\n  environmentRecord: EnvironmentRecord;\n  parent: null | LexicalEnvironment;\n  realm: Realm;\n\n  destroy() {\n    this.destroyed = true;\n    // Once the containing environment is destroyed, we can no longer add or remove entries from the environmentRecord\n    // (but we can update existing values).\n    if (this.environmentRecord instanceof DeclarativeEnvironmentRecord) {\n      this.environmentRecord.frozen = true;\n    }\n  }\n\n  assignToGlobal(globalAst: BabelNodeLVal, rvalue: Value) {\n    let globalValue = this.evaluate(globalAst, false);\n    Properties.PutValue(this.realm, globalValue, rvalue);\n  }\n\n  partiallyEvaluateCompletionDeref(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Value, BabelNode, Array<BabelNodeStatement>] {\n    let [result, partial_ast, partial_io] = this.partiallyEvaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) {\n      result = Environment.GetValue(this.realm, result);\n    }\n    return [result, partial_ast, partial_io];\n  }\n\n  partiallyEvaluateCompletion(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    try {\n      return this.partiallyEvaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return [err, ast, []];\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateCompletionDeref(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value {\n    let result = this.evaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) result = Environment.GetValue(this.realm, result);\n    return result;\n  }\n\n  evaluateCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value | Reference {\n    try {\n      return this.evaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (\n        (err instanceof JoinedAbruptCompletions || err instanceof PossiblyNormalCompletion) &&\n        err.containsBreakOrContinue()\n      ) {\n        AbstractValue.reportIntrospectionError(err.joinCondition);\n        throw new FatalError();\n      }\n      if (err instanceof AbruptCompletion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateAbstractCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): Completion | Value | Reference {\n    try {\n      return this.evaluateAbstract(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      if (err instanceof Object) throw new FatalError(err.constructor.name + \": \" + err);\n      throw new FatalError(err);\n    }\n  }\n\n  concatenateAndParse(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\"\n  ): [BabelNodeFile, { [string]: string }] {\n    let asts = [];\n    let code = {};\n    let directives = [];\n    for (let source of sources) {\n      try {\n        let node = parse(this.realm, source.fileContents, source.filePath, sourceType);\n        if (source.sourceMapContents && source.sourceMapContents.length > 0)\n          this.fixup_source_locations(node, source.sourceMapContents);\n        this.fixup_filenames(node);\n        asts = asts.concat(node.program.body);\n        code[source.filePath] = source.fileContents;\n        directives = directives.concat(node.program.directives);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) {\n          let error = e.value;\n          if (error instanceof ObjectValue) {\n            let message = error.$Get(\"message\", error);\n            message.value = `Syntax error: ${message.value}`;\n            e.location.source = source.filePath;\n            // the position was not located properly on the\n            // syntax errors happen on one given position, so start position = end position\n            e.location.start = { line: e.location.line, column: e.location.column };\n            e.location.end = { line: e.location.line, column: e.location.column };\n            let diagnostic = new CompilerDiagnostic(message.value, e.location, \"PP1004\", \"FatalError\");\n            this.realm.handleError(diagnostic);\n            throw new FatalError(message.value);\n          }\n        }\n        throw e;\n      }\n    }\n    return [t.file(t.program(asts, directives)), code];\n  }\n\n  executeSources(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): [AbruptCompletion | Value, { [string]: string }] {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let res, code;\n    try {\n      let ast;\n      [ast, code] = this.concatenateAndParse(sources, sourceType);\n      if (onParse) onParse(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      this.realm.onDestroyScope(context.lexicalEnvironment);\n      if (!this.destroyed) this.realm.onDestroyScope(this);\n      invariant(this.realm.activeLexicalEnvironments.size === 0);\n    }\n    if (res instanceof AbruptCompletion) return [res, code];\n\n    return [Environment.GetValue(this.realm, res), code];\n  }\n\n  executePartialEvaluator(\n    sources: Array<SourceFile>,\n    options: PartialEvaluatorOptions = defaultOptions,\n    sourceType: SourceType = \"script\"\n  ): AbruptCompletion | { code: string, map?: SourceMap } {\n    let [ast, code] = this.concatenateAndParse(sources, sourceType);\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let partialAST;\n    try {\n      [, partialAST] = this.partiallyEvaluateCompletionDeref(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      this.realm.onDestroyScope(context.lexicalEnvironment);\n      if (!this.destroyed) this.realm.onDestroyScope(this);\n      invariant(this.realm.activeLexicalEnvironments.size === 0);\n    }\n    invariant(partialAST.type === \"File\");\n    let fileAst = ((partialAST: any): BabelNodeFile);\n    let prog = t.program(fileAst.program.body, ast.program.directives);\n    this.fixup_filenames(prog);\n    // The type signature for generate is not complete, hence the any\n    return generate(prog, { sourceMaps: options.sourceMaps }, (code: any));\n  }\n\n  execute(\n    code: string,\n    filename: string,\n    map: string = \"\",\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): AbruptCompletion | Value {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n\n    this.realm.pushContext(context);\n\n    let ast, res;\n    try {\n      try {\n        ast = parse(this.realm, code, filename, sourceType);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n      if (onParse) onParse(ast);\n      if (map.length > 0) this.fixup_source_locations(ast, map);\n      this.fixup_filenames(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      // Avoid destroying \"this\" scope as execute may be called many times.\n      if (context.lexicalEnvironment !== this) this.realm.onDestroyScope(context.lexicalEnvironment);\n      invariant(this.realm.activeLexicalEnvironments.size === 1);\n    }\n    if (res instanceof AbruptCompletion) return res;\n\n    return Environment.GetValue(this.realm, res);\n  }\n\n  fixup_source_locations(ast: BabelNode, map: string) {\n    const smc = new sourceMap.SourceMapConsumer(map);\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc) return false;\n      fixup(loc, loc.start);\n      fixup(loc, loc.end);\n      fixup_comments(node.leadingComments);\n      fixup_comments(node.innerComments);\n      fixup_comments(node.trailingComments);\n      return false;\n\n      function fixup(new_loc: BabelNodeSourceLocation, new_pos: BabelNodePosition) {\n        let old_pos = smc.originalPositionFor({ line: new_pos.line, column: new_pos.column });\n        if (old_pos.source === null) return;\n        new_pos.line = old_pos.line;\n        new_pos.column = old_pos.column;\n        new_loc.source = old_pos.source;\n      }\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>) {\n        if (!comments) return;\n        for (let c of comments) {\n          let cloc = c.loc;\n          if (!cloc) continue;\n          fixup(cloc, cloc.start);\n          fixup(cloc, cloc.end);\n        }\n      }\n    });\n  }\n\n  fixup_filenames(ast: BabelNode) {\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc || !loc.source) {\n        node.leadingComments = null;\n        node.innerComments = null;\n        node.trailingComments = null;\n        node.loc = null;\n      } else {\n        let filename = loc.source;\n        (loc: any).filename = filename;\n        fixup_comments(node.leadingComments, filename);\n        fixup_comments(node.innerComments, filename);\n        fixup_comments(node.trailingComments, filename);\n      }\n      return false;\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>, filename: string) {\n        if (!comments) return;\n        for (let c of comments) {\n          if (c.loc) {\n            (c.loc: any).filename = filename;\n            c.loc.source = filename;\n          }\n        }\n      }\n    });\n  }\n\n  evaluate(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    if (this.realm.debuggerInstance) {\n      this.realm.debuggerInstance.checkForActions(ast);\n    }\n    let res = this.evaluateAbstract(ast, strictCode, metadata);\n    invariant(res instanceof Value || res instanceof Reference, ast.type);\n    return res;\n  }\n\n  evaluateAbstract(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    this.realm.currentLocation = ast.loc;\n    this.realm.testTimeout();\n\n    let evaluator = this.realm.evaluators[(ast.type: string)];\n    if (evaluator) {\n      let result = evaluator(ast, strictCode, this, this.realm, metadata);\n      return result;\n    }\n\n    throw new TypeError(`Unsupported node type ${ast.type}`);\n  }\n\n  partiallyEvaluate(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    let partialEvaluator = this.realm.partialEvaluators[(ast.type: string)];\n    if (partialEvaluator) {\n      return partialEvaluator(ast, strictCode, this, this.realm, metadata);\n    }\n\n    let err = new TypeError(`Unsupported node type ${ast.type}`);\n    throw err;\n  }\n}\n\n// ECMA262 6.2.3\n// A Reference is a resolved name or property binding. A Reference consists of three components, the base value,\n// the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object,\n// a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value of undefined indicates that the\n// Reference could not be resolved to a binding. The referenced name is a String or Symbol value.\nexport type BaseValue = void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;\nexport type ReferenceName = string | SymbolValue;\n\nexport function mightBecomeAnObject(base: Value): boolean {\n  let type = base.getType();\n  // The top Value type might be able to become an object. We let it\n  // pass and error later if it can't.\n  return (\n    type === Value ||\n    type === PrimitiveValue ||\n    type === BooleanValue ||\n    type === StringValue ||\n    type === SymbolValue ||\n    type === NumberValue\n  );\n}\n\nexport class Reference {\n  base: BaseValue | AbstractValue;\n  referencedName: ReferenceName | AbstractValue;\n  strict: boolean;\n  thisValue: void | Value;\n\n  constructor(\n    base: BaseValue | AbstractValue,\n    refName: ReferenceName | AbstractValue,\n    strict: boolean,\n    thisValue?: void | Value\n  ) {\n    invariant(\n      base instanceof AbstractObjectValue ||\n        base === undefined ||\n        base instanceof ObjectValue ||\n        base instanceof EnvironmentRecord ||\n        mightBecomeAnObject(base)\n    );\n    this.base = base;\n    this.referencedName = refName;\n    invariant(!(refName instanceof AbstractValue) || !(refName.mightNotBeString() && refName.mightNotBeNumber()));\n    this.strict = strict;\n    this.thisValue = thisValue;\n    invariant(thisValue === undefined || !(base instanceof EnvironmentRecord));\n  }\n}\n"]}