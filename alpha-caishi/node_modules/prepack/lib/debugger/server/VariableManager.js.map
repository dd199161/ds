{"version":3,"sources":["../../../src/debugger/server/VariableManager.js"],"names":["VariableManager","realm","_containerCache","Map","_referenceMap","_realm","value","cachedRef","get","undefined","varRef","add","set","reference","container","_getVariablesFromEnvRecord","environmentRecord","_getVariablesFromObject","_getAbstractValueContent","object","variables","names","properties","keys","name","binding","descriptor","variable","_getVariableFromValue","push","kindVar","kind","variablesReference","contents","argCount","args","arg","envRecord","_getVariablesFromDeclarativeEnv","declVars","$DeclarativeRecord","objVars","$ObjectRecord","concat","env","bindings","_getVariableFromConcreteValue","_getVariableFromAbstractValue","_getAbstractValueDisplay","getReferenceForValue","intrinsicName","startsWith","types","getType","toDisplayString","getKind","frameId","expression","evalRealm","isDirect","isStrict","contextStack","length","stackIndex","context","evalString","PerformEval","varInfo","result","displayValue","type","e","clean"],"mappings":";;;;;;;qjBAAA;;;;;;;;;AAYA;;AACA;;AAOA;;AASA;;;;AAEA;;AACA;;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;IACaA,e,WAAAA,e;AACX,2BAAYC,KAAZ,EAA0B;AAAA;;AACxB,SAAKC,eAAL,GAAuB,IAAIC,GAAJ,EAAvB;AACA,SAAKC,aAAL,GAAqB,gCAArB;AACA,SAAKC,MAAL,GAAcJ,KAAd;AACD;AACD;;AAEA;;;;;;;AAIA;AACA;yCACqBK,K,EAAkC;AACrD,UAAIC,YAAY,KAAKL,eAAL,CAAqBM,GAArB,CAAyBF,KAAzB,CAAhB;AACA,UAAIC,cAAcE,SAAlB,EAA6B;AAC3B,eAAOF,SAAP;AACD;;AAED,UAAIG,SAAS,KAAKN,aAAL,CAAmBO,GAAnB,CAAuBL,KAAvB,CAAb;AACA,WAAKJ,eAAL,CAAqBU,GAArB,CAAyBN,KAAzB,EAAgCI,MAAhC;AACA,aAAOA,MAAP;AACD;;AAED;;;;4CACwBG,S,EAAoC;AAC1D,UAAIC,YAAY,KAAKV,aAAL,CAAmBI,GAAnB,CAAuBK,SAAvB,CAAhB;AACA,UAAI,CAACC,SAAL,EAAgB,OAAO,EAAP;AAChB,UAAIA,oDAAJ,EAA6C;AAC3C,eAAO,KAAKC,0BAAL,CAAgCD,UAAUE,iBAA1C,CAAP;AACD,OAFD,MAEO,IAAIF,uCAAJ,EAAsC;AAC3C,eAAO,KAAKG,uBAAL,CAA6BH,SAA7B,CAAP;AACD,OAFM,MAEA,IAAIA,yCAAJ,EAAwC;AAC7C,eAAO,KAAKI,wBAAL,CAA8BJ,SAA9B,CAAP;AACD,OAFM,MAEA;AACL,iCAAU,KAAV,EAAiB,4BAAjB;AACD;AACF;;;4CAEuBK,M,EAAsC;AAC5D,UAAIC,YAAY,EAAhB;AACA,UAAIC,QAAQF,OAAOG,UAAP,CAAkBC,IAAlB,EAAZ;AAF4D;AAAA;AAAA;;AAAA;AAG5D,6BAAiBF,KAAjB,8HAAwB;AAAA,cAAfG,IAAe;;AACtB,cAAIC,UAAUN,OAAOG,UAAP,CAAkBd,GAAlB,CAAsBgB,IAAtB,CAAd;AACA,mCAAUC,YAAYhB,SAAtB;AACA,cAAIgB,QAAQC,UAAZ,EAAwB;AACtB,gBAAI,0BAAiB,KAAKrB,MAAtB,EAA8BoB,QAAQC,UAAtC,CAAJ,EAAuD;AACrD,kBAAIpB,QAAQmB,QAAQC,UAAR,CAAmBpB,KAA/B;AACA,kBAAIA,6BAAJ,EAA4B;AAC1B,oBAAIqB,WAAW,KAAKC,qBAAL,CAA2BJ,IAA3B,EAAiClB,KAAjC,CAAf;AACAc,0BAAUS,IAAV,CAAeF,QAAf;AACD;AACF;AACF;AACF;AAf2D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgB5D,aAAOP,SAAP;AACD;;;6CAEwBd,K,EAAuC;AAC9D,UAAIwB,UAAoB;AACtBN,cAAM,MADgB;AAEtBlB,eAAOA,MAAMyB,IAAN,IAAc,WAFC;AAGtBC,4BAAoB;AAHE,OAAxB;AAKA,UAAIC,WAA4B,CAACH,OAAD,CAAhC;AACA,UAAII,WAAW,CAAf;AAP8D;AAAA;AAAA;;AAAA;AAQ9D,8BAAgB5B,MAAM6B,IAAtB,mIAA4B;AAAA,cAAnBC,GAAmB;;AAC1BH,mBAASJ,IAAT,CAAc,KAAKD,qBAAL,CAA2B,SAASM,QAApC,EAA8CE,GAA9C,CAAd;AACAF;AACD;AAX6D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAY9D,aAAOD,QAAP;AACD;;;+CAE0BI,S,EAA+C;AACxE,UAAIA,8DAAJ,EAAuD;AACrD,eAAO,KAAKC,+BAAL,CAAqCD,SAArC,CAAP;AACD,OAFD,MAEO,IAAIA,yDAAJ,EAAkD;AACvD,YAAIA,UAAUlB,MAAV,8BAAJ,EAA6C;AAC3C,iBAAO,KAAKF,uBAAL,CAA6BoB,UAAUlB,MAAvC,CAAP;AACD,SAFD,MAEO,IAAIkB,UAAUlB,MAAV,sCAAJ,EAAqD;AAC1D;AACA,iBAAO,EAAP;AACD,SAHM,MAGA;AACL,mCAAU,KAAV,EAAiB,2CAAjB;AACD;AACF,OATM,MASA,IAAIkB,yDAAJ,EAAkD;AACvD,YAAIE,WAAW,KAAKxB,0BAAL,CAAgCsB,UAAUG,kBAA1C,CAAf;AACA,YAAIC,UAAU,KAAK1B,0BAAL,CAAgCsB,UAAUK,aAA1C,CAAd;AACA,eAAOH,SAASI,MAAT,CAAgBF,OAAhB,CAAP;AACD,OAJM,MAIA;AACL,iCAAU,KAAV,EAAiB,oCAAjB;AACD;AACF;;;oDAE+BG,G,EAAoD;AAClF,UAAIxB,YAAY,EAAhB;AACA,UAAIyB,WAAWD,IAAIC,QAAnB;AACA,WAAK,IAAIrB,IAAT,IAAiBqB,QAAjB,EAA2B;AACzB,YAAIpB,UAAUoB,SAASrB,IAAT,CAAd;AACA,YAAIC,QAAQnB,KAAZ,EAAmB;AACjB,cAAIqB,WAAW,KAAKC,qBAAL,CAA2BJ,IAA3B,EAAiCC,QAAQnB,KAAzC,CAAf;AACAc,oBAAUS,IAAV,CAAeF,QAAf;AACD;AACF;AACD,aAAOP,SAAP;AACD;;;0CAEqBI,I,EAAclB,K,EAAwB;AAC1D,UAAIA,qCAAJ,EAAoC;AAClC,eAAO,KAAKwC,6BAAL,CAAmCtB,IAAnC,EAAyClB,KAAzC,CAAP;AACD,OAFD,MAEO,IAAIA,qCAAJ,EAAoC;AACzC,eAAO,KAAKyC,6BAAL,CAAmCvB,IAAnC,EAAyClB,KAAzC,CAAP;AACD,OAFM,MAEA;AACL,iCAAU,KAAV,EAAiB,wCAAjB;AACD;AACF;;;kDAE6BkB,I,EAAclB,K,EAAgC;AAC1E,UAAIqB,WAAqB;AACvBH,cAAMA,IADiB;AAEvBlB,eAAO,KAAK0C,wBAAL,CAA8B1C,KAA9B,CAFgB;AAGvB0B,4BAAoB,KAAKiB,oBAAL,CAA0B3C,KAA1B;AAHG,OAAzB;AAKA,aAAOqB,QAAP;AACD;;;6CAEwBrB,K,EAA8B;AACrD,UAAIA,MAAM4C,aAAN,IAAuB,CAAC5C,MAAM4C,aAAN,CAAoBC,UAApB,CAA+B,GAA/B,CAA5B,EAAiE;AAC/D,eAAO7C,MAAM4C,aAAb;AACD;AACD,aAAO,cAAc5C,MAAM8C,KAAN,CAAYC,OAAZ,GAAsB7B,IAA3C;AACD;;;kDAE6BA,I,EAAclB,K,EAAgC;AAC1E,UAAIA,sCAAJ,EAAqC;AACnC,YAAIqB,WAAqB;AACvBH,gBAAMA,IADiB;AAEvBlB,iBAAOA,MAAMgD,eAAN,EAFgB;AAGvBtB,8BAAoB;AAHG,SAAzB;AAKA,eAAOL,QAAP;AACD,OAPD,MAOO,IAAIrB,mCAAJ,EAAkC;AACvC,YAAIqB,YAAqB;AACvBH,gBAAMA,IADiB;AAEvBlB,iBAAOA,MAAMiD,OAAN,EAFgB;AAGvBvB,8BAAoB,KAAKiB,oBAAL,CAA0B3C,KAA1B;AAHG,SAAzB;AAKA,eAAOqB,SAAP;AACD,OAPM,MAOA;AACL,iCAAU,KAAV,EAAiB,4CAAjB;AACD;AACF;;;6BAEQ6B,O,EAAwBC,U,EAAoC;AACnE,UAAIC,YAAY,KAAKrD,MAArB;AACA,UAAIsD,WAAW,KAAf;AACA,UAAIC,WAAW,KAAf;AACA,UAAIJ,YAAY/C,SAAhB,EAA2B;AACzB,YAAI+C,UAAU,CAAV,IAAeA,WAAW,KAAKnD,MAAL,CAAYwD,YAAZ,CAAyBC,MAAvD,EAA+D;AAC7D,gBAAM,iCAAkB,iBAAlB,EAAqC,4BAArC,CAAN;AACD;AACD;AACA,YAAIC,aAAa,KAAK1D,MAAL,CAAYwD,YAAZ,CAAyBC,MAAzB,GAAkC,CAAlC,GAAsCN,OAAvD;AACA,YAAIQ,UAAU,KAAK3D,MAAL,CAAYwD,YAAZ,CAAyBE,UAAzB,CAAd;AACAJ,mBAAW,IAAX;AACAC,mBAAW,IAAX;AACAF,oBAAYM,QAAQ/D,KAApB;AACD;;AAED,UAAIgE,aAAa,uBAAgB,KAAK5D,MAArB,EAA6BoD,UAA7B,CAAjB;AACA,UAAI;AACF,YAAInD,QAAQ,sBAAU4D,WAAV,CAAsB,KAAK7D,MAA3B,EAAmC4D,UAAnC,EAA+CP,SAA/C,EAA0DE,QAA1D,EAAoED,QAApE,CAAZ;AACA,YAAIQ,UAAU,KAAKvC,qBAAL,CAA2B6B,UAA3B,EAAuCnD,KAAvC,CAAd;AACA,YAAI8D,SAAyB;AAC3BrC,gBAAM,UADqB;AAE3BsC,wBAAcF,QAAQ7D,KAFK;AAG3BgE,gBAAMhE,MAAM+C,OAAN,GAAgB7B,IAHK;AAI3BQ,8BAAoBmC,QAAQnC;AAJD,SAA7B;AAMA,eAAOoC,MAAP;AACD,OAVD,CAUE,OAAOG,CAAP,EAAU;AACV,YAAIH,UAAyB;AAC3BrC,gBAAM,UADqB;AAE3BsC,iDAAqCZ,UAFV;AAG3Ba,gBAAM,SAHqB;AAI3BtC,8BAAoB;AAJO,SAA7B;AAMA,eAAOoC,OAAP;AACD;AACF;;;4BAEO;AACN,WAAKlE,eAAL,GAAuB,IAAIC,GAAJ,EAAvB;AACA,WAAKC,aAAL,CAAmBoE,KAAnB;AACD","file":"VariableManager.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Variable, EvaluateResult } from \"./../common/types.js\";\nimport { ReferenceMap } from \"./ReferenceMap.js\";\nimport {\n  LexicalEnvironment,\n  EnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  ObjectEnvironmentRecord,\n  GlobalEnvironmentRecord,\n} from \"./../../environment.js\";\nimport {\n  Value,\n  ConcreteValue,\n  PrimitiveValue,\n  ObjectValue,\n  AbstractObjectValue,\n  AbstractValue,\n  StringValue,\n} from \"./../../values/index.js\";\nimport invariant from \"./../common/invariant.js\";\nimport type { Realm } from \"./../../realm.js\";\nimport { IsDataDescriptor } from \"./../../methods/is.js\";\nimport { DebuggerError } from \"./../common/DebuggerError.js\";\nimport { Functions } from \"./../../singletons.js\";\n\ntype VariableContainer = LexicalEnvironment | ObjectValue | AbstractValue;\n\n// This class manages the handling of variable requests in the debugger\n// The DebugProtocol specifies collections of variables are to be fetched using a\n// unique reference ID called a variablesReference. This class can generate new\n// variablesReferences to pass to the UI and then perform lookups for those\n// variablesReferences when they are requested.\nexport class VariableManager {\n  constructor(realm: Realm) {\n    this._containerCache = new Map();\n    this._referenceMap = new ReferenceMap();\n    this._realm = realm;\n  }\n  // cache for created references\n  _containerCache: Map<VariableContainer, number>;\n  // map for looking up references\n  _referenceMap: ReferenceMap<VariableContainer>;\n  _realm: Realm;\n\n  // Given a container, either returns a cached reference for that container if\n  // it exists or return a new reference\n  getReferenceForValue(value: VariableContainer): number {\n    let cachedRef = this._containerCache.get(value);\n    if (cachedRef !== undefined) {\n      return cachedRef;\n    }\n\n    let varRef = this._referenceMap.add(value);\n    this._containerCache.set(value, varRef);\n    return varRef;\n  }\n\n  // The entry point for retrieving a collection of variables by a reference\n  getVariablesByReference(reference: number): Array<Variable> {\n    let container = this._referenceMap.get(reference);\n    if (!container) return [];\n    if (container instanceof LexicalEnvironment) {\n      return this._getVariablesFromEnvRecord(container.environmentRecord);\n    } else if (container instanceof ObjectValue) {\n      return this._getVariablesFromObject(container);\n    } else if (container instanceof AbstractValue) {\n      return this._getAbstractValueContent(container);\n    } else {\n      invariant(false, \"Invalid variable container\");\n    }\n  }\n\n  _getVariablesFromObject(object: ObjectValue): Array<Variable> {\n    let variables = [];\n    let names = object.properties.keys();\n    for (let name of names) {\n      let binding = object.properties.get(name);\n      invariant(binding !== undefined);\n      if (binding.descriptor) {\n        if (IsDataDescriptor(this._realm, binding.descriptor)) {\n          let value = binding.descriptor.value;\n          if (value instanceof Value) {\n            let variable = this._getVariableFromValue(name, value);\n            variables.push(variable);\n          }\n        }\n      }\n    }\n    return variables;\n  }\n\n  _getAbstractValueContent(value: AbstractValue): Array<Variable> {\n    let kindVar: Variable = {\n      name: \"kind\",\n      value: value.kind || \"undefined\",\n      variablesReference: 0,\n    };\n    let contents: Array<Variable> = [kindVar];\n    let argCount = 1;\n    for (let arg of value.args) {\n      contents.push(this._getVariableFromValue(\"arg-\" + argCount, arg));\n      argCount++;\n    }\n    return contents;\n  }\n\n  _getVariablesFromEnvRecord(envRecord: EnvironmentRecord): Array<Variable> {\n    if (envRecord instanceof DeclarativeEnvironmentRecord) {\n      return this._getVariablesFromDeclarativeEnv(envRecord);\n    } else if (envRecord instanceof ObjectEnvironmentRecord) {\n      if (envRecord.object instanceof ObjectValue) {\n        return this._getVariablesFromObject(envRecord.object);\n      } else if (envRecord.object instanceof AbstractObjectValue) {\n        // TODO: call _getVariablesFromAbstractObject when it is implemented\n        return [];\n      } else {\n        invariant(false, \"Invalid type of object environment record\");\n      }\n    } else if (envRecord instanceof GlobalEnvironmentRecord) {\n      let declVars = this._getVariablesFromEnvRecord(envRecord.$DeclarativeRecord);\n      let objVars = this._getVariablesFromEnvRecord(envRecord.$ObjectRecord);\n      return declVars.concat(objVars);\n    } else {\n      invariant(false, \"Invalid type of environment record\");\n    }\n  }\n\n  _getVariablesFromDeclarativeEnv(env: DeclarativeEnvironmentRecord): Array<Variable> {\n    let variables = [];\n    let bindings = env.bindings;\n    for (let name in bindings) {\n      let binding = bindings[name];\n      if (binding.value) {\n        let variable = this._getVariableFromValue(name, binding.value);\n        variables.push(variable);\n      }\n    }\n    return variables;\n  }\n\n  _getVariableFromValue(name: string, value: Value): Variable {\n    if (value instanceof ConcreteValue) {\n      return this._getVariableFromConcreteValue(name, value);\n    } else if (value instanceof AbstractValue) {\n      return this._getVariableFromAbstractValue(name, value);\n    } else {\n      invariant(false, \"Value is neither concrete nor abstract\");\n    }\n  }\n\n  _getVariableFromAbstractValue(name: string, value: AbstractValue): Variable {\n    let variable: Variable = {\n      name: name,\n      value: this._getAbstractValueDisplay(value),\n      variablesReference: this.getReferenceForValue(value),\n    };\n    return variable;\n  }\n\n  _getAbstractValueDisplay(value: AbstractValue): string {\n    if (value.intrinsicName && !value.intrinsicName.startsWith(\"_\")) {\n      return value.intrinsicName;\n    }\n    return \"Abstract \" + value.types.getType().name;\n  }\n\n  _getVariableFromConcreteValue(name: string, value: ConcreteValue): Variable {\n    if (value instanceof PrimitiveValue) {\n      let variable: Variable = {\n        name: name,\n        value: value.toDisplayString(),\n        variablesReference: 0,\n      };\n      return variable;\n    } else if (value instanceof ObjectValue) {\n      let variable: Variable = {\n        name: name,\n        value: value.getKind(),\n        variablesReference: this.getReferenceForValue(value),\n      };\n      return variable;\n    } else {\n      invariant(false, \"Concrete value must be primitive or object\");\n    }\n  }\n\n  evaluate(frameId: void | number, expression: string): EvaluateResult {\n    let evalRealm = this._realm;\n    let isDirect = false;\n    let isStrict = false;\n    if (frameId !== undefined) {\n      if (frameId < 0 || frameId >= this._realm.contextStack.length) {\n        throw new DebuggerError(\"Invalid command\", \"Invalid value for frame ID\");\n      }\n      // frameId's are in reverse order of context stack\n      let stackIndex = this._realm.contextStack.length - 1 - frameId;\n      let context = this._realm.contextStack[stackIndex];\n      isDirect = true;\n      isStrict = true;\n      evalRealm = context.realm;\n    }\n\n    let evalString = new StringValue(this._realm, expression);\n    try {\n      let value = Functions.PerformEval(this._realm, evalString, evalRealm, isStrict, isDirect);\n      let varInfo = this._getVariableFromValue(expression, value);\n      let result: EvaluateResult = {\n        kind: \"evaluate\",\n        displayValue: varInfo.value,\n        type: value.getType().name,\n        variablesReference: varInfo.variablesReference,\n      };\n      return result;\n    } catch (e) {\n      let result: EvaluateResult = {\n        kind: \"evaluate\",\n        displayValue: `Failed to evaluate: ${expression}`,\n        type: \"unknown\",\n        variablesReference: 0,\n      };\n      return result;\n    }\n  }\n\n  clean() {\n    this._containerCache = new Map();\n    this._referenceMap.clean();\n  }\n}\n"]}