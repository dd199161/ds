{"version":3,"sources":["../../../src/debugger/adapter/DebugAdapter.js"],"names":["DebugProtocol","PrepackDebugSession","setDebuggerLinesStartAt1","setDebuggerColumnsStartAt1","direction","time","Date","now","filePath","_adapterChannel","registerChannelEvent","STOPPED_RESPONSE","response","result","kind","sendEvent","reason","line","column","PREPACK_THREAD_ID","STEPINTO_RESPONSE","args","_clientID","clientID","body","supportsConfigurationDoneRequest","sendResponse","CLI_CLIENTID","run","DEFAULT_REQUEST_ID","runResponse","inFilePath","_generateDebugFilePath","outFilePath","_registerMessageCallbacks","launchArgs","sourceFile","prepackRuntime","prepackArguments","debugInFilePath","debugOutFilePath","outputCallback","data","outputEvent","toString","exitCallback","process","exit","launch","request_seq","dbgResponse","source","path","breakpoints","breakpointInfos","breakpoint","breakpointInfo","requestID","push","setBreakpoints","verified","getStackFrames","frameInfos","stackframes","frames","frameInfo","fileName","frame","id","name","functionName","stackFrames","thread","threads","getScopes","frameId","scopeInfos","scopes","scopeInfo","scope","variablesReference","expensive","getVariables","variableInfos","variables","varInfo","variable","value","stepInto","stepOver","evaluate","expression","evalResult","displayValue","type"],"mappings":"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","file":"DebugAdapter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DebugSession, InitializedEvent, OutputEvent, TerminatedEvent, StoppedEvent } from \"vscode-debugadapter\";\nimport * as DebugProtocol from \"vscode-debugprotocol\";\nimport { AdapterChannel } from \"./channel/AdapterChannel.js\";\nimport invariant from \"./../common/invariant.js\";\nimport { DebugMessage } from \"./../common/channel/DebugMessage.js\";\nimport type {\n  Breakpoint,\n  DebuggerResponse,\n  LaunchRequestArguments,\n  PrepackLaunchArguments,\n} from \"./../common/types.js\";\nimport { DebuggerConstants } from \"./../common/DebuggerConstants.js\";\n\n/* An implementation of an debugger adapter adhering to the VSCode Debug protocol\n * The adapter is responsible for communication between the UI and Prepack\n*/\nclass PrepackDebugSession extends DebugSession {\n  /**\n   * Creates a new debug adapter that is used for one debug session.\n   * We configure the default implementation of a debug adapter here.\n   */\n  constructor() {\n    super();\n    this.setDebuggerLinesStartAt1(true);\n    this.setDebuggerColumnsStartAt1(true);\n  }\n  _clientID: void | string;\n  _adapterChannel: AdapterChannel;\n\n  _generateDebugFilePath(direction: \"in\" | \"out\") {\n    let time = Date.now();\n    let filePath = \"/tmp/\";\n    if (direction === \"in\") {\n      filePath += `prepack-debug-engine2adapter-${time}.txt`;\n    } else {\n      filePath += `prepack-debug-adapter2engine-${time}.txt`;\n    }\n    return filePath;\n  }\n\n  _registerMessageCallbacks() {\n    this._adapterChannel.registerChannelEvent(DebugMessage.STOPPED_RESPONSE, (response: DebuggerResponse) => {\n      let result = response.result;\n      invariant(result.kind === \"stopped\");\n      this.sendEvent(\n        new StoppedEvent(\n          `${result.reason}: ${result.filePath} ${result.line}:${result.column}`,\n          DebuggerConstants.PREPACK_THREAD_ID\n        )\n      );\n    });\n    this._adapterChannel.registerChannelEvent(DebugMessage.STEPINTO_RESPONSE, (response: DebuggerResponse) => {\n      let result = response.result;\n      invariant(result.kind === \"stepInto\");\n      this.sendEvent(\n        new StoppedEvent(\n          \"Stepped into \" + `${result.filePath} ${result.line}:${result.column}`,\n          DebuggerConstants.PREPACK_THREAD_ID\n        )\n      );\n    });\n  }\n\n  /**\n   * The 'initialize' request is the first request called by the UI\n   * to interrogate the features the debug adapter provides.\n   */\n  // Override\n  initializeRequest(response: DebugProtocol.InitializeResponse, args: DebugProtocol.InitializeRequestArguments): void {\n    // Let the UI know that we can start accepting breakpoint requests.\n    // The UI will end the configuration sequence by calling 'configurationDone' request.\n    this.sendEvent(new InitializedEvent());\n\n    this._clientID = args.clientID;\n    response.body = response.body || {};\n    response.body.supportsConfigurationDoneRequest = true;\n    // Respond back to the UI with the configurations. Will add more configurations gradually as needed.\n    // Adapter can respond immediately here because no message is sent to Prepack\n    this.sendResponse(response);\n  }\n\n  // Override\n  configurationDoneRequest(\n    response: DebugProtocol.ConfigurationDoneResponse,\n    args: DebugProtocol.ConfigurationDoneArguments\n  ): void {\n    // initial handshake with UI is complete\n    if (this._clientID !== DebuggerConstants.CLI_CLIENTID) {\n      // for all ui except the CLI, autosend the first run request\n      this._adapterChannel.run(DebuggerConstants.DEFAULT_REQUEST_ID, (runResponse: DebuggerResponse) => {});\n    }\n    this.sendResponse(response);\n  }\n\n  // Override\n  launchRequest(response: DebugProtocol.LaunchResponse, args: LaunchRequestArguments): void {\n    let inFilePath = this._generateDebugFilePath(\"in\");\n    let outFilePath = this._generateDebugFilePath(\"out\");\n    // set up the communication channel\n    this._adapterChannel = new AdapterChannel(inFilePath, outFilePath);\n    this._registerMessageCallbacks();\n    let launchArgs: PrepackLaunchArguments = {\n      kind: \"launch\",\n      sourceFile: args.sourceFile,\n      prepackRuntime: args.prepackRuntime,\n      prepackArguments: args.prepackArguments,\n      debugInFilePath: inFilePath,\n      debugOutFilePath: outFilePath,\n      outputCallback: (data: Buffer) => {\n        let outputEvent = new OutputEvent(data.toString(), \"stdout\");\n        this.sendEvent(outputEvent);\n      },\n      exitCallback: () => {\n        this.sendEvent(new TerminatedEvent());\n        process.exit();\n      },\n    };\n    this._adapterChannel.launch(response.request_seq, launchArgs, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  /**\n   * Request Prepack to continue running when it is stopped\n  */\n  // Override\n  continueRequest(response: DebugProtocol.ContinueResponse, args: DebugProtocol.ContinueArguments): void {\n    // send a Run request to Prepack and try to send the next request\n    this._adapterChannel.run(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  setBreakPointsRequest(\n    response: DebugProtocol.SetBreakpointsResponse,\n    args: DebugProtocol.SetBreakpointsArguments\n  ): void {\n    if (!args.source.path || !args.breakpoints) return;\n    let filePath = args.source.path;\n    let breakpointInfos = [];\n    for (const breakpoint of args.breakpoints) {\n      let line = breakpoint.line;\n      let column = 0;\n      if (breakpoint.column) {\n        column = breakpoint.column;\n      }\n      let breakpointInfo: Breakpoint = {\n        kind: \"breakpoint\",\n        requestID: response.request_seq,\n        filePath: filePath,\n        line: line,\n        column: column,\n      };\n      breakpointInfos.push(breakpointInfo);\n    }\n    this._adapterChannel.setBreakpoints(response.request_seq, breakpointInfos, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"breakpoint-add\");\n      let breakpoints: Array<DebugProtocol.Breakpoint> = [];\n      for (const breakpointInfo of result.breakpoints) {\n        let source: DebugProtocol.Source = {\n          path: breakpointInfo.filePath,\n        };\n        let breakpoint: DebugProtocol.Breakpoint = {\n          verified: true,\n          source: source,\n          line: breakpointInfo.line,\n          column: breakpointInfo.column,\n        };\n        breakpoints.push(breakpoint);\n      }\n      response.body = {\n        breakpoints: breakpoints,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  stackTraceRequest(response: DebugProtocol.StackTraceResponse, args: DebugProtocol.StackTraceArguments): void {\n    this._adapterChannel.getStackFrames(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"stackframe\");\n      let frameInfos = result.stackframes;\n      let frames: Array<DebugProtocol.StackFrame> = [];\n      for (const frameInfo of frameInfos) {\n        let source: DebugProtocol.Source = {\n          path: frameInfo.fileName,\n        };\n        let frame: DebugProtocol.StackFrame = {\n          id: frameInfo.id,\n          name: frameInfo.functionName,\n          source: source,\n          line: frameInfo.line,\n          column: frameInfo.column,\n        };\n        frames.push(frame);\n      }\n      response.body = {\n        stackFrames: frames,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  threadsRequest(response: DebugProtocol.ThreadsResponse): void {\n    // There will only be 1 thread, so respond immediately\n    let thread: DebugProtocol.Thread = {\n      id: DebuggerConstants.PREPACK_THREAD_ID,\n      name: \"main\",\n    };\n    response.body = {\n      threads: [thread],\n    };\n    this.sendResponse(response);\n  }\n\n  // Override\n  scopesRequest(response: DebugProtocol.ScopesResponse, args: DebugProtocol.ScopesArguments): void {\n    this._adapterChannel.getScopes(response.request_seq, args.frameId, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"scopes\");\n      let scopeInfos = result.scopes;\n      let scopes: Array<DebugProtocol.Scope> = [];\n      for (const scopeInfo of scopeInfos) {\n        let scope: DebugProtocol.Scope = {\n          name: scopeInfo.name,\n          variablesReference: scopeInfo.variablesReference,\n          expensive: scopeInfo.expensive,\n        };\n        scopes.push(scope);\n      }\n      response.body = {\n        scopes: scopes,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  variablesRequest(response: DebugProtocol.VariablesResponse, args: DebugProtocol.VariablesArguments): void {\n    this._adapterChannel.getVariables(\n      response.request_seq,\n      args.variablesReference,\n      (dbgResponse: DebuggerResponse) => {\n        let result = dbgResponse.result;\n        invariant(result.kind === \"variables\");\n        let variableInfos = result.variables;\n        let variables: Array<DebugProtocol.Variable> = [];\n        for (const varInfo of variableInfos) {\n          let variable: DebugProtocol.Variable = {\n            name: varInfo.name,\n            value: varInfo.value,\n            variablesReference: varInfo.variablesReference,\n          };\n          variables.push(variable);\n        }\n        response.body = {\n          variables: variables,\n        };\n        this.sendResponse(response);\n      }\n    );\n  }\n\n  // Override\n  stepInRequest(response: DebugProtocol.StepInResponse, args: DebugProtocol.StepInArguments): void {\n    this._adapterChannel.stepInto(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  nextRequest(response: DebugProtocol.NextResponse, args: DebugProtocol.NextArguments): void {\n    this._adapterChannel.stepOver(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  evaluateRequest(response: DebugProtocol.EvaluateResponse, args: DebugProtocol.EvaluateArguments): void {\n    this._adapterChannel.evaluate(\n      response.request_seq,\n      args.frameId,\n      args.expression,\n      (dbgResponse: DebuggerResponse) => {\n        let evalResult = dbgResponse.result;\n        invariant(evalResult.kind === \"evaluate\");\n        response.body = {\n          result: evalResult.displayValue,\n          type: evalResult.type,\n          variablesReference: evalResult.variablesReference,\n        };\n        this.sendResponse(response);\n      }\n    );\n  }\n}\n\nDebugSession.run(PrepackDebugSession);\n"]}